# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi hidden-definitions

# typed: autogenerated

module Addressable::IDNA
  extend ::T::Sig
end

module Addressable::URI::CharacterClasses
  extend ::T::Sig
end

module Addressable::VERSION
  extend ::T::Sig
end

module Addressable
  extend ::T::Sig
end

class Addrinfo
  extend ::T::Sig
end

class ArgumentError
  extend ::T::Sig
end

class Array
  include ::PSON::Pure::Generator::GeneratorMethods::Array
  include ::JSON::Ext::Generator::GeneratorMethods::Array
  def abbrev(pattern=T.unsafe(nil)); end

  def bsearch(); end

  def bsearch_index(); end

  def collect!(); end

  def dig(*_); end

  def flatten!(*_); end

  def pack(_); end

  def replace(_); end

  def shelljoin(); end

  def to_h(); end
end

class Array
  extend ::T::Sig
  def self.try_convert(_); end
end

module Base64
  extend ::T::Sig
end

class BasicObject
  def should(matcher=T.unsafe(nil), message=T.unsafe(nil), &block); end

  def should_not(matcher=T.unsafe(nil), message=T.unsafe(nil), &block); end
end

BasicObject::BasicObject = BasicObject

class BasicObject
  extend ::T::Sig
end

class BasicSocket
  extend ::T::Sig
end

class Benchmark::Job
  def initialize(width); end

  def item(label=T.unsafe(nil), &blk); end

  def list(); end

  def report(label=T.unsafe(nil), &blk); end

  def width(); end
end

class Benchmark::Job
  extend ::T::Sig
end

class Benchmark::Report
  def initialize(width=T.unsafe(nil), format=T.unsafe(nil)); end

  def item(label=T.unsafe(nil), *format, &blk); end

  def list(); end

  def report(label=T.unsafe(nil), *format, &blk); end
end

class Benchmark::Report
  extend ::T::Sig
end

class Benchmark::Tms
  def *(x); end

  def +(other); end

  def -(other); end

  def /(x); end

  def add(&blk); end

  def add!(&blk); end

  def cstime(); end

  def cutime(); end

  def format(format=T.unsafe(nil), *args); end

  def initialize(utime=T.unsafe(nil), stime=T.unsafe(nil), cutime=T.unsafe(nil), cstime=T.unsafe(nil), real=T.unsafe(nil), label=T.unsafe(nil)); end

  def label(); end

  def memberwise(op, x); end

  def real(); end

  def stime(); end

  def to_a(); end

  def total(); end

  def utime(); end
end

class Benchmark::Tms
  extend ::T::Sig
end

module Benchmark
  extend ::T::Sig
end

class Benchmarker
  include ::FileUtils::StreamUtils_
end

class BigDecimal
  EXCEPTION_NaN = ::T.let(nil, ::T.untyped)
  SIGN_NaN = ::T.let(nil, ::T.untyped)
end

class BigDecimal
  extend ::T::Sig
  def self._load(_); end

  def self.double_fig(); end

  def self.limit(*_); end

  def self.mode(*_); end

  def self.save_exception_mode(); end

  def self.save_limit(); end

  def self.save_rounding_mode(); end

  def self.ver(); end
end

module BigMath
  extend ::T::Sig
end

class Binding
  def local_variable_defined?(_); end

  def local_variable_get(_); end

  def local_variable_set(_, _1); end

  def receiver(); end
end

class Binding
  extend ::T::Sig
end

module Bundler::BuildMetadata
  extend ::T::Sig
end

class Bundler::CurrentRuby
  def jruby_27?(); end

  def maglev_27?(); end

  def mingw_27?(); end

  def mri_27?(); end

  def mswin64_27?(); end

  def mswin_27?(); end

  def on_27?(); end

  def rbx_27?(); end

  def ruby_27?(); end

  def truffleruby_27?(); end

  def x64_mingw_27?(); end
end

Bundler::Deprecate = Gem::Deprecate

class Bundler::Env
end

class Bundler::Env
  def self.environment(); end

  def self.report(options=T.unsafe(nil)); end

  def self.write(io); end
end

class Bundler::FeatureFlag
  def github_https?(); end

  def lockfile_upgrade_warning?(); end
end

class Bundler::Fetcher
  def fetch_spec(spec); end

  def fetchers(); end

  def http_proxy(); end

  def initialize(remote); end

  def specs(gem_names, source); end

  def specs_with_retry(gem_names, source); end

  def uri(); end

  def use_api(); end

  def user_agent(); end
  FAIL_ERRORS = ::T.let(nil, ::T.untyped)
  FETCHERS = ::T.let(nil, ::T.untyped)
  HTTP_ERRORS = ::T.let(nil, ::T.untyped)
  NET_ERRORS = ::T.let(nil, ::T.untyped)
end

class Bundler::Fetcher::AuthenticationRequiredError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::AuthenticationRequiredError
end

class Bundler::Fetcher::BadAuthenticationError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::BadAuthenticationError
end

class Bundler::Fetcher::Base
  def api_fetcher?(); end

  def available?(); end

  def display_uri(); end

  def downloader(); end

  def fetch_uri(); end

  def initialize(downloader, remote, display_uri); end

  def remote(); end

  def remote_uri(); end
end

class Bundler::Fetcher::Base
end

class Bundler::Fetcher::CertificateFailureError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::CertificateFailureError
end

class Bundler::Fetcher::CompactIndex
  def available?(*args, &blk); end

  def fetch_spec(*args, &blk); end

  def specs(*args, &blk); end

  def specs_for_names(gem_names); end
end

class Bundler::Fetcher::CompactIndex::ClientFetcher
  def call(path, headers); end

  def fetcher(); end

  def fetcher=(_); end

  def ui(); end

  def ui=(_); end
end

class Bundler::Fetcher::CompactIndex::ClientFetcher
  def self.[](*_); end

  def self.members(); end
end

class Bundler::Fetcher::CompactIndex
  def self.compact_index_request(method_name); end
end

class Bundler::Fetcher::Dependency
  def dependency_api_uri(gem_names=T.unsafe(nil)); end

  def dependency_specs(gem_names); end

  def get_formatted_specs_and_deps(gem_list); end

  def specs(gem_names, full_dependency_list=T.unsafe(nil), last_spec_list=T.unsafe(nil)); end

  def unmarshalled_dep_gems(gem_names); end
end

class Bundler::Fetcher::Dependency
end

class Bundler::Fetcher::Downloader
  def connection(); end

  def fetch(uri, headers=T.unsafe(nil), counter=T.unsafe(nil)); end

  def initialize(connection, redirect_limit); end

  def redirect_limit(); end

  def request(uri, headers); end
end

class Bundler::Fetcher::Downloader
end

class Bundler::Fetcher::FallbackError
end

class Bundler::Fetcher::FallbackError
end

class Bundler::Fetcher::Index
  def fetch_spec(spec); end

  def specs(_gem_names); end
end

class Bundler::Fetcher::Index
end

class Bundler::Fetcher::NetworkDownError
end

class Bundler::Fetcher::NetworkDownError
end

class Bundler::Fetcher::SSLError
  def initialize(msg=T.unsafe(nil)); end
end

class Bundler::Fetcher::SSLError
end

class Bundler::Fetcher
  def self.api_timeout(); end

  def self.api_timeout=(api_timeout); end

  def self.disable_endpoint(); end

  def self.disable_endpoint=(disable_endpoint); end

  def self.max_retries(); end

  def self.max_retries=(max_retries); end

  def self.redirect_limit(); end

  def self.redirect_limit=(redirect_limit); end
end

class Bundler::GemHelper
  def allowed_push_host(); end

  def already_tagged?(); end

  def base(); end

  def build_gem(); end

  def built_gem_path(); end

  def clean?(); end

  def committed?(); end

  def gem_key(); end

  def gem_push?(); end

  def gem_push_host(); end

  def gemspec(); end

  def git_push(remote=T.unsafe(nil)); end

  def guard_clean(); end

  def initialize(base=T.unsafe(nil), name=T.unsafe(nil)); end

  def install(); end

  def install_gem(built_gem_path=T.unsafe(nil), local=T.unsafe(nil)); end

  def name(); end

  def perform_git_push(options=T.unsafe(nil)); end

  def rubygem_push(path); end

  def sh(cmd, &block); end

  def sh_with_code(cmd, &block); end

  def spec_path(); end

  def tag_version(); end

  def version(); end

  def version_tag(); end
end

class Bundler::GemHelper
  def self.gemspec(&block); end

  def self.install_tasks(opts=T.unsafe(nil)); end

  def self.instance(); end

  def self.instance=(instance); end
end

module Bundler::GemHelpers
  extend ::T::Sig
end

class Bundler::GemRemoteFetcher
end

class Bundler::GemRemoteFetcher
end

class Bundler::GemVersionPromoter
  def initialize(locked_specs=T.unsafe(nil), unlock_gems=T.unsafe(nil)); end

  def level(); end

  def level=(value); end

  def locked_specs(); end

  def major?(); end

  def minor?(); end

  def prerelease_specified(); end

  def prerelease_specified=(prerelease_specified); end

  def sort_versions(dep, spec_groups); end

  def strict(); end

  def strict=(strict); end

  def unlock_gems(); end
  DEBUG = ::T.let(nil, ::T.untyped)
end

class Bundler::GemVersionPromoter
end

class Bundler::Graph
  def edge_options(); end

  def groups(); end

  def initialize(env, output_file, show_version=T.unsafe(nil), show_requirements=T.unsafe(nil), output_format=T.unsafe(nil), without=T.unsafe(nil)); end

  def node_options(); end

  def output_file(); end

  def output_format(); end

  def relations(); end

  def viz(); end
  GRAPH_NAME = ::T.let(nil, ::T.untyped)
end

class Bundler::Graph::GraphVizClient
  def g(); end

  def initialize(graph_instance); end

  def run(); end
end

class Bundler::Graph::GraphVizClient
end

class Bundler::Graph
end

class Bundler::Injector
  def initialize(deps, options=T.unsafe(nil)); end

  def inject(gemfile_path, lockfile_path); end

  def remove(gemfile_path, lockfile_path); end
  INJECTED_GEMS = ::T.let(nil, ::T.untyped)
end

class Bundler::Injector
  def self.inject(new_deps, options=T.unsafe(nil)); end

  def self.remove(gems, options=T.unsafe(nil)); end
end

class Bundler::Installer
  def generate_bundler_executable_stubs(spec, options=T.unsafe(nil)); end

  def generate_standalone_bundler_executable_stubs(spec); end

  def initialize(root, definition); end

  def post_install_messages(); end

  def run(options); end
end

class Bundler::Installer
  def self.ambiguous_gems(); end

  def self.ambiguous_gems=(ambiguous_gems); end

  def self.install(root, definition, options=T.unsafe(nil)); end
end

module Bundler::MatchPlatform
  extend ::T::Sig
end

module Bundler::Molinillo::Compatibility
  extend ::T::Sig
end

module Bundler::Molinillo::Delegates::ResolutionState
  extend ::T::Sig
end

module Bundler::Molinillo::Delegates::SpecificationProvider
  extend ::T::Sig
end

module Bundler::Molinillo::Delegates
  extend ::T::Sig
end

module Bundler::Molinillo::SpecificationProvider
  extend ::T::Sig
end

module Bundler::Molinillo::UI
  extend ::T::Sig
end

module Bundler::Molinillo
  extend ::T::Sig
end

module Bundler::Plugin::API::Source
  def ==(other); end

  def app_cache_dirname(); end

  def app_cache_path(custom_path=T.unsafe(nil)); end

  def bundler_plugin_api_source?(); end

  def cache(spec, custom_path=T.unsafe(nil)); end

  def cached!(); end

  def can_lock?(spec); end

  def dependency_names(); end

  def dependency_names=(dependency_names); end

  def double_check_for(*_); end

  def eql?(other); end

  def fetch_gemspec_files(); end

  def gem_install_dir(); end

  def hash(); end

  def include?(other); end

  def initialize(opts); end

  def install(spec, opts); end

  def install_path(); end

  def installed?(); end

  def name(); end

  def options(); end

  def options_to_lock(); end

  def post_install(spec, disable_exts=T.unsafe(nil)); end

  def remote!(); end

  def root(); end

  def specs(); end

  def to_lock(); end

  def to_s(); end

  def unlock!(); end

  def unmet_deps(); end

  def uri(); end

  def uri_hash(); end
end

module Bundler::Plugin::API::Source
  extend ::T::Sig
end

class Bundler::Plugin::DSL
  def _gem(name, *args); end

  def inferred_plugins(); end

  def plugin(name, *args); end
end

class Bundler::Plugin::DSL::PluginGemfileError
end

class Bundler::Plugin::DSL::PluginGemfileError
end

class Bundler::Plugin::DSL
end

module Bundler::Plugin::Events
  GEM_AFTER_INSTALL = ::T.let(nil, ::T.untyped)
  GEM_AFTER_INSTALL_ALL = ::T.let(nil, ::T.untyped)
  GEM_BEFORE_INSTALL = ::T.let(nil, ::T.untyped)
  GEM_BEFORE_INSTALL_ALL = ::T.let(nil, ::T.untyped)
end

module Bundler::Plugin::Events
  extend ::T::Sig
  def self.defined_event?(event); end
end

class Bundler::Plugin::Index
  def command_plugin(command); end

  def commands(); end

  def global_index_file(); end

  def hook_plugins(event); end

  def index_file(); end

  def installed?(name); end

  def load_paths(name); end

  def local_index_file(); end

  def plugin_path(name); end

  def register_plugin(name, path, load_paths, commands, sources, hooks); end

  def source?(source); end

  def source_plugin(name); end
end

class Bundler::Plugin::Index::CommandConflict
  def initialize(plugin, commands); end
end

class Bundler::Plugin::Index::CommandConflict
end

class Bundler::Plugin::Index::SourceConflict
  def initialize(plugin, sources); end
end

class Bundler::Plugin::Index::SourceConflict
end

class Bundler::Plugin::Index
end

class Bundler::Plugin::Installer
  def install(names, options); end

  def install_definition(definition); end
end

class Bundler::Plugin::Installer::Git
  def generate_bin(spec, disable_extensions=T.unsafe(nil)); end
end

class Bundler::Plugin::Installer::Git
end

class Bundler::Plugin::Installer::Rubygems
end

class Bundler::Plugin::Installer::Rubygems
end

class Bundler::Plugin::Installer
end

class Bundler::Plugin::SourceList
end

class Bundler::Plugin::SourceList
end

module Bundler::Plugin
  extend ::T::Sig
end

class Bundler::ProcessLock
end

class Bundler::ProcessLock
  def self.lock(bundle_path=T.unsafe(nil)); end
end

class Bundler::Retry
  def attempt(&block); end

  def attempts(&block); end

  def current_run(); end

  def current_run=(current_run); end

  def initialize(name, exceptions=T.unsafe(nil), retries=T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def total_runs(); end

  def total_runs=(total_runs); end
end

class Bundler::Retry
  def self.attempts(); end

  def self.default_attempts(); end

  def self.default_retries(); end
end

module Bundler::RubyDsl
  extend ::T::Sig
end

class Bundler::RubyGemsGemInstaller
end

class Bundler::RubyGemsGemInstaller
end

class Bundler::Settings::Mirror
  def ==(other); end

  def fallback_timeout(); end

  def fallback_timeout=(timeout); end

  def initialize(uri=T.unsafe(nil), fallback_timeout=T.unsafe(nil)); end

  def uri(); end

  def uri=(uri); end

  def valid?(); end

  def validate!(probe=T.unsafe(nil)); end
  DEFAULT_FALLBACK_TIMEOUT = ::T.let(nil, ::T.untyped)
end

class Bundler::Settings::Mirror
end

class Bundler::Settings::Mirrors
  def each(); end

  def for(uri); end

  def initialize(prober=T.unsafe(nil)); end

  def parse(key, value); end
end

class Bundler::Settings::Mirrors
end

class Bundler::Settings::Validator
end

class Bundler::Settings::Validator::Rule
  def description(); end

  def fail!(key, value, *reasons); end

  def initialize(keys, description, &validate); end

  def k(key); end

  def set(settings, key, value, *reasons); end

  def validate!(key, value, settings); end
end

class Bundler::Settings::Validator::Rule
end

class Bundler::Settings::Validator
  def self.validate!(key, value, settings); end
end

module Bundler::SharedHelpers
  extend ::T::Sig
end

class Bundler::UI::RGProxy
end

class Bundler::UI::Shell
  def add_color(string, *color); end

  def ask(msg); end

  def confirm(msg, newline=T.unsafe(nil)); end

  def debug(msg, newline=T.unsafe(nil)); end

  def debug?(); end

  def error(msg, newline=T.unsafe(nil)); end

  def info(msg, newline=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def level(name=T.unsafe(nil)); end

  def level=(level); end

  def no?(); end

  def quiet?(); end

  def shell=(shell); end

  def silence(&blk); end

  def trace(e, newline=T.unsafe(nil), force=T.unsafe(nil)); end

  def unprinted_warnings(); end

  def warn(msg, newline=T.unsafe(nil)); end

  def yes?(msg); end
  LEVELS = ::T.let(nil, ::T.untyped)
end

class Bundler::UI::Shell
end

module Bundler::UI
  extend ::T::Sig
end

module Bundler::URICredentialsFilter
  extend ::T::Sig
end

module Bundler::VersionRanges
end

class Bundler::VersionRanges::NEq
  def version(); end

  def version=(_); end
end

class Bundler::VersionRanges::NEq
  def self.[](*_); end

  def self.members(); end
end

class Bundler::VersionRanges::ReqR
  def cover?(v); end

  def empty?(); end

  def left(); end

  def left=(_); end

  def right(); end

  def right=(_); end

  def single?(); end
  INFINITY = ::T.let(nil, ::T.untyped)
  UNIVERSAL = ::T.let(nil, ::T.untyped)
  ZERO = ::T.let(nil, ::T.untyped)
end

class Bundler::VersionRanges::ReqR::Endpoint
  def inclusive(); end

  def inclusive=(_); end

  def version(); end

  def version=(_); end
end

class Bundler::VersionRanges::ReqR::Endpoint
  def self.[](*_); end

  def self.members(); end
end

class Bundler::VersionRanges::ReqR
  def self.[](*_); end

  def self.members(); end
end

module Bundler::VersionRanges
  extend ::T::Sig
  def self.empty?(ranges, neqs); end

  def self.for(requirement); end

  def self.for_many(requirements); end
end

module Bundler::YAMLSerializer
  extend ::T::Sig
end

module Bundler
  extend ::T::Sig
end

class Byebug::Breakpoint
  def enabled=(enabled); end

  def enabled?(); end

  def expr(); end

  def expr=(expr); end

  def hit_condition(); end

  def hit_condition=(hit_condition); end

  def hit_count(); end

  def hit_value(); end

  def hit_value=(hit_value); end

  def id(); end

  def initialize(_, _1, _2); end

  def pos(); end

  def source(); end
end

class Byebug::Command
  def confirm(*args, &block); end

  def errmsg(*args, &block); end

  def help(*args, &block); end

  def match(*args, &block); end

  def pr(*args, &block); end

  def prc(*args, &block); end

  def print(*args, &block); end

  def prv(*args, &block); end

  def puts(*args, &block); end
end

class Byebug::CommandProcessor
  def commands(*args, &block); end

  def confirm(*args, &block); end

  def errmsg(*args, &block); end

  def frame(*args, &block); end

  def pr(*args, &block); end

  def prc(*args, &block); end

  def prv(*args, &block); end

  def puts(*args, &block); end
end

class Byebug::Context
  def backtrace(); end

  def dead?(); end

  def file(*args, &block); end

  def frame_binding(*_); end

  def frame_class(*_); end

  def frame_file(*_); end

  def frame_line(*_); end

  def frame_method(*_); end

  def frame_self(*_); end

  def ignored?(); end

  def line(*args, &block); end

  def resume(); end

  def step_into(*_); end

  def step_out(*_); end

  def step_over(*_); end

  def stop_reason(); end

  def suspend(); end

  def suspended?(); end

  def switch(); end

  def thnum(); end

  def thread(); end

  def tracing(); end

  def tracing=(tracing); end
end

class Byebug::DebugThread
end

class Byebug::DebugThread
end

class Byebug::DisableCommand
  extend ::Byebug::Subcommands::ClassMethods
  extend ::Byebug::Helpers::ReflectionHelper
end

class Byebug::EnableCommand
  extend ::Byebug::Subcommands::ClassMethods
  extend ::Byebug::Helpers::ReflectionHelper
end

module Byebug::Helpers::BinHelper
  extend ::T::Sig
end

module Byebug::Helpers::EvalHelper
  extend ::T::Sig
end

module Byebug::Helpers::FileHelper
  extend ::T::Sig
end

module Byebug::Helpers::FrameHelper
  extend ::T::Sig
end

module Byebug::Helpers::ParseHelper
  extend ::T::Sig
end

module Byebug::Helpers::PathHelper
  extend ::T::Sig
end

module Byebug::Helpers::ReflectionHelper
  extend ::T::Sig
end

module Byebug::Helpers::StringHelper
  extend ::T::Sig
end

module Byebug::Helpers::ThreadHelper
  extend ::T::Sig
end

module Byebug::Helpers::ToggleHelper
  extend ::T::Sig
end

module Byebug::Helpers::VarHelper
  extend ::T::Sig
end

module Byebug::Helpers
  extend ::T::Sig
end

class Byebug::InfoCommand
  extend ::Byebug::Subcommands::ClassMethods
  extend ::Byebug::Helpers::ReflectionHelper
end

class Byebug::ListCommand
  def amend_final(*args, &block); end

  def max_line(*args, &block); end

  def size(*args, &block); end
end

module Byebug::Printers
  extend ::T::Sig
end

module Byebug::Remote
  extend ::T::Sig
end

module Byebug::Subcommands
  def subcommand_list(*args, &block); end
end

module Byebug::Subcommands::ClassMethods
  extend ::T::Sig
end

module Byebug::Subcommands
  extend ::T::Sig
end

class Byebug::ThreadCommand
  extend ::Byebug::Subcommands::ClassMethods
  extend ::Byebug::Helpers::ReflectionHelper
end

class Byebug::ThreadsTable
end

class Byebug::ThreadsTable
end

class Byebug::VarCommand
  extend ::Byebug::Subcommands::ClassMethods
  extend ::Byebug::Helpers::ReflectionHelper
end

module Byebug
  extend ::T::Sig
end

class CFPropertyList::Binary
  def self.ascii_string?(str); end

  def self.bytes_needed(count); end

  def self.charset_convert(str, from, to=T.unsafe(nil)); end

  def self.charset_strlen(str, charset=T.unsafe(nil)); end

  def self.pack_int_array_with_size(nbytes, array); end

  def self.pack_it_with_size(nbytes, int); end

  def self.type_bytes(type, length); end
end

class CFPropertyList::CFDate
  def self.date_string(val); end

  def self.parse_date(val); end
end

module CFPropertyList
  extend ::T::Sig
end

class CGI::Cookie
  extend ::T::Sig
end

module CGI::Escape
  extend ::T::Sig
end

module CGI::HtmlExtension
  def a(href=T.unsafe(nil)); end

  def base(href=T.unsafe(nil)); end

  def blockquote(cite=T.unsafe(nil)); end

  def caption(align=T.unsafe(nil)); end

  def checkbox(name=T.unsafe(nil), value=T.unsafe(nil), checked=T.unsafe(nil)); end

  def checkbox_group(name=T.unsafe(nil), *values); end

  def file_field(name=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def form(method=T.unsafe(nil), action=T.unsafe(nil), enctype=T.unsafe(nil)); end

  def hidden(name=T.unsafe(nil), value=T.unsafe(nil)); end

  def html(attributes=T.unsafe(nil)); end

  def image_button(src=T.unsafe(nil), name=T.unsafe(nil), alt=T.unsafe(nil)); end

  def img(src=T.unsafe(nil), alt=T.unsafe(nil), width=T.unsafe(nil), height=T.unsafe(nil)); end

  def multipart_form(action=T.unsafe(nil), enctype=T.unsafe(nil)); end

  def password_field(name=T.unsafe(nil), value=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def popup_menu(name=T.unsafe(nil), *values); end

  def radio_button(name=T.unsafe(nil), value=T.unsafe(nil), checked=T.unsafe(nil)); end

  def radio_group(name=T.unsafe(nil), *values); end

  def reset(value=T.unsafe(nil), name=T.unsafe(nil)); end

  def scrolling_list(name=T.unsafe(nil), *values); end

  def submit(value=T.unsafe(nil), name=T.unsafe(nil)); end

  def text_field(name=T.unsafe(nil), value=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def textarea(name=T.unsafe(nil), cols=T.unsafe(nil), rows=T.unsafe(nil)); end
end

module CGI::HtmlExtension
  extend ::T::Sig
end

class CGI::InvalidEncoding
  extend ::T::Sig
end

module CGI::QueryExtension
  extend ::T::Sig
end

module CGI::Util
  extend ::T::Sig
end

class CGI
  extend ::T::Sig
end

class Class
  extend ::T::Sig
end

class ClosedQueueError
  extend ::T::Sig
end

module Comparable
  extend ::T::Sig
end

class Complex
  extend ::T::Sig
  def self.polar(*_); end

  def self.rect(*_); end

  def self.rectangular(*_); end
end

ConditionVariable = Thread::ConditionVariable

module ContainmentMatchers
  extend ::T::Sig
end

module DOT
  extend ::T::Sig
end

class Data
  extend ::T::Sig
end

class Date::Infinity
  def initialize(d=T.unsafe(nil)); end
end

class Date::Infinity
  extend ::T::Sig
end

class Date
  extend ::T::Sig
end

class DateTime
  extend ::T::Sig
end

module DeepMerge::DeepMergeHash
  extend ::T::Sig
end

module DeepMerge::RailsCompat
  extend ::T::Sig
end

module DeepMerge
  extend ::T::Sig
end

class Delegator
  def !=(obj); end

  def ==(obj); end

  def __getobj__(); end

  def __setobj__(obj); end

  def initialize(obj); end

  def marshal_dump(); end

  def marshal_load(data); end

  def method_missing(m, *args, &block); end

  def methods(all=T.unsafe(nil)); end

  def protected_methods(all=T.unsafe(nil)); end

  def public_methods(all=T.unsafe(nil)); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Delegator
  extend ::T::Sig
  def self.const_missing(n); end

  def self.delegating_block(mid); end

  def self.public_api(); end
end

class DidYouMean::ClassNameChecker
  extend ::T::Sig
end

module DidYouMean::Correctable
  extend ::T::Sig
end

class DidYouMean::Formatter
  extend ::T::Sig
end

module DidYouMean::Jaro
  extend ::T::Sig
end

module DidYouMean::JaroWinkler
  extend ::T::Sig
end

module DidYouMean::Levenshtein
  extend ::T::Sig
end

class DidYouMean::MethodNameChecker
  extend ::T::Sig
end

module DidYouMean::NameErrorCheckers
  extend ::T::Sig
end

class DidYouMean::NullChecker
  extend ::T::Sig
end

class DidYouMean::SpellChecker
  extend ::T::Sig
end

class DidYouMean::VariableNameChecker
  extend ::T::Sig
end

module DidYouMean
  extend ::T::Sig
end

class Digest::Base
  extend ::T::Sig
end

class Digest::Class
  extend ::T::Sig
end

module Digest::Instance
  extend ::T::Sig
end

class Digest::MD5
  extend ::T::Sig
end

class Digest::SHA1
  extend ::T::Sig
end

class Digest::SHA2
  extend ::T::Sig
end

class Digest::SHA256
  extend ::T::Sig
end

class Digest::SHA384
  extend ::T::Sig
end

class Digest::SHA512
  extend ::T::Sig
end

module Digest
  extend ::T::Sig
end

module Dir::Tmpname
  extend ::T::Sig
end

class Dir
  extend ::T::Sig
  def self.exists?(_); end

  def self.tmpdir(); end
end

class EOFError
  extend ::T::Sig
end

class ERB
  def def_method(mod, methodname, fname=T.unsafe(nil)); end

  def def_module(methodname=T.unsafe(nil)); end
end

class ERB::Compiler::Buffer
  extend ::T::Sig
end

class ERB::Compiler::ExplicitScanner
  extend ::T::Sig
end

class ERB::Compiler::PercentLine
  extend ::T::Sig
end

class ERB::Compiler::Scanner
  extend ::T::Sig
end

class ERB::Compiler::SimpleScanner
  extend ::T::Sig
end

class ERB::Compiler::TrimScanner
  extend ::T::Sig
end

class ERB::Compiler
  extend ::T::Sig
end

module ERB::DefMethod
  extend ::T::Sig
end

module ERB::Util
  extend ::T::Sig
end

class ERB
  extend ::T::Sig
end

class Encoding
  def _dump(*_); end
end

class Encoding::CompatibilityError
  extend ::T::Sig
end

class Encoding::Converter
  def convert(_); end

  def convpath(); end

  def destination_encoding(); end

  def finish(); end

  def initialize(*_); end

  def insert_output(_); end

  def last_error(); end

  def primitive_convert(*_); end

  def primitive_errinfo(); end

  def putback(*_); end

  def replacement(); end

  def replacement=(replacement); end

  def source_encoding(); end
end

class Encoding::Converter
  extend ::T::Sig
  def self.asciicompat_encoding(_); end

  def self.search_convpath(*_); end
end

class Encoding::ConverterNotFoundError
  extend ::T::Sig
end

class Encoding::InvalidByteSequenceError
  def destination_encoding(); end

  def destination_encoding_name(); end

  def error_bytes(); end

  def incomplete_input?(); end

  def readagain_bytes(); end

  def source_encoding(); end

  def source_encoding_name(); end
end

class Encoding::InvalidByteSequenceError
  extend ::T::Sig
end

class Encoding::UndefinedConversionError
  def destination_encoding(); end

  def destination_encoding_name(); end

  def error_char(); end

  def source_encoding(); end

  def source_encoding_name(); end
end

class Encoding::UndefinedConversionError
  extend ::T::Sig
end

class Encoding
  extend ::T::Sig
  def self._load(_); end

  def self.locale_charmap(); end
end

class EncodingError
  extend ::T::Sig
end

module Enumerable
  def chunk(); end

  def chunk_while(); end

  def each_entry(*_); end

  def each_with_object(_); end

  def grep_v(_); end

  def lazy(); end

  def slice_after(*_); end

  def slice_before(*_); end

  def slice_when(); end

  def to_set(klass=T.unsafe(nil), *args, &block); end

  def zip(*_); end
end

module Enumerable
  extend ::T::Sig
end

class Enumerator::Generator
  def each(*_); end

  def initialize(*_); end
end

class Enumerator::Generator
  extend ::T::Sig
end

class Enumerator::Lazy
  def chunk(*_); end

  def force(*_); end

  def slice_when(*_); end
end

class Enumerator::Lazy
  extend ::T::Sig
end

class Enumerator::Yielder
  extend ::T::Sig
end

class Enumerator
  extend ::T::Sig
end

class Errno::E2BIG
  extend ::T::Sig
end

class Errno::EACCES
  extend ::T::Sig
end

class Errno::EADDRINUSE
  extend ::T::Sig
end

class Errno::EADDRNOTAVAIL
  extend ::T::Sig
end

class Errno::EAFNOSUPPORT
  extend ::T::Sig
end

class Errno::EAGAIN
  extend ::T::Sig
end

class Errno::EALREADY
  extend ::T::Sig
end

class Errno::EAUTH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EAUTH
end

class Errno::EBADF
  extend ::T::Sig
end

class Errno::EBADMSG
  extend ::T::Sig
end

class Errno::EBADRPC
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADRPC
end

class Errno::EBUSY
  extend ::T::Sig
end

class Errno::ECANCELED
  extend ::T::Sig
end

Errno::ECAPMODE = Errno::NOERROR

class Errno::ECHILD
  extend ::T::Sig
end

class Errno::ECONNABORTED
  extend ::T::Sig
end

class Errno::ECONNREFUSED
  extend ::T::Sig
end

class Errno::ECONNRESET
  extend ::T::Sig
end

class Errno::EDEADLK
  extend ::T::Sig
end

Errno::EDEADLOCK = Errno::NOERROR

class Errno::EDESTADDRREQ
  extend ::T::Sig
end

class Errno::EDOM
  extend ::T::Sig
end

Errno::EDOOFUS = Errno::NOERROR

class Errno::EDQUOT
  extend ::T::Sig
end

class Errno::EEXIST
  extend ::T::Sig
end

class Errno::EFAULT
  extend ::T::Sig
end

class Errno::EFBIG
  extend ::T::Sig
end

class Errno::EFTYPE
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EFTYPE
end

class Errno::EHOSTDOWN
  extend ::T::Sig
end

class Errno::EHOSTUNREACH
  extend ::T::Sig
end

class Errno::EIDRM
  extend ::T::Sig
end

class Errno::EILSEQ
  extend ::T::Sig
end

class Errno::EINPROGRESS
  extend ::T::Sig
end

class Errno::EINTR
  extend ::T::Sig
end

class Errno::EINVAL
  extend ::T::Sig
end

class Errno::EIO
  extend ::T::Sig
end

Errno::EIPSEC = Errno::NOERROR

class Errno::EISCONN
  extend ::T::Sig
end

class Errno::EISDIR
  extend ::T::Sig
end

class Errno::ELOOP
  extend ::T::Sig
end

class Errno::EMFILE
  extend ::T::Sig
end

class Errno::EMLINK
  extend ::T::Sig
end

class Errno::EMSGSIZE
  extend ::T::Sig
end

class Errno::EMULTIHOP
  extend ::T::Sig
end

class Errno::ENAMETOOLONG
  extend ::T::Sig
end

class Errno::ENEEDAUTH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENEEDAUTH
end

class Errno::ENETDOWN
  extend ::T::Sig
end

class Errno::ENETRESET
  extend ::T::Sig
end

class Errno::ENETUNREACH
  extend ::T::Sig
end

class Errno::ENFILE
  extend ::T::Sig
end

class Errno::ENOATTR
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENOATTR
end

class Errno::ENOBUFS
  extend ::T::Sig
end

class Errno::ENODATA
  extend ::T::Sig
end

class Errno::ENODEV
  extend ::T::Sig
end

class Errno::ENOENT
  extend ::T::Sig
end

class Errno::ENOEXEC
  extend ::T::Sig
end

class Errno::ENOLCK
  extend ::T::Sig
end

class Errno::ENOLINK
  extend ::T::Sig
end

class Errno::ENOMEM
  extend ::T::Sig
end

class Errno::ENOMSG
  extend ::T::Sig
end

class Errno::ENOPROTOOPT
  extend ::T::Sig
end

class Errno::ENOSPC
  extend ::T::Sig
end

class Errno::ENOSR
  extend ::T::Sig
end

class Errno::ENOSTR
  extend ::T::Sig
end

class Errno::ENOSYS
  extend ::T::Sig
end

class Errno::ENOTBLK
  extend ::T::Sig
end

Errno::ENOTCAPABLE = Errno::NOERROR

class Errno::ENOTCONN
  extend ::T::Sig
end

class Errno::ENOTDIR
  extend ::T::Sig
end

class Errno::ENOTEMPTY
  extend ::T::Sig
end

class Errno::ENOTRECOVERABLE
  extend ::T::Sig
end

class Errno::ENOTSOCK
  extend ::T::Sig
end

class Errno::ENOTSUP
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENOTSUP
end

class Errno::ENOTTY
  extend ::T::Sig
end

class Errno::ENXIO
  extend ::T::Sig
end

class Errno::EOPNOTSUPP
  extend ::T::Sig
end

class Errno::EOVERFLOW
  extend ::T::Sig
end

class Errno::EOWNERDEAD
  extend ::T::Sig
end

class Errno::EPERM
  extend ::T::Sig
end

class Errno::EPFNOSUPPORT
  extend ::T::Sig
end

class Errno::EPIPE
  extend ::T::Sig
end

class Errno::EPROCLIM
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROCLIM
end

class Errno::EPROCUNAVAIL
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROCUNAVAIL
end

class Errno::EPROGMISMATCH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROGMISMATCH
end

class Errno::EPROGUNAVAIL
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROGUNAVAIL
end

class Errno::EPROTO
  extend ::T::Sig
end

class Errno::EPROTONOSUPPORT
  extend ::T::Sig
end

class Errno::EPROTOTYPE
  extend ::T::Sig
end

class Errno::ERANGE
  extend ::T::Sig
end

class Errno::EREMOTE
  extend ::T::Sig
end

class Errno::EROFS
  extend ::T::Sig
end

class Errno::ERPCMISMATCH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ERPCMISMATCH
end

class Errno::ESHUTDOWN
  extend ::T::Sig
end

class Errno::ESOCKTNOSUPPORT
  extend ::T::Sig
end

class Errno::ESPIPE
  extend ::T::Sig
end

class Errno::ESRCH
  extend ::T::Sig
end

class Errno::ESTALE
  extend ::T::Sig
end

class Errno::ETIME
  extend ::T::Sig
end

class Errno::ETIMEDOUT
  extend ::T::Sig
end

class Errno::ETOOMANYREFS
  extend ::T::Sig
end

class Errno::ETXTBSY
  extend ::T::Sig
end

class Errno::EUSERS
  extend ::T::Sig
end

class Errno::EXDEV
  extend ::T::Sig
end

class Errno::NOERROR
  extend ::T::Sig
end

module Errno
  extend ::T::Sig
end

class Etc::Group
  def gid(); end

  def gid=(_); end

  def mem(); end

  def mem=(_); end

  def name(); end

  def name=(_); end

  def passwd(); end

  def passwd=(_); end
end

class Etc::Group
  extend ::T::Sig
  extend ::Enumerable
  def self.[](*_); end

  def self.each(); end

  def self.members(); end
end

class Etc::Passwd
  def change(); end

  def change=(_); end

  def dir(); end

  def dir=(_); end

  def expire(); end

  def expire=(_); end

  def gecos(); end

  def gecos=(_); end

  def gid(); end

  def gid=(_); end

  def name(); end

  def name=(_); end

  def passwd(); end

  def passwd=(_); end

  def shell(); end

  def shell=(_); end

  def uclass(); end

  def uclass=(_); end

  def uid(); end

  def uid=(_); end
end

class Etc::Passwd
  extend ::T::Sig
  extend ::Enumerable
  def self.[](*_); end

  def self.each(); end

  def self.members(); end
end

module Etc
  extend ::T::Sig
  def self.confstr(_); end

  def self.endgrent(); end

  def self.endpwent(); end

  def self.getgrent(); end

  def self.getgrgid(*_); end

  def self.getgrnam(_); end

  def self.getlogin(); end

  def self.getpwent(); end

  def self.getpwnam(_); end

  def self.getpwuid(*_); end

  def self.group(); end

  def self.nprocessors(); end

  def self.passwd(); end

  def self.setgrent(); end

  def self.setpwent(); end

  def self.sysconf(_); end

  def self.sysconfdir(); end

  def self.systmpdir(); end

  def self.uname(); end
end

module EvaluatorRspecHelper
  extend ::T::Sig
end

class Exception
  extend ::T::Sig
  def self.exception(*_); end
end

module Exception2MessageMapper
  def bind(cl); end
end

Exception2MessageMapper::E2MM = Exception2MessageMapper

class Exception2MessageMapper::ErrNotRegisteredException
end

class Exception2MessageMapper::ErrNotRegisteredException
end

module Exception2MessageMapper
  extend ::T::Sig
  def self.Fail(klass=T.unsafe(nil), err=T.unsafe(nil), *rest); end

  def self.Raise(klass=T.unsafe(nil), err=T.unsafe(nil), *rest); end

  def self.def_e2message(k, c, m); end

  def self.def_exception(k, n, m, s=T.unsafe(nil)); end

  def self.e2mm_message(klass, exp); end

  def self.extend_object(cl); end

  def self.message(klass, exp); end
end

module Facter::Core::Execution
  extend ::T::Sig
end

module Facter::Core::Logging
  extend ::T::Sig
end

module Facter::Core::Resolvable
  extend ::T::Sig
end

module Facter::Core::Suitable
  extend ::T::Sig
end

module Facter::Core
  extend ::T::Sig
end

module Facter::Operatingsystem
  extend ::T::Sig
end

module Facter::Util::Config
  extend ::T::Sig
end

module Facter::Util::FileRead
  extend ::T::Sig
end

module Facter::Util::Normalization
  extend ::T::Sig
end

module Facter::Util::Operatingsystem
  extend ::T::Sig
end

module Facter::Util::POSIX
  extend ::T::Sig
end

module Facter::Util::Parser::KeyValuePairOutputFormat
  extend ::T::Sig
end

module Facter::Util::Parser
  extend ::T::Sig
end

module Facter::Util::Root
  extend ::T::Sig
end

module Facter::Util::Values
  extend ::T::Sig
end

module Facter::Util::Windows::Process
  extend ::T::Sig
end

module Facter::Util::Windows
  extend ::T::Sig
end

module Facter::Util
  extend ::T::Sig
end

module Facter
  extend ::T::Sig
end

module FactoryRspecHelper
  extend ::T::Sig
end

class FalseClass
  include ::PSON::Pure::Generator::GeneratorMethods::FalseClass
  include ::JSON::Ext::Generator::GeneratorMethods::FalseClass
end

class FalseClass
  extend ::T::Sig
end

module FastGettext
  def N_(*args); end

  def Nn_(*args); end

  def _(*args); end

  def n_(*args); end

  def ns_(*args); end

  def s_(*args); end
end

class FastGettext::GetText::MOFile::Header
  def self.[](*_); end

  def self.members(); end
end

module FastGettext::GetText
  extend ::T::Sig
end

module FastGettext::Storage
  def available_locales=(value); end

  def cache_class(); end

  def cache_class=(value); end

  def default_available_locales(); end

  def default_available_locales=(value); end

  def default_text_domain(); end

  def default_text_domain=(value); end

  def pluralisation_rule=(value); end

  def text_domain=(value); end
end

module FastGettext::Storage
  extend ::T::Sig
end

module FastGettext::Translation
  extend ::T::Sig
end

module FastGettext::TranslationMultidomain
  extend ::T::Sig
end

module FastGettext::TranslationRepository
  extend ::T::Sig
end

module FastGettext
  extend ::T::Sig
end

class Fiber
  def resume(*_); end
end

class Fiber
  extend ::T::Sig
  def self.yield(*_); end
end

class FiberError
  extend ::T::Sig
end

module Fiddle
  ALIGN_CHAR = ::T.let(nil, ::T.untyped)
  ALIGN_DOUBLE = ::T.let(nil, ::T.untyped)
  ALIGN_FLOAT = ::T.let(nil, ::T.untyped)
  ALIGN_INT = ::T.let(nil, ::T.untyped)
  ALIGN_INTPTR_T = ::T.let(nil, ::T.untyped)
  ALIGN_LONG = ::T.let(nil, ::T.untyped)
  ALIGN_LONG_LONG = ::T.let(nil, ::T.untyped)
  ALIGN_PTRDIFF_T = ::T.let(nil, ::T.untyped)
  ALIGN_SHORT = ::T.let(nil, ::T.untyped)
  ALIGN_SIZE_T = ::T.let(nil, ::T.untyped)
  ALIGN_SSIZE_T = ::T.let(nil, ::T.untyped)
  ALIGN_UINTPTR_T = ::T.let(nil, ::T.untyped)
  ALIGN_VOIDP = ::T.let(nil, ::T.untyped)
  BUILD_RUBY_PLATFORM = ::T.let(nil, ::T.untyped)
  NULL = ::T.let(nil, ::T.untyped)
  RTLD_GLOBAL = ::T.let(nil, ::T.untyped)
  RTLD_LAZY = ::T.let(nil, ::T.untyped)
  RTLD_NOW = ::T.let(nil, ::T.untyped)
  RUBY_FREE = ::T.let(nil, ::T.untyped)
  SIZEOF_CHAR = ::T.let(nil, ::T.untyped)
  SIZEOF_DOUBLE = ::T.let(nil, ::T.untyped)
  SIZEOF_FLOAT = ::T.let(nil, ::T.untyped)
  SIZEOF_INT = ::T.let(nil, ::T.untyped)
  SIZEOF_INTPTR_T = ::T.let(nil, ::T.untyped)
  SIZEOF_LONG = ::T.let(nil, ::T.untyped)
  SIZEOF_LONG_LONG = ::T.let(nil, ::T.untyped)
  SIZEOF_PTRDIFF_T = ::T.let(nil, ::T.untyped)
  SIZEOF_SHORT = ::T.let(nil, ::T.untyped)
  SIZEOF_SIZE_T = ::T.let(nil, ::T.untyped)
  SIZEOF_SSIZE_T = ::T.let(nil, ::T.untyped)
  SIZEOF_UINTPTR_T = ::T.let(nil, ::T.untyped)
  SIZEOF_VOIDP = ::T.let(nil, ::T.untyped)
  TYPE_CHAR = ::T.let(nil, ::T.untyped)
  TYPE_DOUBLE = ::T.let(nil, ::T.untyped)
  TYPE_FLOAT = ::T.let(nil, ::T.untyped)
  TYPE_INT = ::T.let(nil, ::T.untyped)
  TYPE_INTPTR_T = ::T.let(nil, ::T.untyped)
  TYPE_LONG = ::T.let(nil, ::T.untyped)
  TYPE_LONG_LONG = ::T.let(nil, ::T.untyped)
  TYPE_PTRDIFF_T = ::T.let(nil, ::T.untyped)
  TYPE_SHORT = ::T.let(nil, ::T.untyped)
  TYPE_SIZE_T = ::T.let(nil, ::T.untyped)
  TYPE_SSIZE_T = ::T.let(nil, ::T.untyped)
  TYPE_UINTPTR_T = ::T.let(nil, ::T.untyped)
  TYPE_VOID = ::T.let(nil, ::T.untyped)
  TYPE_VOIDP = ::T.let(nil, ::T.untyped)
  WINDOWS = ::T.let(nil, ::T.untyped)
end

class Fiddle::Closure
  def args(); end

  def ctype(); end

  def initialize(*_); end

  def to_i(); end
end

class Fiddle::Closure::BlockCaller
  def call(*args); end

  def initialize(ctype, args, abi=T.unsafe(nil), &block); end
end

class Fiddle::Closure::BlockCaller
end

class Fiddle::Closure
end

class Fiddle::DLError
end

class Fiddle::DLError
end

class Fiddle::Function
  def abi(); end

  def call(*_); end

  def initialize(*_); end

  def name(); end

  def ptr(); end

  def to_i(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Fiddle::Function
end

class Fiddle::Handle
  def [](_); end

  def close(); end

  def close_enabled?(); end

  def disable_close(); end

  def enable_close(); end

  def initialize(*_); end

  def sym(_); end

  def to_i(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
  NEXT = ::T.let(nil, ::T.untyped)
  RTLD_GLOBAL = ::T.let(nil, ::T.untyped)
  RTLD_LAZY = ::T.let(nil, ::T.untyped)
  RTLD_NOW = ::T.let(nil, ::T.untyped)
end

class Fiddle::Handle
  def self.[](_); end

  def self.sym(_); end
end

class Fiddle::Pointer
  def +(_); end

  def +@(); end

  def -(_); end

  def -@(); end

  def [](*_); end

  def []=(*_); end

  def free(); end

  def free=(free); end

  def initialize(*_); end

  def null?(); end

  def ptr(); end

  def ref(); end

  def size(); end

  def size=(size); end

  def to_i(); end

  def to_int(); end

  def to_s(*_); end

  def to_str(*_); end

  def to_value(); end
end

class Fiddle::Pointer
  def self.[](_); end

  def self.malloc(*_); end

  def self.to_ptr(_); end
end

module Fiddle
  extend ::T::Sig
  def self.dlopen(library); end

  def self.dlunwrap(_); end

  def self.dlwrap(_); end

  def self.free(_); end

  def self.last_error(); end

  def self.last_error=(error); end

  def self.malloc(_); end

  def self.realloc(_, _1); end
end

class File
  Separator = ::T.let(nil, ::T.untyped)
end

module File::Constants
  extend ::T::Sig
end

class File::Stat
  def size?(); end
end

class File::Stat
  extend ::T::Sig
end

class File
  extend ::T::Sig
  def self.exists?(_); end

  def self.mkfifo(*_); end

end

module FileTest
  extend ::T::Sig
  def self.blockdev?(_); end

  def self.chardev?(_); end

  def self.directory?(_); end

  def self.executable?(_); end

  def self.executable_real?(_); end

  def self.exist?(_); end

  def self.exists?(_); end

  def self.file?(_); end

  def self.grpowned?(_); end

  def self.identical?(_, _1); end

  def self.owned?(_); end

  def self.pipe?(_); end

  def self.readable?(_); end

  def self.readable_real?(_); end

  def self.setgid?(_); end

  def self.setuid?(_); end

  def self.size(_); end

  def self.size?(_); end

  def self.socket?(_); end

  def self.sticky?(_); end

  def self.symlink?(_); end

  def self.world_readable?(_); end

  def self.world_writable?(_); end

  def self.writable?(_); end

  def self.writable_real?(_); end

  def self.zero?(_); end
end

module FileUtils
  include ::FileUtils::StreamUtils_
end

module FileUtils::DryRun
  include ::FileUtils::LowMethods
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

module FileUtils::DryRun
  extend ::T::Sig
  extend ::FileUtils::DryRun
  extend ::FileUtils::LowMethods
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
end

class FileUtils::Entry_
  def blockdev?(); end

  def chardev?(); end

  def chmod(mode); end

  def chown(uid, gid); end

  def copy(dest); end

  def copy_file(dest); end

  def copy_metadata(path); end

  def dereference?(); end

  def directory?(); end

  def door?(); end

  def entries(); end

  def exist?(); end

  def file?(); end

  def initialize(a, b=T.unsafe(nil), deref=T.unsafe(nil)); end

  def lstat(); end

  def lstat!(); end

  def path(); end

  def pipe?(); end

  def platform_support(); end

  def postorder_traverse(); end

  def prefix(); end

  def preorder_traverse(); end

  def rel(); end

  def remove(); end

  def remove_dir1(); end

  def remove_file(); end

  def socket?(); end

  def stat(); end

  def stat!(); end

  def symlink?(); end

  def traverse(); end

  def wrap_traverse(pre, post); end
end

class FileUtils::Entry_
  extend ::T::Sig
end

module FileUtils::LowMethods
  extend ::T::Sig
end

module FileUtils::NoWrite
  include ::FileUtils::LowMethods
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

module FileUtils::NoWrite
  extend ::T::Sig
  extend ::FileUtils::NoWrite
  extend ::FileUtils::LowMethods
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
end

module FileUtils::StreamUtils_
  extend ::T::Sig
end

module FileUtils::Verbose
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

module FileUtils::Verbose
  extend ::T::Sig
  extend ::FileUtils::Verbose
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
end

module FileUtils
  extend ::T::Sig
  extend ::FileUtils::StreamUtils_
  def self.cd(dir, options=T.unsafe(nil), &block); end

  def self.chdir(dir, options=T.unsafe(nil), &block); end

  def self.chmod(mode, list, options=T.unsafe(nil)); end

  def self.chmod_R(mode, list, options=T.unsafe(nil)); end

  def self.chown(user, group, list, options=T.unsafe(nil)); end

  def self.chown_R(user, group, list, options=T.unsafe(nil)); end

  def self.cmp(a, b); end

  def self.collect_method(opt); end

  def self.commands(); end

  def self.compare_file(a, b); end

  def self.compare_stream(a, b); end

  def self.copy(src, dest, options=T.unsafe(nil)); end

  def self.copy_entry(src, dest, preserve=T.unsafe(nil), dereference_root=T.unsafe(nil), remove_destination=T.unsafe(nil)); end

  def self.copy_file(src, dest, preserve=T.unsafe(nil), dereference=T.unsafe(nil)); end

  def self.copy_stream(src, dest); end

  def self.cp(src, dest, options=T.unsafe(nil)); end

  def self.getwd(); end

  def self.have_option?(mid, opt); end

  def self.identical?(a, b); end

  def self.install(src, dest, options=T.unsafe(nil)); end

  def self.link(src, dest, options=T.unsafe(nil)); end

  def self.ln(src, dest, options=T.unsafe(nil)); end

  def self.ln_s(src, dest, options=T.unsafe(nil)); end

  def self.ln_sf(src, dest, options=T.unsafe(nil)); end

  def self.makedirs(list, options=T.unsafe(nil)); end

  def self.mkdir(list, options=T.unsafe(nil)); end

  def self.mkpath(list, options=T.unsafe(nil)); end

  def self.move(src, dest, options=T.unsafe(nil)); end

  def self.mv(src, dest, options=T.unsafe(nil)); end

  def self.options(); end

  def self.options_of(mid); end

  def self.private_module_function(name); end

  def self.pwd(); end

  def self.remove(list, options=T.unsafe(nil)); end

  def self.remove_dir(path, force=T.unsafe(nil)); end

  def self.remove_entry(path, force=T.unsafe(nil)); end

  def self.remove_entry_secure(path, force=T.unsafe(nil)); end

  def self.remove_file(path, force=T.unsafe(nil)); end

  def self.rm(list, options=T.unsafe(nil)); end

  def self.rm_f(list, options=T.unsafe(nil)); end

  def self.rm_rf(list, options=T.unsafe(nil)); end

  def self.rmdir(list, options=T.unsafe(nil)); end

  def self.rmtree(list, options=T.unsafe(nil)); end

  def self.safe_unlink(list, options=T.unsafe(nil)); end

  def self.symlink(src, dest, options=T.unsafe(nil)); end

  def self.uptodate?(new, old_list); end
end

module Find
end

module Find
  extend ::T::Sig
  def self.find(*paths, ignore_error: T.unsafe(nil)); end

  def self.prune(); end
end

class Float
  include ::PSON::Pure::Generator::GeneratorMethods::Float
  include ::JSON::Ext::Generator::GeneratorMethods::Float
end

class Float
  extend ::T::Sig
end

class FloatDomainError
  extend ::T::Sig
end

module Forwardable
  def def_delegator(accessor, method, ali=T.unsafe(nil)); end

  def def_delegators(accessor, *methods); end

  def def_instance_delegator(accessor, method, ali=T.unsafe(nil)); end

  def def_instance_delegators(accessor, *methods); end

  def delegate(hash); end

  def instance_delegate(hash); end
end

module Forwardable
  extend ::T::Sig
  def self._delegator_method(obj, accessor, method, ali); end

  def self.debug(); end

  def self.debug=(debug); end
end

module GC
  def garbage_collect(*_); end
end

module GC::Profiler
  extend ::T::Sig
end

module GC
  extend ::T::Sig
  def self.latest_gc_info(*_); end

  def self.stress=(stress); end

  def self.verify_internal_consistency(); end
end

module Gem
  ConfigMap = ::T.let(nil, ::T.untyped)
  RbConfigPriorities = ::T.let(nil, ::T.untyped)
  RubyGemsPackageVersion = ::T.let(nil, ::T.untyped)
  RubyGemsVersion = ::T.let(nil, ::T.untyped)
end

class Gem::AvailableSet
  include ::Enumerable
  def <<(o); end

  def add(spec, source); end

  def all_specs(); end

  def each(); end

  def each_spec(); end

  def empty?(); end

  def find_all(req); end

  def inject_into_list(dep_list); end

  def match_platform!(); end

  def pick_best!(); end

  def prefetch(reqs); end

  def remote(); end

  def remote=(remote); end

  def remove_installed!(dep); end

  def set(); end

  def size(); end

  def sorted(); end

  def source_for(spec); end

  def to_request_set(development=T.unsafe(nil)); end
end

class Gem::AvailableSet::Tuple
  def source(); end

  def source=(_); end

  def spec(); end

  def spec=(_); end
end

class Gem::AvailableSet::Tuple
  def self.[](*_); end

  def self.members(); end
end

class Gem::AvailableSet
end

class Gem::BasicSpecification
  def activated?(); end

  def base_dir(); end

  def base_dir=(base_dir); end

  def contains_requirable_file?(file); end

  def datadir(); end

  def default_gem?(); end

  def extension_dir(); end

  def extension_dir=(extension_dir); end

  def extensions_dir(); end

  def full_gem_path(); end

  def full_gem_path=(full_gem_path); end

  def full_name(); end

  def full_require_paths(); end

  def gem_build_complete_path(); end

  def gem_dir(); end

  def gems_dir(); end

  def ignored=(ignored); end

  def internal_init(); end

  def lib_dirs_glob(); end

  def loaded_from(); end

  def loaded_from=(loaded_from); end

  def matches_for_glob(glob); end

  def name(); end

  def platform(); end

  def raw_require_paths(); end

  def require_paths(); end

  def source_paths(); end

  def stubbed?(); end

  def to_fullpath(path); end

  def to_spec(); end

  def version(); end
end

class Gem::BasicSpecification
  extend ::T::Sig
  def self.default_specifications_dir(); end
end

class Gem::Command
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  def add_extra_args(args); end

  def add_option(*opts, &handler); end

  def arguments(); end

  def begins?(long, short); end

  def command(); end

  def defaults(); end

  def defaults=(defaults); end

  def defaults_str(); end

  def description(); end

  def execute(); end

  def get_all_gem_names(); end

  def get_all_gem_names_and_versions(); end

  def get_one_gem_name(); end

  def get_one_optional_argument(); end

  def handle_options(args); end

  def handles?(args); end

  def initialize(command, summary=T.unsafe(nil), defaults=T.unsafe(nil)); end

  def invoke(*args); end

  def invoke_with_build_args(args, build_args); end

  def merge_options(new_options); end

  def options(); end

  def program_name(); end

  def program_name=(program_name); end

  def remove_option(name); end

  def show_help(); end

  def show_lookup_failure(gem_name, version, errors, domain); end

  def summary(); end

  def summary=(summary); end

  def usage(); end

  def when_invoked(&block); end
  HELP = ::T.let(nil, ::T.untyped)
end

class Gem::Command
  def self.add_common_option(*args, &handler); end

  def self.add_specific_extra_args(cmd, args); end

  def self.build_args(); end

  def self.build_args=(value); end

  def self.common_options(); end

  def self.extra_args(); end

  def self.extra_args=(value); end

  def self.specific_extra_args(cmd); end

  def self.specific_extra_args_hash(); end
end

class Gem::CommandLineError
  extend ::T::Sig
end

module Gem::Commands
end

module Gem::Commands
  extend ::T::Sig
end

class Gem::ConfigFile
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  def ==(other); end

  def [](key); end

  def []=(key, value); end

  def api_keys(); end

  def args(); end

  def backtrace(); end

  def backtrace=(backtrace); end

  def bulk_threshold(); end

  def bulk_threshold=(bulk_threshold); end

  def check_credentials_permissions(); end

  def config_file_name(); end

  def credentials_path(); end

  def disable_default_gem_server(); end

  def disable_default_gem_server=(disable_default_gem_server); end

  def each(&block); end

  def handle_arguments(arg_list); end

  def home(); end

  def home=(home); end

  def initialize(args); end

  def load_api_keys(); end

  def load_file(filename); end

  def path(); end

  def path=(path); end

  def really_verbose(); end

  def rubygems_api_key(); end

  def rubygems_api_key=(api_key); end

  def ssl_ca_cert(); end

  def ssl_ca_cert=(ssl_ca_cert); end

  def ssl_client_cert(); end

  def ssl_verify_mode(); end

  def to_yaml(); end

  def update_sources(); end

  def update_sources=(update_sources); end

  def verbose(); end

  def verbose=(verbose); end

  def write(); end
  DEFAULT_BACKTRACE = ::T.let(nil, ::T.untyped)
  DEFAULT_BULK_THRESHOLD = ::T.let(nil, ::T.untyped)
  DEFAULT_UPDATE_SOURCES = ::T.let(nil, ::T.untyped)
  DEFAULT_VERBOSITY = ::T.let(nil, ::T.untyped)
  OPERATING_SYSTEM_DEFAULTS = ::T.let(nil, ::T.untyped)
  PLATFORM_DEFAULTS = ::T.let(nil, ::T.untyped)
  SYSTEM_CONFIG_PATH = ::T.let(nil, ::T.untyped)
  SYSTEM_WIDE_CONFIG_FILE = ::T.let(nil, ::T.untyped)
end

class Gem::ConfigFile
end

class Gem::ConflictError
  def conflicts(); end

  def initialize(target, conflicts); end

  def target(); end
end

class Gem::ConflictError
  extend ::T::Sig
end

class Gem::ConsoleUI
  def initialize(); end
end

class Gem::ConsoleUI
end

module Gem::DefaultUserInteraction
  def ui(); end

  def ui=(new_ui); end

  def use_ui(new_ui, &block); end
end

module Gem::DefaultUserInteraction
  extend ::T::Sig
  def self.ui(); end

  def self.ui=(new_ui); end

  def self.use_ui(new_ui); end
end

class Gem::Dependency
  def ==(other); end

  def ===(other); end

  def =~(other); end

  def all_sources(); end

  def all_sources=(all_sources); end

  def encode_with(coder); end

  def eql?(other); end

  def groups(); end

  def groups=(groups); end

  def initialize(name, *requirements); end

  def latest_version?(); end

  def match?(obj, version=T.unsafe(nil), allow_prerelease=T.unsafe(nil)); end

  def matches_spec?(spec); end

  def matching_specs(platform_only=T.unsafe(nil)); end

  def merge(other); end

  def name(); end

  def name=(name); end

  def prerelease=(prerelease); end

  def prerelease?(); end

  def requirement(); end

  def requirements_list(); end

  def runtime?(); end

  def source(); end

  def source=(source); end

  def specific?(); end

  def to_lock(); end

  def to_spec(); end

  def to_specs(); end

  def type(); end
end

class Gem::Dependency
  extend ::T::Sig
end

class Gem::DependencyError
  extend ::T::Sig
end

class Gem::DependencyInstaller
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  def add_found_dependencies(to_do, dependency_list); end

  def available_set_for(dep_or_name, version); end

  def consider_local?(); end

  def consider_remote?(); end

  def document(); end

  def errors(); end

  def find_gems_with_sources(dep, best_only=T.unsafe(nil)); end

  def find_spec_by_name_and_version(gem_name, version=T.unsafe(nil), prerelease=T.unsafe(nil)); end

  def gather_dependencies(); end

  def gems_to_install(); end

  def in_background(what); end

  def initialize(options=T.unsafe(nil)); end

  def install(dep_or_name, version=T.unsafe(nil)); end

  def install_development_deps(); end

  def installed_gems(); end

  def resolve_dependencies(dep_or_name, version); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Gem::DependencyInstaller
end

class Gem::DependencyList
  include ::Enumerable
  include ::TSort
  def add(*gemspecs); end

  def clear(); end

  def dependency_order(); end

  def development(); end

  def development=(development); end

  def each(&block); end

  def find_name(full_name); end

  def initialize(development=T.unsafe(nil)); end

  def ok?(); end

  def ok_to_remove?(full_name, check_dev=T.unsafe(nil)); end

  def remove_by_name(full_name); end

  def remove_specs_unsatisfied_by(dependencies); end

  def spec_predecessors(); end

  def specs(); end

  def tsort_each_node(&block); end

  def why_not_ok?(quick=T.unsafe(nil)); end
end

class Gem::DependencyList
  def self.from_specs(); end
end

class Gem::DependencyRemovalException
  extend ::T::Sig
end

class Gem::DependencyResolutionError
  def conflict(); end

  def conflicting_dependencies(); end

  def initialize(conflict); end
end

class Gem::DependencyResolutionError
  extend ::T::Sig
end

class Gem::Resolver
end

Gem::DependencyResolver::Conflict = Gem::Resolver::Conflict

Gem::DependencyResolver::DependencyConflict = Gem::Resolver::Conflict

module Gem::Resolver::Molinillo
end

Gem::DependencyResolver::Molinillo::SpecificationProvider = Gem::Resolver::Molinillo::SpecificationProvider

Gem::DependencyResolver::Molinillo::UI = Gem::Resolver::Molinillo::UI

module Gem::Resolver::Molinillo
end

class Gem::Resolver
end

module Gem::Deprecate
  extend ::T::Sig
  def self.deprecate(name, repl, year, month); end

  def self.skip(); end

  def self.skip=(v); end

  def self.skip_during(); end
end

class Gem::DocumentError
  extend ::T::Sig
end

class Gem::EndOfYAMLException
  extend ::T::Sig
end

class Gem::ErrorReason
  extend ::T::Sig
end

class Gem::Exception
  def source_exception(); end

  def source_exception=(source_exception); end
end

class Gem::Exception
  extend ::T::Sig
end

module Gem::Ext
end

class Gem::Ext::BuildError
end

class Gem::Ext::BuildError
end

class Gem::Ext::Builder
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  def build_args(); end

  def build_args=(build_args); end

  def build_error(build_dir, output, backtrace=T.unsafe(nil)); end

  def build_extension(extension, dest_path); end

  def build_extensions(); end

  def builder_for(extension); end

  def initialize(spec, build_args=T.unsafe(nil)); end

  def write_gem_make_out(output); end
  CHDIR_MONITOR = ::T.let(nil, ::T.untyped)
  CHDIR_MUTEX = ::T.let(nil, ::T.untyped)
end

class Gem::Ext::Builder
  def self.class_name(); end

  def self.make(dest_path, results); end

  def self.redirector(); end

  def self.run(command, results, command_name=T.unsafe(nil)); end
end

class Gem::Ext::CmakeBuilder
end

class Gem::Ext::CmakeBuilder
  def self.build(extension, directory, dest_path, results, args=T.unsafe(nil), lib_dir=T.unsafe(nil)); end
end

class Gem::Ext::ConfigureBuilder
end

class Gem::Ext::ConfigureBuilder
  def self.build(extension, directory, dest_path, results, args=T.unsafe(nil), lib_dir=T.unsafe(nil)); end
end

class Gem::Ext::ExtConfBuilder
end

Gem::Ext::ExtConfBuilder::FileEntry = FileUtils::Entry_

class Gem::Ext::ExtConfBuilder
  def self.build(extension, directory, dest_path, results, args=T.unsafe(nil), lib_dir=T.unsafe(nil)); end

  def self.get_relative_path(path); end
end

class Gem::Ext::RakeBuilder
end

class Gem::Ext::RakeBuilder
  def self.build(extension, directory, dest_path, results, args=T.unsafe(nil), lib_dir=T.unsafe(nil)); end
end

module Gem::Ext
  extend ::T::Sig
end

class Gem::FilePermissionError
  def directory(); end

  def initialize(directory); end
end

class Gem::FilePermissionError
  extend ::T::Sig
end

class Gem::FormatException
  def file_path(); end

  def file_path=(file_path); end
end

class Gem::FormatException
  extend ::T::Sig
end

class Gem::GemNotFoundException
  extend ::T::Sig
end

class Gem::GemNotInHomeException
  def spec(); end

  def spec=(spec); end
end

class Gem::GemNotInHomeException
  extend ::T::Sig
end

class Gem::ImpossibleDependenciesError
  def build_message(); end

  def conflicts(); end

  def dependency(); end

  def initialize(request, conflicts); end

  def request(); end
end

class Gem::ImpossibleDependenciesError
  extend ::T::Sig
end

class Gem::InstallError
  extend ::T::Sig
end

class Gem::Installer
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  def app_script_text(bin_file_name); end

  def bin_dir(); end

  def build_extensions(); end

  def build_root(); end

  def check_executable_overwrite(filename); end

  def check_that_user_bin_dir_is_in_path(); end

  def default_spec_file(); end

  def dir(); end

  def ensure_dependencies_met(); end

  def ensure_dependency(spec, dependency); end

  def ensure_loadable_spec(); end

  def ensure_required_ruby_version_met(); end

  def ensure_required_rubygems_version_met(); end

  def extension_build_error(build_dir, output, backtrace=T.unsafe(nil)); end

  def extract_bin(); end

  def extract_files(); end

  def formatted_program_filename(filename); end

  def gem(); end

  def gem_dir(); end

  def gem_home(); end

  def generate_bin(); end

  def generate_bin_script(filename, bindir); end

  def generate_bin_symlink(filename, bindir); end

  def generate_windows_script(filename, bindir); end

  def initialize(package, options=T.unsafe(nil)); end

  def install(); end

  def installation_satisfies_dependency?(dependency); end

  def installed_specs(); end

  def options(); end

  def pre_install_checks(); end

  def process_options(); end

  def run_post_build_hooks(); end

  def run_post_install_hooks(); end

  def run_pre_install_hooks(); end

  def shebang(bin_file_name); end

  def spec(); end

  def spec_file(); end

  def unpack(directory); end

  def verify_gem_home(unpack=T.unsafe(nil)); end

  def verify_spec_name(); end

  def windows_stub_script(bindir, bin_file_name); end

  def write_build_info_file(); end

  def write_cache_file(); end

  def write_default_spec(); end

  def write_spec(); end
  ENV_PATHS = ::T.let(nil, ::T.untyped)
end

class Gem::Installer
  def self.at(path, options=T.unsafe(nil)); end

  def self.exec_format(); end

  def self.exec_format=(exec_format); end

  def self.for_spec(spec, options=T.unsafe(nil)); end

  def self.install_lock(); end

  def self.path_warning(); end

  def self.path_warning=(path_warning); end
end

class Gem::InvalidSpecificationException
  extend ::T::Sig
end

class Gem::Licenses
  IDENTIFIERS = ::T.let(nil, ::T.untyped)
  NONSTANDARD = ::T.let(nil, ::T.untyped)
  REGEXP = ::T.let(nil, ::T.untyped)
end

class Gem::Licenses
  extend ::Gem::Text
  def self.match?(license); end

  def self.suggestions(license); end
end

class Gem::List
  def each(); end

  def initialize(value=T.unsafe(nil), tail=T.unsafe(nil)); end

  def prepend(value); end

  def tail(); end

  def tail=(tail); end

  def to_a(); end

  def value(); end

  def value=(value); end
end

class Gem::List
  extend ::T::Sig
  def self.prepend(list, value); end
end

class Gem::LoadError
  def name(); end

  def name=(name); end

  def requirement(); end

  def requirement=(requirement); end
end

class Gem::LoadError
  extend ::T::Sig
end

class Gem::NameTuple
  include ::Comparable
  def ==(other); end

  def eql?(other); end

  def full_name(); end

  def initialize(name, version, platform=T.unsafe(nil)); end

  def match_platform?(); end

  def name(); end

  def platform(); end

  def prerelease?(); end

  def spec_name(); end

  def to_a(); end

  def version(); end
end

class Gem::NameTuple
  def self.from_list(list); end

  def self.null(); end

  def self.to_basic(list); end
end

class Gem::OperationNotSupportedError
  extend ::T::Sig
end

class Gem::Package
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  def add_checksums(tar); end

  def add_contents(tar); end

  def add_files(tar); end

  def add_metadata(tar); end

  def build(skip_validation=T.unsafe(nil)); end

  def build_time(); end

  def build_time=(build_time); end

  def checksums(); end

  def contents(); end

  def copy_to(path); end

  def digest(entry); end

  def extract_files(destination_dir, pattern=T.unsafe(nil)); end

  def extract_tar_gz(io, destination_dir, pattern=T.unsafe(nil)); end

  def files(); end

  def gzip_to(io); end

  def initialize(gem, security_policy); end

  def install_location(filename, destination_dir); end

  def load_spec(entry); end

  def mkdir_p_safe(mkdir, mkdir_options, destination_dir, file_name); end

  def open_tar_gz(io); end

  def read_checksums(gem); end

  def realpath(file); end

  def security_policy(); end

  def security_policy=(security_policy); end

  def setup_signer(); end

  def spec(); end

  def spec=(spec); end

  def verify(); end

  def verify_checksums(digests, checksums); end

  def verify_entry(entry); end

  def verify_files(gem); end

  def verify_gz(entry); end
end

class Gem::Package::DigestIO
  def digests(); end

  def initialize(io, digests); end

  def write(data); end
end

class Gem::Package::DigestIO
  def self.wrap(io, digests); end
end

class Gem::Package::Error
end

class Gem::Package::Error
end

class Gem::Package::FileSource
  def initialize(path); end

  def path(); end

  def present?(); end

  def start(); end

  def with_read_io(&block); end

  def with_write_io(&block); end
end

class Gem::Package::FileSource
end

class Gem::Package::FormatError
  def initialize(message, source=T.unsafe(nil)); end

  def path(); end
end

class Gem::Package::FormatError
end

class Gem::Package::IOSource
  def initialize(io); end

  def io(); end

  def path(); end

  def present?(); end

  def start(); end

  def with_read_io(); end

  def with_write_io(); end
end

class Gem::Package::IOSource
end

class Gem::Package::NonSeekableIO
end

class Gem::Package::NonSeekableIO
end

class Gem::Package::Old
  def extract_files(destination_dir); end

  def file_list(io); end

  def read_until_dashes(io); end

  def skip_ruby(io); end
end

class Gem::Package::Old
end

class Gem::Package::PathError
  def initialize(destination, destination_dir); end
end

class Gem::Package::PathError
end

class Gem::Package::Source
end

class Gem::Package::Source
end

class Gem::Package::TarHeader
  def ==(other); end

  def checksum(); end

  def devmajor(); end

  def devminor(); end

  def empty?(); end

  def gid(); end

  def gname(); end

  def initialize(vals); end

  def linkname(); end

  def magic(); end

  def mode(); end

  def mtime(); end

  def name(); end

  def prefix(); end

  def size(); end

  def typeflag(); end

  def uid(); end

  def uname(); end

  def update_checksum(); end

  def version(); end
  FIELDS = ::T.let(nil, ::T.untyped)
  PACK_FORMAT = ::T.let(nil, ::T.untyped)
  UNPACK_FORMAT = ::T.let(nil, ::T.untyped)
end

class Gem::Package::TarHeader
  def self.from(stream); end

  def self.strict_oct(str); end
end

class Gem::Package::TarInvalidError
end

class Gem::Package::TarInvalidError
end

class Gem::Package::TarReader
  include ::Enumerable
  def close(); end

  def each(); end

  def each_entry(); end

  def initialize(io); end

  def rewind(); end

  def seek(name); end
end

class Gem::Package::TarReader::Entry
  def bytes_read(); end

  def check_closed(); end

  def close(); end

  def closed?(); end

  def directory?(); end

  def eof?(); end

  def file?(); end

  def full_name(); end

  def getc(); end

  def header(); end

  def initialize(header, io); end

  def pos(); end

  def read(len=T.unsafe(nil)); end

  def readpartial(len=T.unsafe(nil)); end

  def rewind(); end

  def symlink?(); end
end

class Gem::Package::TarReader::Entry
end

class Gem::Package::TarReader::UnexpectedEOF
end

class Gem::Package::TarReader::UnexpectedEOF
end

class Gem::Package::TarReader
  def self.new(io); end
end

class Gem::Package::TarWriter
  def add_file(name, mode); end

  def add_file_digest(name, mode, digest_algorithms); end

  def add_file_signed(name, mode, signer); end

  def add_file_simple(name, mode, size); end

  def add_symlink(name, target, mode); end

  def check_closed(); end

  def close(); end

  def closed?(); end

  def flush(); end

  def initialize(io); end

  def mkdir(name, mode); end

  def split_name(name); end
end

class Gem::Package::TarWriter::BoundedStream
  def initialize(io, limit); end

  def limit(); end

  def write(data); end

  def written(); end
end

class Gem::Package::TarWriter::BoundedStream
end

class Gem::Package::TarWriter::FileOverflow
end

class Gem::Package::TarWriter::FileOverflow
end

class Gem::Package::TarWriter::RestrictedStream
  def initialize(io); end

  def write(data); end
end

class Gem::Package::TarWriter::RestrictedStream
end

class Gem::Package::TarWriter
  def self.new(io); end
end

class Gem::Package::TooLongFileName
end

class Gem::Package::TooLongFileName
end

class Gem::Package
  def self.build(spec, skip_validation=T.unsafe(nil)); end

  def self.new(gem, security_policy=T.unsafe(nil)); end
end

class Gem::PathSupport
  def home(); end

  def initialize(env=T.unsafe(nil)); end

  def path(); end

  def spec_cache_dir(); end
end

class Gem::PathSupport
  extend ::T::Sig
end

class Gem::Platform
  def ==(other); end

  def ===(other); end

  def =~(other); end

  def cpu(); end

  def cpu=(cpu); end

  def eql?(other); end

  def initialize(arch); end

  def os(); end

  def os=(os); end

  def to_a(); end

  def version(); end

  def version=(version); end
  JAVA = ::T.let(nil, ::T.untyped)
  MINGW = ::T.let(nil, ::T.untyped)
  MSWIN = ::T.let(nil, ::T.untyped)
  MSWIN64 = ::T.let(nil, ::T.untyped)
  X64_MINGW = ::T.let(nil, ::T.untyped)
end

class Gem::Platform
  extend ::T::Sig
  def self.installable?(spec); end

  def self.local(); end

  def self.match(platform); end

  def self.new(arch); end
end

class Gem::PlatformMismatch
  def add_platform(platform); end

  def initialize(name, version); end

  def name(); end

  def platforms(); end

  def version(); end

  def wordy(); end
end

class Gem::PlatformMismatch
  extend ::T::Sig
end

class Gem::RemoteError
  extend ::T::Sig
end

class Gem::RemoteFetcher
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  def api_endpoint(uri); end

  def cache_update_path(uri, path=T.unsafe(nil), update=T.unsafe(nil)); end

  def close_all(); end

  def correct_for_windows_path(path); end

  def download(spec, source_uri, install_dir=T.unsafe(nil)); end

  def download_to_cache(dependency); end

  def fetch_file(uri, *_); end

  def fetch_http(uri, last_modified=T.unsafe(nil), head=T.unsafe(nil), depth=T.unsafe(nil)); end

  def fetch_https(uri, last_modified=T.unsafe(nil), head=T.unsafe(nil), depth=T.unsafe(nil)); end

  def fetch_path(uri, mtime=T.unsafe(nil), head=T.unsafe(nil)); end

  def fetch_s3(uri, mtime=T.unsafe(nil), head=T.unsafe(nil)); end

  def fetch_size(uri); end

  def headers(); end

  def headers=(headers); end

  def https?(uri); end

  def initialize(proxy=T.unsafe(nil), dns=T.unsafe(nil), headers=T.unsafe(nil)); end

  def request(uri, request_class, last_modified=T.unsafe(nil)); end

  def s3_expiration(); end

  def sign_s3_url(uri, expiration=T.unsafe(nil)); end
  BASE64_URI_TRANSLATE = ::T.let(nil, ::T.untyped)
end

class Gem::RemoteFetcher
  def self.fetcher(); end
end

class Gem::RemoteInstallationCancelled
  extend ::T::Sig
end

class Gem::RemoteInstallationSkipped
  extend ::T::Sig
end

class Gem::RemoteSourceException
  extend ::T::Sig
end

class Gem::Request
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  def cert_files(); end

  def connection_for(uri); end

  def fetch(); end

  def initialize(uri, request_class, last_modified, pool); end

  def perform_request(request); end

  def proxy_uri(); end

  def reset(connection); end

  def user_agent(); end
end

class Gem::Request::ConnectionPools
  def close_all(); end

  def initialize(proxy_uri, cert_files); end

  def pool_for(uri); end
end

class Gem::Request::ConnectionPools
  def self.client(); end

  def self.client=(client); end
end

class Gem::Request::HTTPPool
  def cert_files(); end

  def checkin(connection); end

  def checkout(); end

  def close_all(); end

  def initialize(http_args, cert_files, proxy_uri); end

  def proxy_uri(); end
end

class Gem::Request::HTTPPool
end

class Gem::Request::HTTPSPool
end

class Gem::Request::HTTPSPool
end

class Gem::Request
  def self.configure_connection_for_https(connection, cert_files); end

  def self.create_with_proxy(uri, request_class, last_modified, proxy); end

  def self.get_cert_files(); end

  def self.get_proxy_from_env(scheme=T.unsafe(nil)); end

  def self.proxy_uri(proxy); end
end

class Gem::RequestSet
  include ::TSort
  def always_install(); end

  def always_install=(always_install); end

  def dependencies(); end

  def development(); end

  def development=(development); end

  def development_shallow(); end

  def development_shallow=(development_shallow); end

  def errors(); end

  def gem(name, *reqs); end

  def git_set(); end

  def ignore_dependencies(); end

  def ignore_dependencies=(ignore_dependencies); end

  def import(deps); end

  def initialize(*deps); end

  def install(options, &block); end

  def install_dir(); end

  def install_from_gemdeps(options, &block); end

  def install_into(dir, force=T.unsafe(nil), options=T.unsafe(nil)); end

  def load_gemdeps(path, without_groups=T.unsafe(nil), installing=T.unsafe(nil)); end

  def prerelease(); end

  def prerelease=(prerelease); end

  def remote(); end

  def remote=(remote); end

  def resolve(set=T.unsafe(nil)); end

  def resolve_current(); end

  def resolver(); end

  def sets(); end

  def soft_missing(); end

  def soft_missing=(soft_missing); end

  def sorted_requests(); end

  def source_set(); end

  def specs(); end

  def specs_in(dir); end

  def tsort_each_node(&block); end

  def vendor_set(); end
end

Gem::RequestSet::GemDepedencyAPI = Gem::RequestSet::GemDependencyAPI

class Gem::RequestSet::GemDependencyAPI
  def dependencies(); end

  def find_gemspec(name, path); end

  def gem(name, *requirements); end

  def gem_deps_file(); end

  def gem_git_reference(options); end

  def gemspec(options=T.unsafe(nil)); end

  def git(repository); end

  def git_set(); end

  def git_source(name, &callback); end

  def group(*groups); end

  def initialize(set, path); end

  def installing=(installing); end

  def load(); end

  def platform(*platforms); end

  def platforms(*platforms); end

  def requires(); end

  def ruby(version, options=T.unsafe(nil)); end

  def source(url); end

  def vendor_set(); end

  def without_groups(); end

  def without_groups=(without_groups); end
  ENGINE_MAP = ::T.let(nil, ::T.untyped)
  PLATFORM_MAP = ::T.let(nil, ::T.untyped)
  VERSION_MAP = ::T.let(nil, ::T.untyped)
  WINDOWS = ::T.let(nil, ::T.untyped)
end

class Gem::RequestSet::GemDependencyAPI
end

class Gem::RequestSet::Lockfile
  def add_DEPENDENCIES(out); end

  def add_GEM(out, spec_groups); end

  def add_GIT(out, git_requests); end

  def add_PATH(out, path_requests); end

  def add_PLATFORMS(out); end

  def initialize(request_set, gem_deps_file, dependencies); end

  def platforms(); end

  def relative_path_from(dest, base); end

  def spec_groups(); end

  def write(); end
end

class Gem::RequestSet::Lockfile::ParseError
  def column(); end

  def initialize(message, column, line, path); end

  def line(); end

  def path(); end
end

class Gem::RequestSet::Lockfile::ParseError
end

class Gem::RequestSet::Lockfile::Parser
  def get(expected_types=T.unsafe(nil), expected_value=T.unsafe(nil)); end

  def initialize(tokenizer, set, platforms, filename=T.unsafe(nil)); end

  def parse(); end

  def parse_DEPENDENCIES(); end

  def parse_GEM(); end

  def parse_GIT(); end

  def parse_PATH(); end

  def parse_PLATFORMS(); end

  def parse_dependency(name, op); end
end

class Gem::RequestSet::Lockfile::Parser
end

class Gem::RequestSet::Lockfile::Tokenizer
  def empty?(); end

  def initialize(input, filename=T.unsafe(nil), line=T.unsafe(nil), pos=T.unsafe(nil)); end

  def make_parser(set, platforms); end

  def next_token(); end

  def peek(); end

  def shift(); end

  def skip(type); end

  def to_a(); end

  def token_pos(byte_offset); end

  def unshift(token); end
  EOF = ::T.let(nil, ::T.untyped)
end

class Gem::RequestSet::Lockfile::Tokenizer::Token
  def column(); end

  def column=(_); end

  def line(); end

  def line=(_); end

  def type(); end

  def type=(_); end

  def value(); end

  def value=(_); end
end

class Gem::RequestSet::Lockfile::Tokenizer::Token
  def self.[](*_); end

  def self.members(); end
end

class Gem::RequestSet::Lockfile::Tokenizer
  def self.from_file(file); end
end

class Gem::RequestSet::Lockfile
  def self.build(request_set, gem_deps_file, dependencies=T.unsafe(nil)); end

  def self.requests_to_deps(requests); end
end

class Gem::RequestSet
end

class Gem::Requirement
  def ==(other); end

  def ===(version); end

  def =~(version); end

  def as_list(); end

  def concat(new); end

  def encode_with(coder); end

  def exact?(); end

  def for_lockfile(); end

  def init_with(coder); end

  def initialize(*requirements); end

  def marshal_dump(); end

  def marshal_load(array); end

  def none?(); end

  def prerelease?(); end

  def requirements(); end

  def satisfied_by?(version); end

  def specific?(); end

  def yaml_initialize(tag, vals); end
  DefaultRequirement = ::T.let(nil, ::T.untyped)
end

class Gem::Requirement::BadRequirementError
  extend ::T::Sig
end

class Gem::Requirement
  extend ::T::Sig
  def self.create(input); end

  def self.default(); end

  def self.parse(obj); end

  def self.source_set(); end
end

class Gem::Resolver
  include ::Gem::Resolver::Molinillo::UI
  include ::Gem::Resolver::Molinillo::SpecificationProvider
  def activation_request(dep, possible); end

  def development(); end

  def development=(development); end

  def development_shallow(); end

  def development_shallow=(development_shallow); end

  def explain(stage, *data); end

  def explain_list(stage); end

  def find_possible(dependency); end

  def ignore_dependencies(); end

  def ignore_dependencies=(ignore_dependencies); end

  def initialize(needed, set=T.unsafe(nil)); end

  def missing(); end

  def requests(s, act, reqs=T.unsafe(nil)); end

  def resolve(); end

  def select_local_platforms(specs); end

  def skip_gems(); end

  def skip_gems=(skip_gems); end

  def soft_missing(); end

  def soft_missing=(soft_missing); end

  def stats(); end
  DEBUG_RESOLVER = ::T.let(nil, ::T.untyped)
end

class Gem::Resolver::APISet
  def dep_uri(); end

  def initialize(dep_uri=T.unsafe(nil)); end

  def prefetch_now(); end

  def source(); end

  def uri(); end

  def versions(name); end
end

class Gem::Resolver::APISet
end

class Gem::Resolver::APISpecification
  def ==(other); end

  def initialize(set, api_data); end
end

class Gem::Resolver::APISpecification
end

class Gem::Resolver::ActivationRequest
  def ==(other); end

  def development?(); end

  def download(path); end

  def full_name(); end

  def full_spec(); end

  def initialize(spec, request, others_possible=T.unsafe(nil)); end

  def installed?(); end

  def name(); end

  def others_possible?(); end

  def parent(); end

  def request(); end

  def spec(); end

  def version(); end
end

class Gem::Resolver::ActivationRequest
end

class Gem::Resolver::BestSet
  def initialize(sources=T.unsafe(nil)); end

  def pick_sets(); end

  def replace_failed_api_set(error); end
end

class Gem::Resolver::BestSet
end

class Gem::Resolver::ComposedSet
  def initialize(*sets); end

  def prerelease=(allow_prerelease); end

  def remote=(remote); end

  def sets(); end
end

class Gem::Resolver::ComposedSet
end

class Gem::Resolver::Conflict
  def ==(other); end

  def activated(); end

  def conflicting_dependencies(); end

  def dependency(); end

  def explain(); end

  def explanation(); end

  def failed_dep(); end

  def for_spec?(spec); end

  def initialize(dependency, activated, failed_dep=T.unsafe(nil)); end

  def request_path(current); end

  def requester(); end
end

class Gem::Resolver::Conflict
end

class Gem::Resolver::CurrentSet
end

class Gem::Resolver::CurrentSet
end

class Gem::Resolver::DependencyRequest
  def ==(other); end

  def dependency(); end

  def development?(); end

  def explicit?(); end

  def implicit?(); end

  def initialize(dependency, requester); end

  def match?(spec, allow_prerelease=T.unsafe(nil)); end

  def matches_spec?(spec); end

  def name(); end

  def request_context(); end

  def requester(); end

  def requirement(); end

  def type(); end
end

class Gem::Resolver::DependencyRequest
end

class Gem::Resolver::GitSet
  def add_git_gem(name, repository, reference, submodules); end

  def add_git_spec(name, version, repository, reference, submodules); end

  def need_submodules(); end

  def repositories(); end

  def root_dir(); end

  def root_dir=(root_dir); end

  def specs(); end
end

class Gem::Resolver::GitSet
end

class Gem::Resolver::GitSpecification
  def ==(other); end

  def add_dependency(dependency); end
end

class Gem::Resolver::GitSpecification
end

class Gem::Resolver::IndexSet
  def initialize(source=T.unsafe(nil)); end
end

class Gem::Resolver::IndexSet
end

class Gem::Resolver::IndexSpecification
  def initialize(set, name, version, source, platform); end
end

class Gem::Resolver::IndexSpecification
end

class Gem::Resolver::InstalledSpecification
  def ==(other); end
end

class Gem::Resolver::InstalledSpecification
end

class Gem::Resolver::InstallerSet
  def add_always_install(dependency); end

  def add_local(dep_name, spec, source); end

  def always_install(); end

  def consider_local?(); end

  def consider_remote?(); end

  def ignore_dependencies(); end

  def ignore_dependencies=(ignore_dependencies); end

  def ignore_installed(); end

  def ignore_installed=(ignore_installed); end

  def initialize(domain); end

  def load_spec(name, ver, platform, source); end

  def local?(dep_name); end

  def prerelease=(allow_prerelease); end

  def remote=(remote); end

  def remote_set(); end
end

class Gem::Resolver::InstallerSet
end

class Gem::Resolver::LocalSpecification
end

class Gem::Resolver::LocalSpecification
end

class Gem::Resolver::LockSet
  def add(name, version, platform); end

  def initialize(sources); end

  def load_spec(name, version, platform, source); end

  def specs(); end
end

class Gem::Resolver::LockSet
end

class Gem::Resolver::LockSpecification
  def add_dependency(dependency); end

  def initialize(set, name, version, sources, platform); end

  def sources(); end
end

class Gem::Resolver::LockSpecification
end

module Gem::Resolver::Molinillo
  VERSION = ::T.let(nil, ::T.untyped)
end

class Gem::Resolver::Molinillo::CircularDependencyError
  def dependencies(); end

  def initialize(nodes); end
end

class Gem::Resolver::Molinillo::CircularDependencyError
end

class Gem::Resolver::Molinillo::DependencyGraph
  include ::Enumerable
  include ::TSort
  def ==(other); end

  def add_child_vertex(name, payload, parent_names, requirement); end

  def add_edge(origin, destination, requirement); end

  def add_vertex(name, payload, root=T.unsafe(nil)); end

  def detach_vertex_named(name); end

  def each(); end

  def root_vertex_named(name); end

  def tsort_each_child(vertex, &block); end

  def vertex_named(name); end

  def vertices(); end
end

class Gem::Resolver::Molinillo::DependencyGraph::Edge
  def destination(); end

  def destination=(_); end

  def origin(); end

  def origin=(_); end

  def requirement(); end

  def requirement=(_); end
end

class Gem::Resolver::Molinillo::DependencyGraph::Edge
  def self.[](*_); end

  def self.members(); end
end

class Gem::Resolver::Molinillo::DependencyGraph::Vertex
  def ==(other); end

  def ancestor?(other); end

  def descendent?(other); end

  def eql?(other); end

  def explicit_requirements(); end

  def incoming_edges(); end

  def incoming_edges=(incoming_edges); end

  def initialize(name, payload); end

  def is_reachable_from?(other); end

  def name(); end

  def name=(name); end

  def outgoing_edges(); end

  def outgoing_edges=(outgoing_edges); end

  def path_to?(other); end

  def payload(); end

  def payload=(payload); end

  def predecessors(); end

  def recursive_predecessors(); end

  def recursive_successors(); end

  def requirements(); end

  def root(); end

  def root=(root); end

  def root?(); end

  def shallow_eql?(other); end

  def successors(); end
end

class Gem::Resolver::Molinillo::DependencyGraph::Vertex
end

class Gem::Resolver::Molinillo::DependencyGraph
  def self.tsort(vertices); end
end

class Gem::Resolver::Molinillo::DependencyState
  def pop_possibility_state(); end
end

class Gem::Resolver::Molinillo::DependencyState
end

class Gem::Resolver::Molinillo::NoSuchDependencyError
  def dependency(); end

  def dependency=(dependency); end

  def initialize(dependency, required_by=T.unsafe(nil)); end

  def required_by(); end

  def required_by=(required_by); end
end

class Gem::Resolver::Molinillo::NoSuchDependencyError
end

class Gem::Resolver::Molinillo::PossibilityState
end

class Gem::Resolver::Molinillo::PossibilityState
end

class Gem::Resolver::Molinillo::ResolutionState
  def activated(); end

  def activated=(_); end

  def conflicts(); end

  def conflicts=(_); end

  def depth(); end

  def depth=(_); end

  def name(); end

  def name=(_); end

  def possibilities(); end

  def possibilities=(_); end

  def requirement(); end

  def requirement=(_); end

  def requirements(); end

  def requirements=(_); end
end

class Gem::Resolver::Molinillo::ResolutionState
  def self.[](*_); end

  def self.empty(); end

  def self.members(); end
end

class Gem::Resolver::Molinillo::Resolver
  def initialize(specification_provider, resolver_ui); end

  def resolve(requested, base=T.unsafe(nil)); end

  def resolver_ui(); end

  def specification_provider(); end
end

class Gem::Resolver::Molinillo::Resolver::Resolution
  def base(); end

  def initialize(specification_provider, resolver_ui, requested, base); end

  def iteration_rate=(iteration_rate); end

  def original_requested(); end

  def resolve(); end

  def resolver_ui(); end

  def specification_provider(); end

  def started_at=(started_at); end

  def states=(states); end
end

class Gem::Resolver::Molinillo::Resolver::Resolution::Conflict
  def activated_by_name(); end

  def activated_by_name=(_); end

  def existing(); end

  def existing=(_); end

  def locked_requirement(); end

  def locked_requirement=(_); end

  def possibility(); end

  def possibility=(_); end

  def requirement(); end

  def requirement=(_); end

  def requirement_trees(); end

  def requirement_trees=(_); end

  def requirements(); end

  def requirements=(_); end
end

class Gem::Resolver::Molinillo::Resolver::Resolution::Conflict
  def self.[](*_); end

  def self.members(); end
end

class Gem::Resolver::Molinillo::Resolver::Resolution
end

class Gem::Resolver::Molinillo::Resolver
end

class Gem::Resolver::Molinillo::ResolverError
end

class Gem::Resolver::Molinillo::ResolverError
end

module Gem::Resolver::Molinillo::SpecificationProvider
  def allow_missing?(dependency); end

  def dependencies_for(specification); end

  def name_for(dependency); end

  def name_for_explicit_dependency_source(); end

  def name_for_locking_dependency_source(); end

  def requirement_satisfied_by?(requirement, activated, spec); end

  def search_for(dependency); end

  def sort_dependencies(dependencies, activated, conflicts); end
end

module Gem::Resolver::Molinillo::SpecificationProvider
  extend ::T::Sig
end

module Gem::Resolver::Molinillo::UI
  def after_resolution(); end

  def before_resolution(); end

  def debug(depth=T.unsafe(nil)); end

  def debug?(); end

  def indicate_progress(); end

  def output(); end

  def progress_rate(); end
end

module Gem::Resolver::Molinillo::UI
  extend ::T::Sig
end

class Gem::Resolver::Molinillo::VersionConflict
  def conflicts(); end

  def initialize(conflicts); end
end

class Gem::Resolver::Molinillo::VersionConflict
end

module Gem::Resolver::Molinillo
  extend ::T::Sig
end

class Gem::Resolver::RequirementList
  include ::Enumerable
  def add(req); end

  def each(); end

  def empty?(); end

  def next5(); end

  def remove(); end

  def size(); end
end

class Gem::Resolver::RequirementList
end

class Gem::Resolver::Set
  def errors(); end

  def errors=(errors); end

  def find_all(req); end

  def prefetch(reqs); end

  def prerelease(); end

  def prerelease=(prerelease); end

  def remote(); end

  def remote=(remote); end

  def remote?(); end
end

class Gem::Resolver::Set
end

class Gem::Resolver::SourceSet
  def add_source_gem(name, source); end
end

class Gem::Resolver::SourceSet
end

class Gem::Resolver::SpecSpecification
  def initialize(set, spec, source=T.unsafe(nil)); end
end

class Gem::Resolver::SpecSpecification
end

class Gem::Resolver::Specification
  def dependencies(); end

  def fetch_development_dependencies(); end

  def full_name(); end

  def install(options=T.unsafe(nil)); end

  def installable_platform?(); end

  def local?(); end

  def name(); end

  def platform(); end

  def set(); end

  def source(); end

  def spec(); end

  def version(); end
end

class Gem::Resolver::Specification
end

class Gem::Resolver::Stats
  def backtracking!(); end

  def display(); end

  def iteration!(); end

  def record_depth(stack); end

  def record_requirements(reqs); end

  def requirement!(); end
  PATTERN = ::T.let(nil, ::T.untyped)
end

class Gem::Resolver::Stats
end

class Gem::Resolver::VendorSet
  def add_vendor_gem(name, directory); end

  def load_spec(name, version, platform, source); end

  def specs(); end
end

class Gem::Resolver::VendorSet
end

class Gem::Resolver::VendorSpecification
  def ==(other); end
end

class Gem::Resolver::VendorSpecification
end

class Gem::Resolver
  def self.compose_sets(*sets); end

  def self.for_current_gems(needed); end
end

class Gem::RubyVersionMismatch
  extend ::T::Sig
end

module Gem::Security
  AlmostNoSecurity = ::T.let(nil, ::T.untyped)
  DIGEST_NAME = ::T.let(nil, ::T.untyped)
  EXTENSIONS = ::T.let(nil, ::T.untyped)
  HighSecurity = ::T.let(nil, ::T.untyped)
  KEY_CIPHER = ::T.let(nil, ::T.untyped)
  KEY_LENGTH = ::T.let(nil, ::T.untyped)
  LowSecurity = ::T.let(nil, ::T.untyped)
  MediumSecurity = ::T.let(nil, ::T.untyped)
  NoSecurity = ::T.let(nil, ::T.untyped)
  ONE_YEAR = ::T.let(nil, ::T.untyped)
  Policies = ::T.let(nil, ::T.untyped)
  SigningPolicy = ::T.let(nil, ::T.untyped)
end

class Gem::Security::DIGEST_ALGORITHM
  def initialize(data=T.unsafe(nil)); end
end

class Gem::Security::DIGEST_ALGORITHM
  def self.digest(data); end

  def self.hexdigest(data); end
end

class Gem::Security::Exception
end

class Gem::Security::Exception
end

Gem::Security::KEY_ALGORITHM = OpenSSL::PKey::RSA

class Gem::Security::Policy
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  def check_cert(signer, issuer, time); end

  def check_chain(chain, time); end

  def check_data(public_key, digest, signature, data); end

  def check_key(signer, key); end

  def check_root(chain, time); end

  def check_trust(chain, digester, trust_dir); end

  def initialize(name, policy=T.unsafe(nil), opt=T.unsafe(nil)); end

  def name(); end

  def only_signed(); end

  def only_signed=(only_signed); end

  def only_trusted(); end

  def only_trusted=(only_trusted); end

  def subject(certificate); end

  def verify(chain, key=T.unsafe(nil), digests=T.unsafe(nil), signatures=T.unsafe(nil), full_name=T.unsafe(nil)); end

  def verify_chain(); end

  def verify_chain=(verify_chain); end

  def verify_data(); end

  def verify_data=(verify_data); end

  def verify_root(); end

  def verify_root=(verify_root); end

  def verify_signatures(spec, digests, signatures); end

  def verify_signer(); end

  def verify_signer=(verify_signer); end
end

class Gem::Security::Policy
end

class Gem::Security::Signer
  def cert_chain(); end

  def cert_chain=(cert_chain); end

  def digest_algorithm(); end

  def digest_name(); end

  def extract_name(cert); end

  def initialize(key, cert_chain, passphrase=T.unsafe(nil)); end

  def key(); end

  def key=(key); end

  def load_cert_chain(); end

  def re_sign_key(); end

  def sign(data); end
end

class Gem::Security::Signer
end

class Gem::Security::TrustDir
  def cert_path(certificate); end

  def dir(); end

  def each_certificate(); end

  def initialize(dir, permissions=T.unsafe(nil)); end

  def issuer_of(certificate); end

  def load_certificate(certificate_file); end

  def name_path(name); end

  def trust_cert(certificate); end

  def verify(); end
  DEFAULT_PERMISSIONS = ::T.let(nil, ::T.untyped)
end

class Gem::Security::TrustDir
end

module Gem::Security
  extend ::T::Sig
  def self.alt_name_or_x509_entry(certificate, x509_entry); end

  def self.create_cert(subject, key, age=T.unsafe(nil), extensions=T.unsafe(nil), serial=T.unsafe(nil)); end

  def self.create_cert_email(email, key, age=T.unsafe(nil), extensions=T.unsafe(nil)); end

  def self.create_cert_self_signed(subject, key, age=T.unsafe(nil), extensions=T.unsafe(nil), serial=T.unsafe(nil)); end

  def self.create_key(length=T.unsafe(nil), algorithm=T.unsafe(nil)); end

  def self.email_to_name(email_address); end

  def self.re_sign(expired_certificate, private_key, age=T.unsafe(nil), extensions=T.unsafe(nil)); end

  def self.reset(); end

  def self.sign(certificate, signing_key, signing_cert, age=T.unsafe(nil), extensions=T.unsafe(nil), serial=T.unsafe(nil)); end

  def self.trust_dir(); end

  def self.trusted_certificates(&block); end

  def self.write(pemmable, path, permissions=T.unsafe(nil), passphrase=T.unsafe(nil), cipher=T.unsafe(nil)); end
end

class Gem::SilentUI
  def initialize(); end
end

class Gem::SilentUI
end

class Gem::Source
  include ::Comparable
  def ==(other); end

  def api_uri(); end

  def cache_dir(uri); end

  def dependency_resolver_set(); end

  def download(spec, dir=T.unsafe(nil)); end

  def eql?(other); end

  def fetch_spec(name_tuple); end

  def initialize(uri); end

  def load_specs(type); end

  def update_cache?(); end

  def uri(); end
  FILES = ::T.let(nil, ::T.untyped)
end

class Gem::Source::Git
  def base_dir(); end

  def cache(); end

  def checkout(); end

  def dir_shortref(); end

  def download(full_spec, path); end

  def initialize(name, repository, reference, submodules=T.unsafe(nil)); end

  def install_dir(); end

  def name(); end

  def need_submodules(); end

  def reference(); end

  def remote(); end

  def remote=(remote); end

  def repo_cache_dir(); end

  def repository(); end

  def rev_parse(); end

  def root_dir(); end

  def root_dir=(root_dir); end

  def specs(); end

  def uri_hash(); end
end

class Gem::Source::Git
end

class Gem::Source::Installed
  def download(spec, path); end

  def initialize(); end
end

class Gem::Source::Installed
end

class Gem::Source::Local
  def download(spec, cache_dir=T.unsafe(nil)); end

  def fetch_spec(name); end

  def find_gem(gem_name, version=T.unsafe(nil), prerelease=T.unsafe(nil)); end

  def initialize(); end
end

class Gem::Source::Local
end

class Gem::Source::Lock
  def initialize(source); end

  def wrapped(); end
end

class Gem::Source::Lock
end

class Gem::Source::SpecificFile
  def fetch_spec(name); end

  def initialize(file); end

  def load_specs(*a); end

  def path(); end

  def spec(); end
end

class Gem::Source::SpecificFile
end

class Gem::Source::Vendor
  def initialize(path); end
end

class Gem::Source::Vendor
end

class Gem::Source
end

class Gem::SourceFetchProblem
  def error(); end

  def exception(); end

  def initialize(source, error); end

  def source(); end

  def wordy(); end
end

class Gem::SourceFetchProblem
  extend ::T::Sig
end

class Gem::SourceList
  include ::Enumerable
  def <<(obj); end

  def ==(other); end

  def clear(); end

  def delete(source); end

  def each(); end

  def each_source(&b); end

  def empty?(); end

  def first(); end

  def include?(other); end

  def replace(other); end

  def sources(); end

  def to_a(); end

  def to_ary(); end
end

class Gem::SourceList
  def self.from(ary); end
end

class Gem::SpecFetcher
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def available_specs(type); end

  def detect(type=T.unsafe(nil)); end

  def initialize(sources=T.unsafe(nil)); end

  def latest_specs(); end

  def prerelease_specs(); end

  def search_for_dependency(dependency, matching_platform=T.unsafe(nil)); end

  def sources(); end

  def spec_for_dependency(dependency, matching_platform=T.unsafe(nil)); end

  def specs(); end

  def suggest_gems_from_name(gem_name); end

  def tuples_for(source, type, gracefully_ignore=T.unsafe(nil)); end
end

class Gem::SpecFetcher
  def self.fetcher(); end

  def self.fetcher=(fetcher); end
end

class Gem::SpecificGemNotFoundException
  def errors(); end

  def initialize(name, version, errors=T.unsafe(nil)); end

  def name(); end

  def version(); end
end

class Gem::SpecificGemNotFoundException
  extend ::T::Sig
end

class Gem::Specification
  include ::Bundler::MatchPlatform
  include ::Bundler::GemHelpers
  def ==(other); end

  def abbreviate(); end

  def activate(); end

  def activate_dependencies(); end

  def activated(); end

  def activated=(activated); end

  def add_bindir(executables); end

  def add_dependency(gem, *requirements); end

  def add_development_dependency(gem, *requirements); end

  def add_runtime_dependency(gem, *requirements); end

  def add_self_to_load_path(); end

  def author(); end

  def author=(o); end

  def authors(); end

  def authors=(value); end

  def autorequire(); end

  def autorequire=(autorequire); end

  def bin_dir(); end

  def bin_file(name); end

  def bindir(); end

  def bindir=(bindir); end

  def build_args(); end

  def build_extensions(); end

  def build_info_dir(); end

  def build_info_file(); end

  def bundled_gem_in_old_ruby?(); end

  def cache_dir(); end

  def cache_file(); end

  def cert_chain(); end

  def cert_chain=(cert_chain); end

  def conficts_when_loaded_with?(list_of_specs); end

  def conflicts(); end

  def date(); end

  def date=(date); end

  def default_executable(); end

  def default_executable=(default_executable); end

  def default_value(name); end

  def dependencies(); end

  def dependent_gems(); end

  def dependent_specs(); end

  def description(); end

  def description=(str); end

  def development_dependencies(); end

  def doc_dir(type=T.unsafe(nil)); end

  def email(); end

  def email=(email); end

  def encode_with(coder); end

  def eql?(other); end

  def executable(); end

  def executable=(o); end

  def executables(); end

  def executables=(value); end

  def extensions(); end

  def extensions=(extensions); end

  def extra_rdoc_files(); end

  def extra_rdoc_files=(files); end

  def file_name(); end

  def files(); end

  def files=(files); end

  def for_cache(); end

  def git_version(); end

  def groups(); end

  def has_conflicts?(); end

  def has_rdoc(); end

  def has_rdoc=(ignored); end

  def has_test_suite?(); end

  def has_unit_tests?(); end

  def homepage(); end

  def homepage=(homepage); end

  def init_with(coder); end

  def initialize(name=T.unsafe(nil), version=T.unsafe(nil)); end

  def installed_by_version(); end

  def installed_by_version=(version); end

  def lib_files(); end

  def license(); end

  def license=(o); end

  def licenses(); end

  def licenses=(licenses); end

  def load_paths(); end

  def location(); end

  def location=(location); end

  def mark_version(); end

  def metadata(); end

  def metadata=(metadata); end

  def method_missing(sym, *a, &b); end

  def missing_extensions?(); end

  def name=(name); end

  def name_tuple(); end

  def nondevelopment_dependencies(); end

  def normalize(); end

  def original_name(); end

  def original_platform(); end

  def original_platform=(original_platform); end

  def platform=(platform); end

  def post_install_message(); end

  def post_install_message=(post_install_message); end

  def raise_if_conflicts(); end

  def rdoc_options(); end

  def rdoc_options=(options); end

  def relative_loaded_from(); end

  def relative_loaded_from=(relative_loaded_from); end

  def remote(); end

  def remote=(remote); end

  def require_path(); end

  def require_path=(path); end

  def require_paths=(val); end

  def required_ruby_version(); end

  def required_ruby_version=(req); end

  def required_rubygems_version(); end

  def required_rubygems_version=(req); end

  def requirements(); end

  def requirements=(req); end

  def reset_nil_attributes_to_default(); end

  def rg_extension_dir(); end

  def rg_full_gem_path(); end

  def rg_loaded_from(); end

  def ri_dir(); end

  def rubyforge_project(); end

  def rubyforge_project=(rubyforge_project); end

  def rubygems_version(); end

  def rubygems_version=(rubygems_version); end

  def runtime_dependencies(); end

  def sanitize(); end

  def sanitize_string(string); end

  def satisfies_requirement?(dependency); end

  def signing_key(); end

  def signing_key=(signing_key); end

  def sort_obj(); end

  def source(); end

  def source=(source); end

  def spec_dir(); end

  def spec_file(); end

  def spec_name(); end

  def specification_version(); end

  def specification_version=(specification_version); end

  def summary(); end

  def summary=(str); end

  def test_file(); end

  def test_file=(file); end

  def test_files(); end

  def test_files=(files); end

  def to_gemfile(path=T.unsafe(nil)); end

  def to_ruby(); end

  def to_ruby_for_cache(); end

  def to_yaml(opts=T.unsafe(nil)); end

  def traverse(trail=T.unsafe(nil), visited=T.unsafe(nil), &block); end

  def validate(packaging=T.unsafe(nil)); end

  def validate_dependencies(); end

  def validate_permissions(); end

  def version=(version); end

  def warning(statement); end

  def yaml_initialize(tag, vals); end
  DateLike = ::T.let(nil, ::T.untyped)
  DateTimeFormat = ::T.let(nil, ::T.untyped)
  Dupable = ::T.let(nil, ::T.untyped)
end

class Gem::Specification
  extend ::T::Sig
  extend ::Gem::Deprecate
  extend ::Enumerable
  def self._all(); end

  def self._clear_load_cache(); end

  def self._latest_specs(specs, prerelease=T.unsafe(nil)); end

  def self._load(str); end

  def self._resort!(specs); end

  def self.add_spec(spec); end

  def self.add_specs(*specs); end

  def self.all(); end

  def self.all=(specs); end

  def self.all_names(); end

  def self.array_attributes(); end

  def self.attribute_names(); end

  def self.dirs(); end

  def self.dirs=(dirs); end

  def self.each(); end

  def self.each_gemspec(dirs); end

  def self.each_spec(dirs); end

  def self.find_active_stub_by_path(path); end

  def self.find_all_by_name(name, *requirements); end

  def self.find_by_name(name, *requirements); end

  def self.find_by_path(path); end

  def self.find_in_unresolved(path); end

  def self.find_in_unresolved_tree(path); end

  def self.find_inactive_by_path(path); end

  def self.from_yaml(input); end

  def self.latest_specs(prerelease=T.unsafe(nil)); end

  def self.load(file); end

  def self.load_defaults(); end

  def self.non_nil_attributes(); end

  def self.normalize_yaml_input(input); end

  def self.outdated(); end

  def self.outdated_and_latest_version(); end

  def self.remove_spec(spec); end

  def self.required_attribute?(name); end

  def self.required_attributes(); end

  def self.reset(); end

  def self.stubs(); end

  def self.stubs_for(name); end

  def self.unresolved_deps(); end
end

class Gem::StreamUI
  def _gets_noecho(); end

  def alert(statement, question=T.unsafe(nil)); end

  def alert_error(statement, question=T.unsafe(nil)); end

  def alert_warning(statement, question=T.unsafe(nil)); end

  def ask(question); end

  def ask_for_password(question); end

  def ask_yes_no(question, default=T.unsafe(nil)); end

  def backtrace(exception); end

  def choose_from_list(question, list); end

  def close(); end

  def debug(statement); end

  def download_reporter(*args); end

  def errs(); end

  def initialize(in_stream, out_stream, err_stream=T.unsafe(nil), usetty=T.unsafe(nil)); end

  def ins(); end

  def outs(); end

  def progress_reporter(*args); end

  def say(statement=T.unsafe(nil)); end

  def terminate_interaction(status=T.unsafe(nil)); end

  def tty?(); end
end

class Gem::StreamUI
end

class Gem::StubSpecification
  def build_extensions(); end

  def extensions(); end

  def initialize(filename, base_dir, gems_dir, default_gem); end

  def missing_extensions?(); end

  def this(); end

  def valid?(); end
end

class Gem::StubSpecification::StubLine
  def extensions(); end

  def full_name(); end

  def initialize(data, extensions); end

  def name(); end

  def platform(); end

  def require_paths(); end

  def version(); end
end

class Gem::StubSpecification::StubLine
  extend ::T::Sig
end

class Gem::StubSpecification
  extend ::T::Sig
  def self.default_gemspec_stub(filename, base_dir, gems_dir); end

  def self.gemspec_stub(filename, base_dir, gems_dir); end
end

class Gem::SystemExitException
  def exit_code(); end

  def exit_code=(exit_code); end

  def initialize(exit_code); end
end

class Gem::SystemExitException
  extend ::T::Sig
end

module Gem::Text
  def clean_text(text); end

  def format_text(text, wrap, indent=T.unsafe(nil)); end

  def levenshtein_distance(str1, str2); end

  def min3(a, b, c); end

  def truncate_text(text, description, max_length=T.unsafe(nil)); end
end

module Gem::Text
  extend ::T::Sig
end

Gem::UnsatisfiableDepedencyError = Gem::UnsatisfiableDependencyError

class Gem::UnsatisfiableDependencyError
  def dependency(); end

  def errors(); end

  def errors=(errors); end

  def initialize(dep, platform_mismatch=T.unsafe(nil)); end

  def name(); end

  def version(); end
end

class Gem::UnsatisfiableDependencyError
  extend ::T::Sig
end

class Gem::UriFormatter
  def escape(); end

  def initialize(uri); end

  def normalize(); end

  def unescape(); end

  def uri(); end
end

class Gem::UriFormatter
end

module Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  def alert(statement, question=T.unsafe(nil)); end

  def alert_error(statement, question=T.unsafe(nil)); end

  def alert_warning(statement, question=T.unsafe(nil)); end

  def ask(question); end

  def ask_for_password(prompt); end

  def ask_yes_no(question, default=T.unsafe(nil)); end

  def choose_from_list(question, list); end

  def say(statement=T.unsafe(nil)); end

  def terminate_interaction(exit_code=T.unsafe(nil)); end

  def verbose(msg=T.unsafe(nil)); end
end

module Gem::UserInteraction
  extend ::T::Sig
end

module Gem::Util
  NULL_DEVICE = ::T.let(nil, ::T.untyped)
end

module Gem::Util
  extend ::T::Sig
  def self.gunzip(data); end

  def self.gzip(data); end

  def self.inflate(data); end

  def self.popen(*command); end

  def self.silent_system(*command); end

  def self.traverse_parents(directory); end
end

class Gem::VerificationError
  extend ::T::Sig
end

class Gem::Version
  def _version(); end

  def approximate_recommendation(); end

  def bump(); end

  def encode_with(coder); end

  def eql?(other); end

  def init_with(coder); end

  def marshal_dump(); end

  def marshal_load(array); end

  def prerelease?(); end

  def release(); end

  def segments(); end

  def version(); end

  def yaml_initialize(tag, map); end
end

Gem::Version::Requirement = Gem::Requirement

class Gem::Version
  extend ::T::Sig
  def self.correct?(version); end

  def self.create(input); end

  def self.new(version); end
end

module Gem
  extend ::T::Sig
  def self.activate_bin_path(name, *args); end

  def self.default_ext_dir_for(base_dir); end

  def self.default_gems_use_full_paths?(); end

  def self.default_spec_cache_dir(); end

  def self.deflate(data); end

  def self.detect_gemdeps(path=T.unsafe(nil)); end

  def self.dir(); end

  def self.done_installing(&hook); end

  def self.done_installing_hooks(); end

  def self.ensure_default_gem_subdirectories(dir=T.unsafe(nil), mode=T.unsafe(nil)); end

  def self.ensure_gem_subdirectories(dir=T.unsafe(nil), mode=T.unsafe(nil)); end

  def self.ensure_subdirectories(dir, mode, subdirs); end

  def self.extension_api_version(); end

  def self.find_files(glob, check_load_path=T.unsafe(nil)); end

  def self.find_files_from_load_path(glob); end

  def self.find_latest_files(glob, check_load_path=T.unsafe(nil)); end

  def self.find_spec_for_exe(gem_name, *args); end

  def self.find_unresolved_default_spec(path); end

  def self.finish_resolve(*_); end

  def self.gemdeps(); end

  def self.gunzip(data); end

  def self.gzip(data); end

  def self.host(); end

  def self.host=(host); end

  def self.inflate(data); end

  def self.install(name, version=T.unsafe(nil), *options); end

  def self.install_extension_in_lib(); end

  def self.latest_rubygems_version(); end

  def self.latest_spec_for(name); end

  def self.latest_version_for(name); end

  def self.load_env_plugins(); end

  def self.load_path_insert_index(); end

  def self.load_plugin_files(plugins); end

  def self.load_plugins(); end

  def self.load_yaml(); end

  def self.loaded_specs(); end

  def self.location_of_caller(); end

  def self.marshal_version(); end

  def self.needs(); end

  def self.path(); end

  def self.path_separator(); end

  def self.paths(); end

  def self.paths=(env); end

  def self.platforms(); end

  def self.platforms=(platforms); end

  def self.post_build(&hook); end

  def self.post_build_hooks(); end

  def self.post_install(&hook); end

  def self.post_install_hooks(); end

  def self.post_reset(&hook); end

  def self.post_reset_hooks(); end

  def self.post_uninstall(&hook); end

  def self.post_uninstall_hooks(); end

  def self.pre_install(&hook); end

  def self.pre_install_hooks(); end

  def self.pre_reset(&hook); end

  def self.pre_reset_hooks(); end

  def self.pre_uninstall(&hook); end

  def self.pre_uninstall_hooks(); end

  def self.prefix(); end

  def self.read_binary(path); end

  def self.refresh(); end

  def self.register_default_spec(spec); end

  def self.remove_unresolved_default_spec(spec); end

  def self.ruby(); end

  def self.ruby_api_version(); end

  def self.ruby_engine(); end

  def self.ruby_version(); end

  def self.rubygems_version(); end

  def self.sources(); end

  def self.sources=(new_sources); end

  def self.spec_cache_dir(); end

  def self.suffix_pattern(); end

  def self.suffixes(); end

  def self.time(msg, width=T.unsafe(nil), display=T.unsafe(nil)); end

  def self.try_activate(path); end

  def self.ui(); end

  def self.use_gemdeps(path=T.unsafe(nil)); end

  def self.use_paths(home, *paths); end

  def self.user_dir(); end

  def self.user_home(); end

  def self.vendor_dir(); end

  def self.win_platform?(); end
end

class GetoptLong
  def each(); end

  def each_option(); end

  def error(); end

  def error?(); end

  def error_message(); end

  def get(); end

  def get_option(); end

  def initialize(*arguments); end

  def ordering(); end

  def ordering=(ordering); end

  def quiet(); end

  def quiet=(quiet); end

  def quiet?(); end

  def set_error(type, message); end

  def set_options(*arguments); end

  def terminate(); end

  def terminated?(); end
  ARGUMENT_FLAGS = ::T.let(nil, ::T.untyped)
  NO_ARGUMENT = ::T.let(nil, ::T.untyped)
  OPTIONAL_ARGUMENT = ::T.let(nil, ::T.untyped)
  ORDERINGS = ::T.let(nil, ::T.untyped)
  PERMUTE = ::T.let(nil, ::T.untyped)
  REQUIRED_ARGUMENT = ::T.let(nil, ::T.untyped)
  REQUIRE_ORDER = ::T.let(nil, ::T.untyped)
  RETURN_IN_ORDER = ::T.let(nil, ::T.untyped)
  STATUS_STARTED = ::T.let(nil, ::T.untyped)
  STATUS_TERMINATED = ::T.let(nil, ::T.untyped)
  STATUS_YET = ::T.let(nil, ::T.untyped)
end

class GetoptLong::AmbiguousOption
end

class GetoptLong::AmbiguousOption
end

class GetoptLong::Error
end

class GetoptLong::Error
end

class GetoptLong::InvalidOption
end

class GetoptLong::InvalidOption
end

class GetoptLong::MissingArgument
end

class GetoptLong::MissingArgument
end

class GetoptLong::NeedlessArgument
end

class GetoptLong::NeedlessArgument
end

class GetoptLong
end

class Hash
  include ::PSON::Pure::Generator::GeneratorMethods::Hash
  include ::JSON::Ext::Generator::GeneratorMethods::Hash
  def <(_); end

  def <=(_); end

  def >(_); end

  def >=(_); end

  def default_proc(); end

  def default_proc=(default_proc); end

  def dig(*_); end

  def fetch_values(*_); end

  def flatten(*_); end

  def index(_); end

  def merge!(_); end

  def replace(_); end

  def to_h(); end

  def to_proc(); end

  def update(_); end
end

class Hash
  extend ::T::Sig
  def self.try_convert(_); end
end

module Hiera::Backend::Eyaml::Parser
  extend ::T::Sig
end

module Hiera::Backend::Eyaml
  extend ::T::Sig
end

module Hiera::Backend
  extend ::T::Sig
end

module Hiera::Console_logger
  extend ::T::Sig
end

module Hiera::Noop_logger
  extend ::T::Sig
end

module Hiera::Puppet_logger
  extend ::T::Sig
end

class Hiera::Scope
  def call_function(*args, &block); end
end

module Hiera::Util::Win32
  extend ::T::Sig
end

module Hiera::Util
  extend ::T::Sig
end

module HieraPuppet
  extend ::T::Sig
end

module Hocon
  extend ::T::Sig
end

class IO
  def beep(); end

  def cooked(); end

  def cooked!(); end

  def cursor(); end

  def cursor=(); end

  def echo=(echo); end

  def echo?(); end

  def external_encoding(); end

  def getch(*_); end

  def getpass(*_); end

  def goto(); end

  def iflush(); end

  def ioflush(); end

  def noecho(); end

  def nonblock(*_); end

  def nonblock=(nonblock); end

  def nonblock?(); end

  def nread(); end

  def oflush(); end

  def pathconf(_); end

  def pressed?(); end

  def raw(*_); end

  def raw!(*_); end

  def ready?(); end

  def scanf(str, &b); end

  def wait(*_); end

  def wait_readable(*_); end

  def wait_writable(*_); end

  def winsize(); end

  def winsize=(winsize); end

  def write_nonblock(buf, exception: T.unsafe(nil)); end
end

class IO::EAGAINWaitReadable
  extend ::T::Sig
end

class IO::EAGAINWaitWritable
  extend ::T::Sig
end

class IO::EINPROGRESSWaitReadable
  extend ::T::Sig
end

class IO::EINPROGRESSWaitWritable
  extend ::T::Sig
end

IO::EWOULDBLOCKWaitReadable = IO::EAGAINWaitReadable

IO::EWOULDBLOCKWaitWritable = IO::EAGAINWaitWritable

module IO::WaitReadable
  extend ::T::Sig
end

module IO::WaitWritable
  extend ::T::Sig
end

class IO
  extend ::T::Sig
  def self.console(*_); end

  def self.console_size(); end

  def self.default_console_size(); end

  def self.foreach(*_); end

  def self.open(*_); end

  def self.pipe(*_); end

end

class IOError
  extend ::T::Sig
end

class IPAddr
  include ::Comparable
  def &(other); end

  def <<(num); end

  def ==(other); end

  def ===(other); end

  def >>(num); end

  def eql?(other); end

  def family(); end

  def hton(); end

  def include?(other); end

  def initialize(addr=T.unsafe(nil), family=T.unsafe(nil)); end

  def ip6_arpa(); end

  def ip6_int(); end

  def ipv4?(); end

  def ipv4_compat(); end

  def ipv4_compat?(); end

  def ipv4_mapped(); end

  def ipv4_mapped?(); end

  def ipv6?(); end

  def mask(prefixlen); end

  def mask!(mask); end

  def native(); end

  def reverse(); end

  def set(addr, *family); end

  def succ(); end

  def to_i(); end

  def to_range(); end

  def to_string(); end

  def |(other); end

  def ~(); end
  IN4MASK = ::T.let(nil, ::T.untyped)
  IN6FORMAT = ::T.let(nil, ::T.untyped)
  IN6MASK = ::T.let(nil, ::T.untyped)
  RE_IPV4ADDRLIKE = ::T.let(nil, ::T.untyped)
  RE_IPV6ADDRLIKE_COMPRESSED = ::T.let(nil, ::T.untyped)
  RE_IPV6ADDRLIKE_FULL = ::T.let(nil, ::T.untyped)
end

class IPAddr::AddressFamilyError
end

class IPAddr::AddressFamilyError
end

class IPAddr::Error
end

class IPAddr::Error
end

class IPAddr::InvalidAddressError
end

class IPAddr::InvalidAddressError
end

class IPAddr::InvalidPrefixError
end

class IPAddr::InvalidPrefixError
end

class IPAddr
  def self.new_ntoh(addr); end

  def self.ntop(addr); end
end

class IPSocket
  extend ::T::Sig
end

module IRB
  IRBRC_EXT = ::T.let(nil, ::T.untyped)
  MagicFile = ::T.let(nil, ::T.untyped)
  STDIN_FILE_NAME = ::T.let(nil, ::T.untyped)
end

class IRB::Abort
end

class IRB::Abort
end

class IRB::Context
  def __exit__(*_); end

  def __inspect__(); end

  def __to_s__(); end

  def ap_name(); end

  def ap_name=(ap_name); end

  def auto_indent_mode(); end

  def auto_indent_mode=(auto_indent_mode); end

  def back_trace_limit(); end

  def back_trace_limit=(back_trace_limit); end

  def debug?(); end

  def debug_level(); end

  def debug_level=(value); end

  def echo(); end

  def echo=(echo); end

  def echo?(); end

  def eval_history=(*opts, &b); end

  def evaluate(line, line_no); end

  def exit(ret=T.unsafe(nil)); end

  def file_input?(); end

  def ignore_eof(); end

  def ignore_eof=(ignore_eof); end

  def ignore_eof?(); end

  def ignore_sigint(); end

  def ignore_sigint=(ignore_sigint); end

  def ignore_sigint?(); end

  def initialize(irb, workspace=T.unsafe(nil), input_method=T.unsafe(nil), output_method=T.unsafe(nil)); end

  def inspect?(); end

  def inspect_last_value(); end

  def inspect_mode(); end

  def inspect_mode=(opt); end

  def io(); end

  def io=(io); end

  def irb(); end

  def irb=(irb); end

  def irb_name(); end

  def irb_name=(irb_name); end

  def irb_path(); end

  def irb_path=(irb_path); end

  def last_value(); end

  def load_modules(); end

  def load_modules=(load_modules); end

  def main(); end

  def math_mode=(*opts, &b); end

  def prompt_c(); end

  def prompt_c=(prompt_c); end

  def prompt_i(); end

  def prompt_i=(prompt_i); end

  def prompt_mode(); end

  def prompt_mode=(mode); end

  def prompt_n(); end

  def prompt_n=(prompt_n); end

  def prompt_s(); end

  def prompt_s=(prompt_s); end

  def prompting?(); end

  def rc(); end

  def rc=(rc); end

  def rc?(); end

  def return_format(); end

  def return_format=(return_format); end

  def save_history=(*opts, &b); end

  def set_last_value(value); end

  def thread(); end

  def use_loader=(*opts, &b); end

  def use_readline(); end

  def use_readline=(opt); end

  def use_readline?(); end

  def use_tracer=(*opts, &b); end

  def verbose(); end

  def verbose=(verbose); end

  def verbose?(); end

  def workspace(); end

  def workspace=(workspace); end

  def workspace_home(); end
  IDNAME_IVARS = ::T.let(nil, ::T.untyped)
  NOPRINTING_IVARS = ::T.let(nil, ::T.untyped)
  NO_INSPECTING_IVARS = ::T.let(nil, ::T.untyped)
end

class IRB::Context
end

module IRB::ContextExtender
end

IRB::ContextExtender::CE = IRB::ContextExtender

module IRB::ContextExtender
  extend ::T::Sig
  def self.def_extend_command(cmd_name, load_file, *aliases); end

  def self.install_extend_commands(); end
end

class IRB::DefaultEncodings
  def external(); end

  def external=(_); end

  def internal(); end

  def internal=(_); end
end

class IRB::DefaultEncodings
  def self.[](*_); end

  def self.members(); end
end

module IRB::ExtendCommandBundle
  def install_alias_method(to, from, override=T.unsafe(nil)); end

  def irb(*opts, &b); end

  def irb_change_workspace(*opts, &b); end

  def irb_context(); end

  def irb_current_working_workspace(*opts, &b); end

  def irb_exit(ret=T.unsafe(nil)); end

  def irb_fg(*opts, &b); end

  def irb_help(*opts, &b); end

  def irb_jobs(*opts, &b); end

  def irb_kill(*opts, &b); end

  def irb_load(*opts, &b); end

  def irb_pop_workspace(*opts, &b); end

  def irb_push_workspace(*opts, &b); end

  def irb_require(*opts, &b); end

  def irb_source(*opts, &b); end

  def irb_workspaces(*opts, &b); end
  NO_OVERRIDE = ::T.let(nil, ::T.untyped)
  OVERRIDE_ALL = ::T.let(nil, ::T.untyped)
  OVERRIDE_PRIVATE_ONLY = ::T.let(nil, ::T.untyped)
end

IRB::ExtendCommandBundle::EXCB = IRB::ExtendCommandBundle

module IRB::ExtendCommandBundle
  extend ::T::Sig
  def self.def_extend_command(cmd_name, cmd_class, load_file=T.unsafe(nil), *aliases); end

  def self.extend_object(obj); end

  def self.install_extend_commands(); end

  def self.irb_original_method_name(method_name); end
end

class IRB::FileInputMethod
  def encoding(); end

  def eof?(); end

  def initialize(file); end
end

class IRB::FileInputMethod
end

class IRB::InputMethod
  def file_name(); end

  def gets(); end

  def initialize(file=T.unsafe(nil)); end

  def prompt(); end

  def prompt=(prompt); end

  def readable_after_eof?(); end
end

class IRB::InputMethod
end

class IRB::Inspector
  def initialize(inspect_proc, init_proc=T.unsafe(nil)); end

  def inspect_value(v); end
  INSPECTORS = ::T.let(nil, ::T.untyped)
end

class IRB::Inspector
  def self.def_inspector(key, arg=T.unsafe(nil), &block); end

  def self.keys_with_inspector(inspector); end
end

class IRB::Irb
  def context(); end

  def eval_input(); end

  def initialize(workspace=T.unsafe(nil), input_method=T.unsafe(nil), output_method=T.unsafe(nil)); end

  def output_value(); end

  def prompt(prompt, ltype, indent, line_no); end

  def scanner(); end

  def scanner=(scanner); end

  def signal_handle(); end

  def signal_status(status); end

  def suspend_context(context); end

  def suspend_input_method(input_method); end

  def suspend_name(path=T.unsafe(nil), name=T.unsafe(nil)); end

  def suspend_workspace(workspace); end
end

class IRB::Irb
end

class IRB::Locale
  def String(mes); end

  def encoding(); end

  def find(file, paths=T.unsafe(nil)); end

  def format(*opts); end

  def gets(*rs); end

  def initialize(locale=T.unsafe(nil)); end

  def lang(); end

  def load(file, priv=T.unsafe(nil)); end

  def modifier(); end

  def print(*opts); end

  def printf(*opts); end

  def puts(*opts); end

  def readline(*rs); end

  def require(file, priv=T.unsafe(nil)); end

  def territory(); end
  LOCALE_DIR = ::T.let(nil, ::T.untyped)
  LOCALE_NAME_RE = ::T.let(nil, ::T.untyped)
end

class IRB::Locale
end

module IRB::MethodExtender
  def def_post_proc(base_method, extend_method); end

  def def_pre_proc(base_method, extend_method); end

  def new_alias_name(name, prefix=T.unsafe(nil), postfix=T.unsafe(nil)); end
end

module IRB::MethodExtender
  extend ::T::Sig
end

module IRB::Notifier
  def Fail(err=T.unsafe(nil), *rest); end

  def Raise(err=T.unsafe(nil), *rest); end
  D_NOMSG = ::T.let(nil, ::T.untyped)
end

class IRB::Notifier::AbstractNotifier
  def exec_if(); end

  def initialize(prefix, base_notifier); end

  def notify?(); end

  def ppx(prefix, *objs); end

  def prefix(); end

  def print(*opts); end

  def printf(format, *opts); end

  def printn(*opts); end

  def puts(*objs); end
end

class IRB::Notifier::AbstractNotifier
end

class IRB::Notifier::CompositeNotifier
  def def_notifier(level, prefix=T.unsafe(nil)); end

  def level(); end

  def level=(value); end

  def level_notifier(); end

  def level_notifier=(value); end

  def notifiers(); end
end

class IRB::Notifier::CompositeNotifier
end

class IRB::Notifier::ErrUndefinedNotifier
end

class IRB::Notifier::ErrUndefinedNotifier
end

class IRB::Notifier::ErrUnrecognizedLevel
end

class IRB::Notifier::ErrUnrecognizedLevel
end

class IRB::Notifier::LeveledNotifier
  include ::Comparable
  def initialize(base, level, prefix); end

  def level(); end
end

class IRB::Notifier::LeveledNotifier
end

class IRB::Notifier::NoMsgNotifier
  def initialize(); end
end

class IRB::Notifier::NoMsgNotifier
end

module IRB::Notifier
  extend ::Exception2MessageMapper
  extend ::T::Sig
  def self.def_notifier(prefix=T.unsafe(nil), output_method=T.unsafe(nil)); end

  def self.included(mod); end
end

class IRB::OutputMethod
  def Fail(err=T.unsafe(nil), *rest); end

  def Raise(err=T.unsafe(nil), *rest); end

  def parse_printf_format(format, opts); end

  def ppx(prefix, *objs); end

  def print(*opts); end

  def printf(format, *opts); end

  def printn(*opts); end

  def puts(*objs); end
end

class IRB::OutputMethod::NotImplementedError
end

class IRB::OutputMethod::NotImplementedError
end

class IRB::OutputMethod
  extend ::Exception2MessageMapper
  def self.included(mod); end
end

class IRB::ReadlineInputMethod
  include ::Readline
  def encoding(); end

  def eof?(); end

  def initialize(); end

  def line(line_no); end
end

class IRB::ReadlineInputMethod
end

class IRB::SLex
  def Fail(err=T.unsafe(nil), *rest); end

  def Raise(err=T.unsafe(nil), *rest); end

  def create(token, preproc=T.unsafe(nil), postproc=T.unsafe(nil)); end

  def def_rule(token, preproc=T.unsafe(nil), postproc=T.unsafe(nil), &block); end

  def def_rules(*tokens, &block); end

  def match(token); end

  def postproc(token); end

  def preproc(token, proc); end

  def search(token); end
  DOUT = ::T.let(nil, ::T.untyped)
  D_DEBUG = ::T.let(nil, ::T.untyped)
  D_DETAIL = ::T.let(nil, ::T.untyped)
  D_WARN = ::T.let(nil, ::T.untyped)
end

class IRB::SLex::ErrNodeAlreadyExists
end

class IRB::SLex::ErrNodeAlreadyExists
end

class IRB::SLex::ErrNodeNothing
end

class IRB::SLex::ErrNodeNothing
end

class IRB::SLex::Node
  def create_subnode(chrs, preproc=T.unsafe(nil), postproc=T.unsafe(nil)); end

  def initialize(preproc=T.unsafe(nil), postproc=T.unsafe(nil)); end

  def match(chrs, op=T.unsafe(nil)); end

  def match_io(io, op=T.unsafe(nil)); end

  def postproc(); end

  def postproc=(postproc); end

  def preproc(); end

  def preproc=(preproc); end

  def search(chrs, opt=T.unsafe(nil)); end
end

class IRB::SLex::Node
end

class IRB::SLex
  extend ::Exception2MessageMapper
  def self.included(mod); end
end

class IRB::StdioInputMethod
  def encoding(); end

  def eof?(); end

  def initialize(); end

  def line(line_no); end
end

class IRB::StdioInputMethod
end

class IRB::StdioOutputMethod
end

class IRB::StdioOutputMethod
end

class IRB::WorkSpace
  def evaluate(context, statements, file=T.unsafe(nil), line=T.unsafe(nil)); end

  def filter_backtrace(bt); end

  def initialize(*main); end

  def main(); end
end

class IRB::WorkSpace
end

module IRB
  extend ::T::Sig
  def self.CurrentContext(); end

  def self.Inspector(inspect, init=T.unsafe(nil)); end

  def self.conf(); end

  def self.delete_caller(); end

  def self.init_config(ap_path); end

  def self.init_error(); end

  def self.irb_abort(irb, exception=T.unsafe(nil)); end

  def self.irb_at_exit(); end

  def self.irb_exit(irb, ret); end

  def self.load_modules(); end

  def self.parse_opts(); end

  def self.rc_file(ext=T.unsafe(nil)); end

  def self.rc_file_generators(); end

  def self.run_config(); end

  def self.setup(ap_path); end

  def self.start(ap_path=T.unsafe(nil)); end

  def self.version(); end
end

class IndexError
  extend ::T::Sig
end

class Integer
  include ::PSON::Pure::Generator::GeneratorMethods::Integer
  def prime?(); end

  def prime_division(generator=T.unsafe(nil)); end

  def to_bn(); end
end

class Integer
  extend ::T::Sig
  def self.each_prime(ubound, &block); end

  def self.from_prime_division(pd); end
end

class Interrupt
  extend ::T::Sig
end

class JSON::CircularDatastructure
  extend ::T::Sig
end

module JSON::Ext::Generator
end

module JSON::Ext::Generator::GeneratorMethods
end

module JSON::Ext::Generator::GeneratorMethods::Array
  def to_json(*_); end
end

module JSON::Ext::Generator::GeneratorMethods::Array
  extend ::T::Sig
end

module JSON::Ext::Generator::GeneratorMethods::Bignum
  def to_json(*_); end
end

module JSON::Ext::Generator::GeneratorMethods::Bignum
  extend ::T::Sig
end

module JSON::Ext::Generator::GeneratorMethods::FalseClass
  def to_json(*_); end
end

module JSON::Ext::Generator::GeneratorMethods::FalseClass
  extend ::T::Sig
end

module JSON::Ext::Generator::GeneratorMethods::Fixnum
  def to_json(*_); end
end

module JSON::Ext::Generator::GeneratorMethods::Fixnum
  extend ::T::Sig
end

module JSON::Ext::Generator::GeneratorMethods::Float
  def to_json(*_); end
end

module JSON::Ext::Generator::GeneratorMethods::Float
  extend ::T::Sig
end

module JSON::Ext::Generator::GeneratorMethods::Hash
  def to_json(*_); end
end

module JSON::Ext::Generator::GeneratorMethods::Hash
  extend ::T::Sig
end

module JSON::Ext::Generator::GeneratorMethods::NilClass
  def to_json(*_); end
end

module JSON::Ext::Generator::GeneratorMethods::NilClass
  extend ::T::Sig
end

module JSON::Ext::Generator::GeneratorMethods::Object
  def to_json(*_); end
end

module JSON::Ext::Generator::GeneratorMethods::Object
  extend ::T::Sig
end

module JSON::Ext::Generator::GeneratorMethods::String
  def to_json(*_); end

  def to_json_raw(*_); end

  def to_json_raw_object(); end
end

module JSON::Ext::Generator::GeneratorMethods::String
  extend ::T::Sig
end

module JSON::Ext::Generator::GeneratorMethods::TrueClass
  def to_json(*_); end
end

module JSON::Ext::Generator::GeneratorMethods::TrueClass
  extend ::T::Sig
end

module JSON::Ext::Generator::GeneratorMethods
  extend ::T::Sig
end

class JSON::Ext::Generator::State
  def [](_); end

  def []=(_, _1); end

  def allow_nan?(); end

  def array_nl(); end

  def array_nl=(array_nl); end

  def ascii_only?(); end

  def buffer_initial_length(); end

  def buffer_initial_length=(buffer_initial_length); end

  def check_circular?(); end

  def configure(_); end

  def depth(); end

  def depth=(depth); end

  def generate(_); end

  def indent(); end

  def indent=(indent); end

  def initialize(*_); end

  def max_nesting(); end

  def max_nesting=(max_nesting); end

  def merge(_); end

  def object_nl(); end

  def object_nl=(object_nl); end

  def quirks_mode(); end

  def quirks_mode=(quirks_mode); end

  def quirks_mode?(); end

  def space(); end

  def space=(space); end

  def space_before(); end

  def space_before=(space_before); end

  def to_h(); end

  def to_hash(); end
end

class JSON::Ext::Generator::State
  def self.from_state(_); end
end

module JSON::Ext::Generator
  extend ::T::Sig
end

class JSON::Ext::Parser
  def initialize(*_); end

  def parse(); end

  def quirks_mode?(); end

  def source(); end
end

class JSON::Ext::Parser
end

module JSON::Ext
  extend ::T::Sig
end

class JSON::GeneratorError
  extend ::T::Sig
end

class JSON::GenericObject
  extend ::T::Sig
end

class JSON::JSONError
  extend ::T::Sig
end

class JSON::MissingUnicodeSupport
  extend ::T::Sig
end

class JSON::NestingError
  extend ::T::Sig
end

JSON::Parser = JSON::Ext::Parser

class JSON::ParserError
  extend ::T::Sig
end

JSON::State = JSON::Ext::Generator::State

module JSON::Util::URI
  extend ::T::Sig
end

class JSON::Util::UUID
  def self.[](*_); end

  def self.members(); end
end

module JSON::Util
  extend ::T::Sig
end

module JSON
  extend ::T::Sig
end

module JSONMatchers
  extend ::T::Sig
end

module Kconv
  ASCII = ::T.let(nil, ::T.untyped)
  AUTO = ::T.let(nil, ::T.untyped)
  BINARY = ::T.let(nil, ::T.untyped)
  EUC = ::T.let(nil, ::T.untyped)
  JIS = ::T.let(nil, ::T.untyped)
  NOCONV = ::T.let(nil, ::T.untyped)
  SJIS = ::T.let(nil, ::T.untyped)
  UNKNOWN = ::T.let(nil, ::T.untyped)
  UTF16 = ::T.let(nil, ::T.untyped)
  UTF32 = ::T.let(nil, ::T.untyped)
  UTF8 = ::T.let(nil, ::T.untyped)
end

module Kconv
  extend ::T::Sig
  def self.guess(str); end

  def self.iseuc(str); end

  def self.isjis(str); end

  def self.issjis(str); end

  def self.isutf8(str); end

  def self.kconv(str, to_enc, from_enc=T.unsafe(nil)); end

  def self.toeuc(str); end

  def self.tojis(str); end

  def self.tolocale(str); end

  def self.tosjis(str); end

  def self.toutf16(str); end

  def self.toutf32(str); end

  def self.toutf8(str); end
end

module Kernel
  def class(); end

  def gem(dep, *reqs); end

  def itself(); end

  def object_id(); end

  def pretty_inspect(); end

  def respond_to?(*_); end

end

module Kernel
  extend ::T::Sig
  def self.at_exit(); end
end

class KeyError
  extend ::T::Sig
end

class LoadError
  def path(); end
end

class LoadError
  extend ::T::Sig
end

class LocalJumpError
  def exit_value(); end

  def reason(); end
end

class LocalJumpError
  extend ::T::Sig
end

module Locale::Driver::Env::Private
  extend ::T::Sig
end

module Locale::Driver::Env
  extend ::T::Sig
end

module Locale::Driver::Posix
  extend ::T::Sig
end

module Locale::Driver
  extend ::T::Sig
end

class Locale::Tag::Simple
  def to_cldr(); end

  def to_common(); end

  def to_posix(); end

  def to_rfc(); end

  def to_simple(); end
end

module Locale::Tag
  extend ::T::Sig
end

module Locale
  extend ::T::Sig
end

module Marshal
  extend ::T::Sig
  def self.restore(*_); end
end

class MatchData
  extend ::T::Sig
end

module Matchers::Include
  def include_in_any_order(*expected, &block_arg); end
end

module Matchers::Include
  extend ::T::Sig
end

module Matchers::Resource
  def be_resource(*expected, &block_arg); end

  def have_resource(*expected, &block_arg); end
end

module Matchers::Resource
  extend ::T::Sig
end

module Matchers
  extend ::T::Sig
end

class Math::DomainError
  extend ::T::Sig
end

module Math
  extend ::T::Sig
end

class Method
  def [](*_); end

  def arity(); end

  def curry(*_); end

  def name(); end

  def original_name(); end

  def owner(); end

  def parameters(); end

  def receiver(); end

  def source_location(); end

  def super_method(); end

  def unbind(); end
end

class Method
  extend ::T::Sig
end

Methods = T::Private::Methods

class Module
  def context(*a, &b); end

  def deprecate_constant(*_); end

  def describe(*a, &b); end

  def example_group(*a, &b); end

  def fcontext(*a, &b); end

  def fdescribe(*a, &b); end

  def psych_yaml_as(url); end

  def shared_context(name, *args, &block); end

  def shared_examples(name, *args, &block); end

  def shared_examples_for(name, *args, &block); end

  def xcontext(*a, &b); end

  def xdescribe(*a, &b); end

  def yaml_as(url); end
end

class Module
  extend ::T::Sig
end

class Monitor
  def enter(); end

  def exit(); end

  def try_enter(); end
end

class Monitor
  extend ::T::Sig
end

module MonitorMixin
  def initialize(*args); end

  def mon_enter(); end

  def mon_exit(); end

  def mon_synchronize(); end

  def mon_try_enter(); end

  def new_cond(); end

  def synchronize(); end

  def try_mon_enter(); end
end

class MonitorMixin::ConditionVariable
  def broadcast(); end

  def initialize(monitor); end

  def signal(); end

  def wait(timeout=T.unsafe(nil)); end

  def wait_until(); end

  def wait_while(); end
end

class MonitorMixin::ConditionVariable::Timeout
  extend ::T::Sig
end

class MonitorMixin::ConditionVariable
  extend ::T::Sig
end

module MonitorMixin
  extend ::T::Sig
  def self.extend_object(obj); end
end

module MultiJson
  def cached_options(*_); end

  def reset_cached_options!(*_); end
end

class MultiJson::Adapter
  def self.instance(); end
end

module MultiJson::Adapters
  extend ::T::Sig
end

module MultiJson::Options
  extend ::T::Sig
end

module MultiJson::OptionsCache
  extend ::T::Sig
end

module MultiJson
  extend ::T::Sig
end

Mutex = Thread::Mutex

module NKF
  ASCII = ::T.let(nil, ::T.untyped)
  AUTO = ::T.let(nil, ::T.untyped)
  BINARY = ::T.let(nil, ::T.untyped)
  EUC = ::T.let(nil, ::T.untyped)
  JIS = ::T.let(nil, ::T.untyped)
  NKF_RELEASE_DATE = ::T.let(nil, ::T.untyped)
  NKF_VERSION = ::T.let(nil, ::T.untyped)
  NOCONV = ::T.let(nil, ::T.untyped)
  SJIS = ::T.let(nil, ::T.untyped)
  UNKNOWN = ::T.let(nil, ::T.untyped)
  UTF16 = ::T.let(nil, ::T.untyped)
  UTF32 = ::T.let(nil, ::T.untyped)
  UTF8 = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module NKF
  extend ::T::Sig
  def self.guess(_); end

  def self.nkf(_, _1); end
end

class NameError
  include ::DidYouMean::Correctable
  def name(); end

  def receiver(); end
end

class NameError
  extend ::T::Sig
end

class Net::BufferedIO
  extend ::T::Sig
end

class Net::HTTP::Copy
  extend ::T::Sig
end

class Net::HTTP::Delete
  extend ::T::Sig
end

class Net::HTTP::Get
  extend ::T::Sig
end

class Net::HTTP::Head
  extend ::T::Sig
end

class Net::HTTP::Lock
  extend ::T::Sig
end

class Net::HTTP::Mkcol
  extend ::T::Sig
end

class Net::HTTP::Move
  extend ::T::Sig
end

class Net::HTTP::Options
  extend ::T::Sig
end

class Net::HTTP::Patch
  extend ::T::Sig
end

class Net::HTTP::Post
  extend ::T::Sig
end

class Net::HTTP::Propfind
  extend ::T::Sig
end

class Net::HTTP::Proppatch
  extend ::T::Sig
end

module Net::HTTP::ProxyDelta
  extend ::T::Sig
end

Net::HTTP::ProxyMod = Net::HTTP::ProxyDelta

class Net::HTTP::Put
  extend ::T::Sig
end

class Net::HTTP::Trace
  extend ::T::Sig
end

class Net::HTTP::Unlock
  extend ::T::Sig
end

class Net::HTTP
  extend ::T::Sig
end

class Net::HTTPAccepted
  extend ::T::Sig
end

class Net::HTTPBadGateway
  extend ::T::Sig
end

class Net::HTTPBadRequest
  extend ::T::Sig
end

class Net::HTTPBadResponse
  extend ::T::Sig
end

Net::HTTPClientError::EXCEPTION_TYPE = Net::HTTPServerException

class Net::HTTPClientError
  extend ::T::Sig
end

Net::HTTPClientErrorCode = Net::HTTPClientError

class Net::HTTPConflict
  extend ::T::Sig
end

class Net::HTTPContinue
  extend ::T::Sig
end

class Net::HTTPCreated
  extend ::T::Sig
end

class Net::HTTPError
  extend ::T::Sig
end

module Net::HTTPExceptions
  extend ::T::Sig
end

class Net::HTTPExpectationFailed
  extend ::T::Sig
end

class Net::HTTPFailedDependency
  extend ::T::Sig
end

class Net::HTTPFatalError
  extend ::T::Sig
end

Net::HTTPFatalErrorCode = Net::HTTPClientError

class Net::HTTPForbidden
  extend ::T::Sig
end

class Net::HTTPFound
  extend ::T::Sig
end

class Net::HTTPGatewayTimeOut
  extend ::T::Sig
end

class Net::HTTPGenericRequest::Chunker
  extend ::T::Sig
end

class Net::HTTPGenericRequest
  extend ::T::Sig
end

class Net::HTTPGone
  extend ::T::Sig
end

module Net::HTTPHeader
  extend ::T::Sig
end

class Net::HTTPHeaderSyntaxError
  extend ::T::Sig
end

class Net::HTTPIMUsed
  extend ::T::Sig
end

Net::HTTPInformation::EXCEPTION_TYPE = Net::HTTPError

class Net::HTTPInformation
  extend ::T::Sig
end

Net::HTTPInformationCode = Net::HTTPInformation

class Net::HTTPInsufficientStorage
  extend ::T::Sig
end

class Net::HTTPInternalServerError
  extend ::T::Sig
end

class Net::HTTPLengthRequired
  extend ::T::Sig
end

class Net::HTTPLocked
  extend ::T::Sig
end

class Net::HTTPMethodNotAllowed
  extend ::T::Sig
end

class Net::HTTPMovedPermanently
  extend ::T::Sig
end

Net::HTTPMovedTemporarily = Net::HTTPFound

class Net::HTTPMultiStatus
  extend ::T::Sig
end

Net::HTTPMultipleChoice = Net::HTTPMultipleChoices

class Net::HTTPMultipleChoices
  extend ::T::Sig
end

class Net::HTTPNetworkAuthenticationRequired
  extend ::T::Sig
end

class Net::HTTPNoContent
  extend ::T::Sig
end

class Net::HTTPNonAuthoritativeInformation
  extend ::T::Sig
end

class Net::HTTPNotAcceptable
  extend ::T::Sig
end

class Net::HTTPNotFound
  extend ::T::Sig
end

class Net::HTTPNotImplemented
  extend ::T::Sig
end

class Net::HTTPNotModified
  extend ::T::Sig
end

class Net::HTTPOK
  extend ::T::Sig
end

class Net::HTTPPartialContent
  extend ::T::Sig
end

class Net::HTTPPaymentRequired
  extend ::T::Sig
end

class Net::HTTPPermanentRedirect
  extend ::T::Sig
end

class Net::HTTPPreconditionFailed
  extend ::T::Sig
end

class Net::HTTPPreconditionRequired
  extend ::T::Sig
end

class Net::HTTPProxyAuthenticationRequired
  extend ::T::Sig
end

Net::HTTPRedirection::EXCEPTION_TYPE = Net::HTTPRetriableError

class Net::HTTPRedirection
  extend ::T::Sig
end

Net::HTTPRedirectionCode = Net::HTTPRedirection

class Net::HTTPRequest
  extend ::T::Sig
end

class Net::HTTPRequestEntityTooLarge
  extend ::T::Sig
end

class Net::HTTPRequestHeaderFieldsTooLarge
  extend ::T::Sig
end

class Net::HTTPRequestTimeOut
  extend ::T::Sig
end

Net::HTTPRequestURITooLarge = Net::HTTPRequestURITooLong

class Net::HTTPRequestURITooLong
  extend ::T::Sig
end

class Net::HTTPRequestedRangeNotSatisfiable
  extend ::T::Sig
end

class Net::HTTPResetContent
  extend ::T::Sig
end

Net::HTTPResponceReceiver = Net::HTTPResponse

class Net::HTTPResponse::Inflater
  extend ::T::Sig
end

class Net::HTTPResponse
  extend ::T::Sig
end

Net::HTTPRetriableCode = Net::HTTPRedirection

class Net::HTTPRetriableError
  extend ::T::Sig
end

class Net::HTTPSeeOther
  extend ::T::Sig
end

Net::HTTPServerError::EXCEPTION_TYPE = Net::HTTPFatalError

class Net::HTTPServerError
  extend ::T::Sig
end

Net::HTTPServerErrorCode = Net::HTTPServerError

class Net::HTTPServerException
  extend ::T::Sig
end

class Net::HTTPServiceUnavailable
  extend ::T::Sig
end

Net::HTTPSession = Net::HTTP

Net::HTTPSuccess::EXCEPTION_TYPE = Net::HTTPError

class Net::HTTPSuccess
  extend ::T::Sig
end

Net::HTTPSuccessCode = Net::HTTPSuccess

class Net::HTTPSwitchProtocol
  extend ::T::Sig
end

class Net::HTTPTemporaryRedirect
  extend ::T::Sig
end

class Net::HTTPTooManyRequests
  extend ::T::Sig
end

class Net::HTTPUnauthorized
  extend ::T::Sig
end

Net::HTTPUnknownResponse::EXCEPTION_TYPE = Net::HTTPError

class Net::HTTPUnknownResponse
  extend ::T::Sig
end

class Net::HTTPUnprocessableEntity
  extend ::T::Sig
end

class Net::HTTPUnsupportedMediaType
  extend ::T::Sig
end

class Net::HTTPUpgradeRequired
  extend ::T::Sig
end

class Net::HTTPUseProxy
  extend ::T::Sig
end

class Net::HTTPVersionNotSupported
  extend ::T::Sig
end

class Net::InternetMessageIO
  extend ::T::Sig
end

Net::NetPrivate::HTTPRequest = Net::HTTPRequest

Net::NetPrivate::Socket = Net::InternetMessageIO

module Net::NetPrivate
  extend ::T::Sig
end

class Net::OpenTimeout
  extend ::T::Sig
end

class Net::ProtoAuthError
  extend ::T::Sig
end

class Net::ProtoCommandError
  extend ::T::Sig
end

class Net::ProtoFatalError
  extend ::T::Sig
end

class Net::ProtoRetriableError
  extend ::T::Sig
end

class Net::ProtoServerError
  extend ::T::Sig
end

class Net::ProtoSyntaxError
  extend ::T::Sig
end

class Net::ProtoUnknownError
  extend ::T::Sig
end

Net::ProtocRetryError = Net::ProtoRetriableError

class Net::Protocol
  extend ::T::Sig
end

class Net::ProtocolError
  extend ::T::Sig
end

class Net::ReadAdapter
  extend ::T::Sig
end

class Net::ReadTimeout
  extend ::T::Sig
end

class Net::WriteAdapter
  extend ::T::Sig
end

module Net
  extend ::T::Sig
end

class NilClass
  include ::PSON::Pure::Generator::GeneratorMethods::NilClass
  include ::JSON::Ext::Generator::GeneratorMethods::NilClass
  def to_i(); end
end

class NilClass
  extend ::T::Sig
end

class NoMemoryError
  extend ::T::Sig
end

class NoMethodError
  include ::DidYouMean::Correctable
  def args(); end
end

class NoMethodError
  extend ::T::Sig
end

class Numeric
  def negative?(); end

  def positive?(); end

end

class Numeric
  extend ::T::Sig
end

class Object
  include ::PP::ObjectMixin
  include ::PSON::Pure::Generator::GeneratorMethods::Object
  include ::JSON::Ext::Generator::GeneratorMethods::Object
  def dclone(); end

  def psych_to_yaml(options=T.unsafe(nil)); end

  def to_yaml(options=T.unsafe(nil)); end

  def to_yaml_properties(); end
  ARCH_LIST = ::T.let(nil, ::T.untyped)
  ARCH_REGEX = ::T.let(nil, ::T.untyped)
  ARGF = ::T.let(nil, ::T.untyped)
  ARGV = ::T.let(nil, ::T.untyped)
  AgeConvertors = ::T.let(nil, ::T.untyped)
  BLANK = ::T.let(nil, ::T.untyped)
  CHECKSUM_PLAINTEXT = ::T.let(nil, ::T.untyped)
  CHECKSUM_STAT_TIME = ::T.let(nil, ::T.untyped)
  CHECKSUM_TYPES_TO_TRY = ::T.let(nil, ::T.untyped)
  COMMENTED_START_ON = ::T.let(nil, ::T.untyped)
  COMMON = ::T.let(nil, ::T.untyped)
  CREATORS = ::T.let(nil, ::T.untyped)
  CROSS_COMPILING = ::T.let(nil, ::T.untyped)
  DEFAULT_SECTION = ::T.let(nil, ::T.untyped)
  DEFAULT_SECTION_MARKER = ::T.let(nil, ::T.untyped)
  DIGEST_ALGORITHMS_TO_TRY = ::T.let(nil, ::T.untyped)
  ENV = ::T.let(nil, ::T.untyped)
  MANUAL = ::T.let(nil, ::T.untyped)
  RUBYVER = ::T.let(nil, ::T.untyped)
  RUBYVER_ARRAY = ::T.let(nil, ::T.untyped)
  RUBY_COPYRIGHT = ::T.let(nil, ::T.untyped)
  RUBY_DESCRIPTION = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE_VERSION = ::T.let(nil, ::T.untyped)
  RUBY_PATCHLEVEL = ::T.let(nil, ::T.untyped)
  RUBY_PLATFORM = ::T.let(nil, ::T.untyped)
  RUBY_RELEASE_DATE = ::T.let(nil, ::T.untyped)
  RUBY_REVISION = ::T.let(nil, ::T.untyped)
  RUBY_VERSION = ::T.let(nil, ::T.untyped)
  SEPARATOR = ::T.let(nil, ::T.untyped)
  SOURCE_ONLY_CHECKSUMS = ::T.let(nil, ::T.untyped)
  SPECIALIZED = ::T.let(nil, ::T.untyped)
  START_ON = ::T.let(nil, ::T.untyped)
  STDERR = ::T.let(nil, ::T.untyped)
  STDIN = ::T.let(nil, ::T.untyped)
  STDOUT = ::T.let(nil, ::T.untyped)
  TIME_TYPES_TO_TRY = ::T.let(nil, ::T.untyped)
  TOPLEVEL_BINDING = ::T.let(nil, ::T.untyped)
  WINDOWS_SYSTEM_SID_REGEXES = ::T.let(nil, ::T.untyped)
  WORKINGDIR = ::T.let(nil, ::T.untyped)
end

class Object
  extend ::T::Sig
  def self.yaml_tag(url); end
end

class ObjectSpace::InternalObjectWrapper
  def internal_object_id(); end

  def type(); end
end

class ObjectSpace::InternalObjectWrapper
end

class ObjectSpace::WeakMap
  def [](_); end

  def []=(_, _1); end

  def each(); end

  def each_key(); end

  def each_pair(); end

  def each_value(); end

  def key?(_); end

  def keys(); end

  def length(); end

  def size(); end

  def values(); end
end

class ObjectSpace::WeakMap
  extend ::T::Sig
end

module ObjectSpace
  extend ::T::Sig
  def self.allocation_class_path(_); end

  def self.allocation_generation(_); end

  def self.allocation_method_id(_); end

  def self.allocation_sourcefile(_); end

  def self.allocation_sourceline(_); end

  def self.count_imemo_objects(*_); end

  def self.count_nodes(*_); end

  def self.count_objects(*_); end

  def self.count_objects_size(*_); end

  def self.count_symbols(*_); end

  def self.count_tdata_objects(*_); end

  def self.define_finalizer(*_); end

  def self.dump(*_); end

  def self.dump_all(*_); end

  def self.garbage_collect(*_); end

  def self.internal_class_of(_); end

  def self.internal_super_of(_); end

  def self.memsize_of(_); end

  def self.memsize_of_all(*_); end

  def self.reachable_objects_from(_); end

  def self.reachable_objects_from_root(); end

  def self.trace_object_allocations(); end

  def self.trace_object_allocations_clear(); end

  def self.trace_object_allocations_debug_start(); end

  def self.trace_object_allocations_start(); end

  def self.trace_object_allocations_stop(); end

  def self.undefine_finalizer(_); end
end

module Open3
  extend ::T::Sig
end

class OpenSSL::ASN1::ASN1Data
  extend ::T::Sig
end

class OpenSSL::ASN1::ASN1Error
  extend ::T::Sig
end

class OpenSSL::ASN1::BMPString
  extend ::T::Sig
end

class OpenSSL::ASN1::BitString
  extend ::T::Sig
end

class OpenSSL::ASN1::Boolean
  extend ::T::Sig
end

class OpenSSL::ASN1::Constructive
  extend ::T::Sig
end

class OpenSSL::ASN1::EndOfContent
  extend ::T::Sig
end

class OpenSSL::ASN1::Enumerated
  extend ::T::Sig
end

class OpenSSL::ASN1::GeneralString
  extend ::T::Sig
end

class OpenSSL::ASN1::GeneralizedTime
  extend ::T::Sig
end

class OpenSSL::ASN1::GraphicString
  extend ::T::Sig
end

class OpenSSL::ASN1::IA5String
  extend ::T::Sig
end

class OpenSSL::ASN1::ISO64String
  extend ::T::Sig
end

class OpenSSL::ASN1::Integer
  extend ::T::Sig
end

class OpenSSL::ASN1::Null
  extend ::T::Sig
end

class OpenSSL::ASN1::NumericString
  extend ::T::Sig
end

class OpenSSL::ASN1::ObjectId
  extend ::T::Sig
end

class OpenSSL::ASN1::OctetString
  extend ::T::Sig
end

class OpenSSL::ASN1::Primitive
  extend ::T::Sig
end

class OpenSSL::ASN1::PrintableString
  extend ::T::Sig
end

class OpenSSL::ASN1::Sequence
  extend ::T::Sig
end

class OpenSSL::ASN1::Set
  extend ::T::Sig
end

class OpenSSL::ASN1::T61String
  extend ::T::Sig
end

class OpenSSL::ASN1::UTCTime
  extend ::T::Sig
end

class OpenSSL::ASN1::UTF8String
  extend ::T::Sig
end

class OpenSSL::ASN1::UniversalString
  extend ::T::Sig
end

class OpenSSL::ASN1::VideotexString
  extend ::T::Sig
end

module OpenSSL::ASN1
  extend ::T::Sig
end

class OpenSSL::BN
  def /(_); end
end

class OpenSSL::BN
  extend ::T::Sig
end

class OpenSSL::BNError
  extend ::T::Sig
end

module OpenSSL::Buffering
  extend ::T::Sig
end

class OpenSSL::Cipher::AES
  extend ::T::Sig
end

class OpenSSL::Cipher::AES128
  extend ::T::Sig
end

class OpenSSL::Cipher::AES192
  extend ::T::Sig
end

class OpenSSL::Cipher::AES256
  extend ::T::Sig
end

class OpenSSL::Cipher::BF
  extend ::T::Sig
end

class OpenSSL::Cipher::CAST5
  extend ::T::Sig
end

class OpenSSL::Cipher::CipherError
  extend ::T::Sig
end

class OpenSSL::Cipher::DES
  extend ::T::Sig
end

class OpenSSL::Cipher::IDEA
  extend ::T::Sig
end

class OpenSSL::Cipher::RC2
  extend ::T::Sig
end

class OpenSSL::Cipher::RC4
  extend ::T::Sig
end

class OpenSSL::Cipher::RC5
  extend ::T::Sig
end

class OpenSSL::Cipher
  extend ::T::Sig
end

class OpenSSL::Config
  extend ::T::Sig
end

class OpenSSL::ConfigError
  extend ::T::Sig
end

class OpenSSL::Digest
  extend ::T::Sig
end

class OpenSSL::Engine::EngineError
  extend ::T::Sig
end

class OpenSSL::Engine
  extend ::T::Sig
end

module OpenSSL::ExtConfig
  extend ::T::Sig
end

class OpenSSL::HMAC
  extend ::T::Sig
end

class OpenSSL::HMACError
  extend ::T::Sig
end

class OpenSSL::Netscape::SPKI
  extend ::T::Sig
end

class OpenSSL::Netscape::SPKIError
  extend ::T::Sig
end

module OpenSSL::Netscape
  extend ::T::Sig
end

class OpenSSL::OCSP::BasicResponse
  extend ::T::Sig
end

class OpenSSL::OCSP::CertificateId
  extend ::T::Sig
end

class OpenSSL::OCSP::OCSPError
  extend ::T::Sig
end

class OpenSSL::OCSP::Request
  extend ::T::Sig
end

class OpenSSL::OCSP::Response
  extend ::T::Sig
end

module OpenSSL::OCSP
  extend ::T::Sig
end

class OpenSSL::OpenSSLError
  extend ::T::Sig
end

class OpenSSL::PKCS12::PKCS12Error
  extend ::T::Sig
end

class OpenSSL::PKCS12
  extend ::T::Sig
end

class OpenSSL::PKCS5::PKCS5Error
  extend ::T::Sig
end

module OpenSSL::PKCS5
  extend ::T::Sig
end

class OpenSSL::PKCS7::PKCS7Error
  extend ::T::Sig
end

class OpenSSL::PKCS7::RecipientInfo
  extend ::T::Sig
end

OpenSSL::PKCS7::Signer = OpenSSL::PKCS7::SignerInfo

class OpenSSL::PKCS7::SignerInfo
  extend ::T::Sig
end

class OpenSSL::PKCS7
  extend ::T::Sig
end

class OpenSSL::PKey::DH
  DEFAULT_512 = ::T.let(nil, ::T.untyped)
end

class OpenSSL::PKey::DH
  extend ::T::Sig
end

class OpenSSL::PKey::DHError
  extend ::T::Sig
end

class OpenSSL::PKey::DSA
  extend ::T::Sig
end

class OpenSSL::PKey::DSAError
  extend ::T::Sig
end

class OpenSSL::PKey::EC::Group::Error
  extend ::T::Sig
end

class OpenSSL::PKey::EC::Group
  extend ::T::Sig
end

class OpenSSL::PKey::EC::Point::Error
  extend ::T::Sig
end

class OpenSSL::PKey::EC::Point
  extend ::T::Sig
end

class OpenSSL::PKey::EC
  extend ::T::Sig
end

class OpenSSL::PKey::ECError
  extend ::T::Sig
end

class OpenSSL::PKey::PKey
  extend ::T::Sig
end

class OpenSSL::PKey::PKeyError
  extend ::T::Sig
end

class OpenSSL::PKey::RSA
  extend ::T::Sig
end

class OpenSSL::PKey::RSAError
  extend ::T::Sig
end

module OpenSSL::PKey
  extend ::T::Sig
  def self.__original_read(*_); end
end

class OpenSSL::Random::RandomError
  extend ::T::Sig
end

module OpenSSL::Random
  extend ::T::Sig
end

class OpenSSL::SSL::SSLContext
  def alpn_protocols(); end

  def alpn_protocols=(alpn_protocols); end

  def alpn_select_cb(); end

  def alpn_select_cb=(alpn_select_cb); end
  INIT_VARS = ::T.let(nil, ::T.untyped)
end

class OpenSSL::SSL::SSLContext
  extend ::T::Sig
end

class OpenSSL::SSL::SSLError
  extend ::T::Sig
end

class OpenSSL::SSL::SSLErrorWaitReadable
  extend ::T::Sig
end

class OpenSSL::SSL::SSLErrorWaitWritable
  extend ::T::Sig
end

class OpenSSL::SSL::SSLServer
  extend ::T::Sig
end

class OpenSSL::SSL::SSLSocket
  def alpn_protocol(); end

end

class OpenSSL::SSL::SSLSocket
  extend ::T::Sig
end

class OpenSSL::SSL::Session::SessionError
  extend ::T::Sig
end

class OpenSSL::SSL::Session
  extend ::T::Sig
end

module OpenSSL::SSL::SocketForwarder
  extend ::T::Sig
end

module OpenSSL::SSL
  extend ::T::Sig
end

class OpenSSL::X509::Attribute
  extend ::T::Sig
end

class OpenSSL::X509::AttributeError
  extend ::T::Sig
end

class OpenSSL::X509::CRL
  extend ::T::Sig
end

class OpenSSL::X509::CRLError
  extend ::T::Sig
end

class OpenSSL::X509::Certificate
  extend ::T::Sig
end

class OpenSSL::X509::CertificateError
  extend ::T::Sig
end

class OpenSSL::X509::Extension
  extend ::T::Sig
end

class OpenSSL::X509::ExtensionError
  extend ::T::Sig
end

class OpenSSL::X509::ExtensionFactory
  extend ::T::Sig
end

module OpenSSL::X509::Name::RFC2253DN
  extend ::T::Sig
end

class OpenSSL::X509::Name
  extend ::T::Sig
end

class OpenSSL::X509::NameError
  extend ::T::Sig
end

class OpenSSL::X509::Request
  extend ::T::Sig
end

class OpenSSL::X509::RequestError
  extend ::T::Sig
end

class OpenSSL::X509::Revoked
  extend ::T::Sig
end

class OpenSSL::X509::RevokedError
  extend ::T::Sig
end

class OpenSSL::X509::Store
  extend ::T::Sig
end

class OpenSSL::X509::StoreContext
  extend ::T::Sig
end

class OpenSSL::X509::StoreError
  extend ::T::Sig
end

module OpenSSL::X509
  extend ::T::Sig
end

module OpenSSL
  extend ::T::Sig
end

class OpenStruct
  extend ::T::Sig
end

module OpenURI
  Options = ::T.let(nil, ::T.untyped)
end

class OpenURI::Buffer
  def <<(str); end

  def io(); end

  def size(); end
  StringMax = ::T.let(nil, ::T.untyped)
end

class OpenURI::Buffer
end

class OpenURI::HTTPError
  def initialize(message, io); end

  def io(); end
end

class OpenURI::HTTPError
end

class OpenURI::HTTPRedirect
  def initialize(message, io, uri); end

  def uri(); end
end

class OpenURI::HTTPRedirect
end

module OpenURI::Meta
  def base_uri(); end

  def base_uri=(base_uri); end

  def charset(); end

  def content_encoding(); end

  def content_type(); end

  def content_type_parse(); end

  def last_modified(); end

  def meta(); end

  def meta_add_field(name, value); end

  def meta_add_field2(name, values); end

  def meta_setup_encoding(); end

  def metas(); end

  def status(); end

  def status=(status); end
  RE_LWS = ::T.let(nil, ::T.untyped)
  RE_PARAMETERS = ::T.let(nil, ::T.untyped)
  RE_QUOTED_STRING = ::T.let(nil, ::T.untyped)
  RE_TOKEN = ::T.let(nil, ::T.untyped)
end

module OpenURI::Meta
  extend ::T::Sig
  def self.init(obj, src=T.unsafe(nil)); end
end

module OpenURI::OpenRead
  def open(*rest, &block); end

  def read(options=T.unsafe(nil)); end
end

module OpenURI::OpenRead
  extend ::T::Sig
end

module OpenURI
  extend ::T::Sig
  def self.check_options(options); end

  def self.open_http(buf, target, proxy, options); end

  def self.open_loop(uri, options); end

  def self.scan_open_optional_arguments(*rest); end
end

OptParse = OptionParser

class OptionParser
  def abort(mesg=T.unsafe(nil)); end

  def accept(*args, &blk); end

  def add_officious(); end

  def banner(); end

  def banner=(banner); end

  def base(); end

  def candidate(word); end

  def compsys(to, name=T.unsafe(nil)); end

  def def_head_option(*opts, &block); end

  def def_option(*opts, &block); end

  def def_tail_option(*opts, &block); end

  def default_argv(); end

  def default_argv=(default_argv); end

  def define(*opts, &block); end

  def define_head(*opts, &block); end

  def define_tail(*opts, &block); end

  def environment(env=T.unsafe(nil)); end

  def getopts(*args); end

  def help(); end

  def inc(*args); end

  def initialize(banner=T.unsafe(nil), width=T.unsafe(nil), indent=T.unsafe(nil)); end

  def load(filename=T.unsafe(nil)); end

  def make_switch(opts, block=T.unsafe(nil)); end

  def new(); end

  def on(*opts, &block); end

  def on_head(*opts, &block); end

  def on_tail(*opts, &block); end

  def order(*argv, &block); end

  def order!(argv=T.unsafe(nil), &nonopt); end

  def parse(*argv); end

  def parse!(argv=T.unsafe(nil)); end

  def permute(*argv); end

  def permute!(argv=T.unsafe(nil)); end

  def program_name(); end

  def program_name=(program_name); end

  def reject(*args, &blk); end

  def release(); end

  def release=(release); end

  def remove(); end

  def separator(string); end

  def set_banner(_); end

  def set_program_name(_); end

  def set_summary_indent(_); end

  def set_summary_width(_); end

  def summarize(to=T.unsafe(nil), width=T.unsafe(nil), max=T.unsafe(nil), indent=T.unsafe(nil), &blk); end

  def summary_indent(); end

  def summary_indent=(summary_indent); end

  def summary_width(); end

  def summary_width=(summary_width); end

  def terminate(arg=T.unsafe(nil)); end

  def to_a(); end

  def top(); end

  def ver(); end

  def version(); end

  def version=(version); end

  def warn(mesg=T.unsafe(nil)); end
  ArgumentStyle = ::T.let(nil, ::T.untyped)
  COMPSYS_HEADER = ::T.let(nil, ::T.untyped)
  DecimalInteger = ::T.let(nil, ::T.untyped)
  DecimalNumeric = ::T.let(nil, ::T.untyped)
  DefaultList = ::T.let(nil, ::T.untyped)
  NO_ARGUMENT = ::T.let(nil, ::T.untyped)
  NoArgument = ::T.let(nil, ::T.untyped)
  OPTIONAL_ARGUMENT = ::T.let(nil, ::T.untyped)
  OctalInteger = ::T.let(nil, ::T.untyped)
  Officious = ::T.let(nil, ::T.untyped)
  OptionalArgument = ::T.let(nil, ::T.untyped)
  REQUIRED_ARGUMENT = ::T.let(nil, ::T.untyped)
  RequiredArgument = ::T.let(nil, ::T.untyped)
  SPLAT_PROC = ::T.let(nil, ::T.untyped)
end

module OptionParser::Acceptables
  DecimalInteger = ::T.let(nil, ::T.untyped)
  DecimalNumeric = ::T.let(nil, ::T.untyped)
  OctalInteger = ::T.let(nil, ::T.untyped)
end

module OptionParser::Acceptables
  extend ::T::Sig
end

class OptionParser::AmbiguousArgument
  Reason = ::T.let(nil, ::T.untyped)
end

class OptionParser::AmbiguousArgument
end

class OptionParser::AmbiguousOption
  Reason = ::T.let(nil, ::T.untyped)
end

class OptionParser::AmbiguousOption
end

module OptionParser::Arguable
  def getopts(*args); end

  def initialize(*args); end

  def options(); end

  def options=(opt); end

  def order!(&blk); end

  def parse!(); end

  def permute!(); end
end

module OptionParser::Arguable
  extend ::T::Sig
  def self.extend_object(obj); end
end

class OptionParser::CompletingHash
  include ::OptionParser::Completion
  def match(key); end
end

class OptionParser::CompletingHash
end

module OptionParser::Completion
  def candidate(key, icase=T.unsafe(nil), pat=T.unsafe(nil)); end

  def complete(key, icase=T.unsafe(nil), pat=T.unsafe(nil)); end

  def convert(opt=T.unsafe(nil), val=T.unsafe(nil), *_); end
end

module OptionParser::Completion
  extend ::T::Sig
  def self.candidate(key, icase=T.unsafe(nil), pat=T.unsafe(nil), &block); end

  def self.regexp(key, icase); end
end

class OptionParser::InvalidArgument
  Reason = ::T.let(nil, ::T.untyped)
end

class OptionParser::InvalidArgument
end

class OptionParser::InvalidOption
  Reason = ::T.let(nil, ::T.untyped)
end

class OptionParser::InvalidOption
end

class OptionParser::List
  def accept(t, pat=T.unsafe(nil), &block); end

  def add_banner(to); end

  def append(*args); end

  def atype(); end

  def complete(id, opt, icase=T.unsafe(nil), *pat, &block); end

  def compsys(*args, &block); end

  def each_option(&block); end

  def list(); end

  def long(); end

  def prepend(*args); end

  def reject(t); end

  def search(id, key); end

  def short(); end

  def summarize(*args, &block); end
end

class OptionParser::List
end

class OptionParser::MissingArgument
  Reason = ::T.let(nil, ::T.untyped)
end

class OptionParser::MissingArgument
end

class OptionParser::NeedlessArgument
  Reason = ::T.let(nil, ::T.untyped)
end

class OptionParser::NeedlessArgument
end

class OptionParser::OptionMap
  include ::OptionParser::Completion
end

class OptionParser::OptionMap
end

class OptionParser::ParseError
  def args(); end

  def initialize(*args); end

  def reason(); end

  def reason=(reason); end

  def recover(argv); end

  def set_backtrace(array); end

  def set_option(opt, eq); end
  Reason = ::T.let(nil, ::T.untyped)
end

class OptionParser::ParseError
  def self.filter_backtrace(array); end
end

class OptionParser::Switch
  def add_banner(to); end

  def arg(); end

  def block(); end

  def compsys(sdone, ldone); end

  def conv(); end

  def desc(); end

  def initialize(pattern=T.unsafe(nil), conv=T.unsafe(nil), short=T.unsafe(nil), long=T.unsafe(nil), arg=T.unsafe(nil), desc=T.unsafe(nil), block=T.unsafe(nil)); end

  def long(); end

  def match_nonswitch?(str); end

  def pattern(); end

  def short(); end

  def summarize(sdone=T.unsafe(nil), ldone=T.unsafe(nil), width=T.unsafe(nil), max=T.unsafe(nil), indent=T.unsafe(nil)); end

  def switch_name(); end
end

class OptionParser::Switch::NoArgument
  def parse(arg, argv); end
end

class OptionParser::Switch::NoArgument
  def self.incompatible_argument_styles(*_); end
end

class OptionParser::Switch::OptionalArgument
  def parse(arg, argv, &error); end
end

class OptionParser::Switch::OptionalArgument
end

class OptionParser::Switch::PlacedArgument
  def parse(arg, argv, &error); end
end

class OptionParser::Switch::PlacedArgument
end

class OptionParser::Switch::RequiredArgument
  def parse(arg, argv); end
end

class OptionParser::Switch::RequiredArgument
end

class OptionParser::Switch
  def self.guess(arg); end

  def self.incompatible_argument_styles(arg, t); end

  def self.pattern(); end
end

class OptionParser
  def self.accept(*args, &blk); end

  def self.getopts(*args); end

  def self.inc(arg, default=T.unsafe(nil)); end

  def self.reject(*args, &blk); end

  def self.terminate(arg=T.unsafe(nil)); end

  def self.top(); end

  def self.with(*args, &block); end
end

module PP::ObjectMixin
  extend ::T::Sig
end

module PP::PPMethods
  extend ::T::Sig
end

class PP::SingleLine
  extend ::T::Sig
end

class PP
  extend ::T::Sig
end

PSON::Parser = PSON::Pure::Parser

module PSON::Pure::Generator::GeneratorMethods::Array
  extend ::T::Sig
end

module PSON::Pure::Generator::GeneratorMethods::FalseClass
  extend ::T::Sig
end

module PSON::Pure::Generator::GeneratorMethods::Float
  extend ::T::Sig
end

module PSON::Pure::Generator::GeneratorMethods::Hash
  extend ::T::Sig
end

module PSON::Pure::Generator::GeneratorMethods::Integer
  extend ::T::Sig
end

module PSON::Pure::Generator::GeneratorMethods::NilClass
  extend ::T::Sig
end

module PSON::Pure::Generator::GeneratorMethods::Object
  extend ::T::Sig
end

module PSON::Pure::Generator::GeneratorMethods::String
  extend ::T::Sig
end

module PSON::Pure::Generator::GeneratorMethods::TrueClass
  extend ::T::Sig
end

module PSON::Pure::Generator::GeneratorMethods
  extend ::T::Sig
end

module PSON::Pure::Generator
  extend ::T::Sig
end

module PSON::Pure
  extend ::T::Sig
end

PSON::State = PSON::Pure::Generator::State

module PSON
  extend ::T::Sig
  def self.fast_unparse(obj); end

  def self.pretty_unparse(obj, opts=T.unsafe(nil)); end

  def self.restore(source, proc=T.unsafe(nil)); end

  def self.unparse(obj, state=T.unsafe(nil)); end
end

module ParserRspecHelper
  extend ::T::Sig
end

class Pathname
  def fnmatch?(*_); end

  def make_symlink(_); end

end

class Pathname
  extend ::T::Sig
end

class PrettyPrint::Breakable
  extend ::T::Sig
end

class PrettyPrint::Group
  extend ::T::Sig
end

class PrettyPrint::GroupQueue
  extend ::T::Sig
end

class PrettyPrint::SingleLine
  extend ::T::Sig
end

class PrettyPrint::Text
  extend ::T::Sig
end

class PrettyPrint
  extend ::T::Sig
end

class Prime
  include ::Enumerable
  include ::Singleton
  def each(ubound=T.unsafe(nil), generator=T.unsafe(nil), &block); end

  def int_from_prime_division(pd); end

  def prime?(value, generator=T.unsafe(nil)); end

  def prime_division(value, generator=T.unsafe(nil)); end
end

class Prime::EratosthenesGenerator
  def initialize(); end
end

class Prime::EratosthenesGenerator
end

class Prime::EratosthenesSieve
  include ::Singleton
  def get_nth_prime(n); end
end

class Prime::EratosthenesSieve
  extend ::Singleton::SingletonClassMethods
  def self.instance(); end
end

class Prime::Generator23
  def initialize(); end
end

class Prime::Generator23
end

class Prime::PseudoPrimeGenerator
  include ::Enumerable
  def each(); end

  def initialize(ubound=T.unsafe(nil)); end

  def next(); end

  def rewind(); end

  def size(); end

  def succ(); end

  def upper_bound(); end

  def upper_bound=(ubound); end

  def with_index(offset=T.unsafe(nil)); end

  def with_object(obj); end
end

class Prime::PseudoPrimeGenerator
end

class Prime::TrialDivision
  include ::Singleton
  def [](index); end

  def cache(); end

  def primes(); end

  def primes_so_far(); end
end

class Prime::TrialDivision
  extend ::Singleton::SingletonClassMethods
  def self.instance(); end
end

class Prime::TrialDivisionGenerator
  def initialize(); end
end

class Prime::TrialDivisionGenerator
end

class Prime
  extend ::Singleton::SingletonClassMethods
  extend ::Enumerable
  def self.each(*args, &block); end

  def self.instance(); end

  def self.int_from_prime_division(*args, &block); end

  def self.method_added(method); end

  def self.prime?(*args, &block); end

  def self.prime_division(*args, &block); end
end

class Proc
  def ===(*_); end

  def [](*_); end

  def lambda?(); end

  def yield(*_); end
end

class Proc
  extend ::T::Sig
end

module Process::GID
  extend ::T::Sig
end

class Process::Status
  extend ::T::Sig
end

module Process::Sys
  extend ::T::Sig
  def self.getegid(); end

end

class Process::Tms
  def cstime(); end

  def cstime=(_); end

  def cutime(); end

  def cutime=(_); end

  def stime(); end

  def stime=(_); end

  def utime(); end

  def utime=(_); end
end

class Process::Tms
  extend ::T::Sig
  def self.[](*_); end

  def self.members(); end
end

module Process::UID
  extend ::T::Sig
end

class Process::Waiter
  extend ::T::Sig
end

module Process
  extend ::T::Sig
  def self.setpgrp(); end

end

module Psych
  DEPRECATED = ::T.let(nil, ::T.untyped)
  LIBYAML_VERSION = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Psych::BadAlias
end

class Psych::BadAlias
end

class Psych::ClassLoader
  def big_decimal(); end

  def complex(); end

  def date(); end

  def date_time(); end

  def exception(); end

  def load(klassname); end

  def object(); end

  def psych_omap(); end

  def psych_set(); end

  def range(); end

  def rational(); end

  def regexp(); end

  def struct(); end

  def symbol(); end

  def symbolize(sym); end
  BIG_DECIMAL = ::T.let(nil, ::T.untyped)
  CACHE = ::T.let(nil, ::T.untyped)
  COMPLEX = ::T.let(nil, ::T.untyped)
  DATE = ::T.let(nil, ::T.untyped)
  DATE_TIME = ::T.let(nil, ::T.untyped)
  EXCEPTION = ::T.let(nil, ::T.untyped)
  OBJECT = ::T.let(nil, ::T.untyped)
  PSYCH_OMAP = ::T.let(nil, ::T.untyped)
  PSYCH_SET = ::T.let(nil, ::T.untyped)
  RANGE = ::T.let(nil, ::T.untyped)
  RATIONAL = ::T.let(nil, ::T.untyped)
  REGEXP = ::T.let(nil, ::T.untyped)
  STRUCT = ::T.let(nil, ::T.untyped)
  SYMBOL = ::T.let(nil, ::T.untyped)
end

class Psych::ClassLoader::Restricted
  def initialize(classes, symbols); end
end

class Psych::ClassLoader::Restricted
end

class Psych::ClassLoader
end

class Psych::Coder
  def [](k); end

  def []=(k, v); end

  def add(k, v); end

  def implicit(); end

  def implicit=(implicit); end

  def initialize(tag); end

  def map(tag=T.unsafe(nil), style=T.unsafe(nil)); end

  def map=(map); end

  def object(); end

  def object=(object); end

  def represent_map(tag, map); end

  def represent_object(tag, obj); end

  def represent_scalar(tag, value); end

  def represent_seq(tag, list); end

  def scalar(*args); end

  def scalar=(value); end

  def seq(); end

  def seq=(list); end

  def style(); end

  def style=(style); end

  def tag(); end

  def tag=(tag); end

  def type(); end
end

class Psych::Coder
end

module Psych::DeprecatedMethods
  def taguri(); end

  def taguri=(taguri); end

  def to_yaml_style(); end

  def to_yaml_style=(to_yaml_style); end
end

module Psych::DeprecatedMethods
  extend ::T::Sig
end

class Psych::DisallowedClass
  def initialize(klass_name); end
end

class Psych::DisallowedClass
end

class Psych::Emitter
  def alias(_); end

  def canonical(); end

  def canonical=(canonical); end

  def end_document(_); end

  def indentation(); end

  def indentation=(indentation); end

  def initialize(*_); end

  def line_width(); end

  def line_width=(line_width); end

  def scalar(_, _1, _2, _3, _4, _5); end

  def start_document(_, _1, _2); end

  def start_mapping(_, _1, _2, _3); end

  def start_sequence(_, _1, _2, _3); end

  def start_stream(_); end
end

class Psych::Emitter
end

class Psych::Exception
end

class Psych::Exception
end

class Psych::FALLBACK
  def to_ruby(); end

  def to_ruby=(_); end
end

class Psych::FALLBACK
  def self.[](*_); end

  def self.members(); end
end

class Psych::Handler
  def alias(anchor); end

  def empty(); end

  def end_document(implicit); end

  def end_mapping(); end

  def end_sequence(); end

  def end_stream(); end

  def scalar(value, anchor, tag, plain, quoted, style); end

  def start_document(version, tag_directives, implicit); end

  def start_mapping(anchor, tag, implicit, style); end

  def start_sequence(anchor, tag, implicit, style); end

  def start_stream(encoding); end

  def streaming?(); end
  EVENTS = ::T.let(nil, ::T.untyped)
  OPTIONS = ::T.let(nil, ::T.untyped)
end

class Psych::Handler::DumperOptions
  def canonical(); end

  def canonical=(canonical); end

  def indentation(); end

  def indentation=(indentation); end

  def line_width(); end

  def line_width=(line_width); end
end

class Psych::Handler::DumperOptions
end

class Psych::Handler
end

module Psych::Handlers
end

class Psych::Handlers::DocumentStream
  def initialize(&block); end
end

class Psych::Handlers::DocumentStream
end

module Psych::Handlers
  extend ::T::Sig
end

module Psych::JSON
end

module Psych::JSON::RubyEvents
  def visit_DateTime(o); end

  def visit_String(o); end

  def visit_Symbol(o); end

  def visit_Time(o); end
end

module Psych::JSON::RubyEvents
  extend ::T::Sig
end

class Psych::JSON::Stream
  include ::Psych::Streaming
end

class Psych::JSON::Stream::Emitter
  include ::Psych::JSON::YAMLEvents
end

class Psych::JSON::Stream::Emitter
end

class Psych::JSON::Stream
  extend ::Psych::Streaming::ClassMethods
end

class Psych::JSON::TreeBuilder
  include ::Psych::JSON::YAMLEvents
end

class Psych::JSON::TreeBuilder
end

module Psych::JSON::YAMLEvents
  def end_document(implicit_end=T.unsafe(nil)); end

  def scalar(value, anchor, tag, plain, quoted, style); end

  def start_document(version, tag_directives, implicit); end

  def start_mapping(anchor, tag, implicit, style); end

  def start_sequence(anchor, tag, implicit, style); end
end

module Psych::JSON::YAMLEvents
  extend ::T::Sig
end

module Psych::JSON
  extend ::T::Sig
end

module Psych::Nodes
end

class Psych::Nodes::Alias
  def anchor(); end

  def anchor=(anchor); end

  def initialize(anchor); end
end

class Psych::Nodes::Alias
end

class Psych::Nodes::Document
  def implicit(); end

  def implicit=(implicit); end

  def implicit_end(); end

  def implicit_end=(implicit_end); end

  def initialize(version=T.unsafe(nil), tag_directives=T.unsafe(nil), implicit=T.unsafe(nil)); end

  def root(); end

  def tag_directives(); end

  def tag_directives=(tag_directives); end

  def version(); end

  def version=(version); end
end

class Psych::Nodes::Document
end

class Psych::Nodes::Mapping
  def anchor(); end

  def anchor=(anchor); end

  def implicit(); end

  def implicit=(implicit); end

  def initialize(anchor=T.unsafe(nil), tag=T.unsafe(nil), implicit=T.unsafe(nil), style=T.unsafe(nil)); end

  def style(); end

  def style=(style); end

  def tag=(tag); end
  ANY = ::T.let(nil, ::T.untyped)
  BLOCK = ::T.let(nil, ::T.untyped)
  FLOW = ::T.let(nil, ::T.untyped)
end

class Psych::Nodes::Mapping
end

class Psych::Nodes::Node
  include ::Enumerable
  def children(); end

  def each(&block); end

  def tag(); end

  def to_ruby(); end

  def to_yaml(io=T.unsafe(nil), options=T.unsafe(nil)); end

  def transform(); end

  def yaml(io=T.unsafe(nil), options=T.unsafe(nil)); end
end

class Psych::Nodes::Node
end

class Psych::Nodes::Scalar
  def anchor(); end

  def anchor=(anchor); end

  def initialize(value, anchor=T.unsafe(nil), tag=T.unsafe(nil), plain=T.unsafe(nil), quoted=T.unsafe(nil), style=T.unsafe(nil)); end

  def plain(); end

  def plain=(plain); end

  def quoted(); end

  def quoted=(quoted); end

  def style(); end

  def style=(style); end

  def tag=(tag); end

  def value(); end

  def value=(value); end
  ANY = ::T.let(nil, ::T.untyped)
  DOUBLE_QUOTED = ::T.let(nil, ::T.untyped)
  FOLDED = ::T.let(nil, ::T.untyped)
  LITERAL = ::T.let(nil, ::T.untyped)
  PLAIN = ::T.let(nil, ::T.untyped)
  SINGLE_QUOTED = ::T.let(nil, ::T.untyped)
end

class Psych::Nodes::Scalar
end

class Psych::Nodes::Sequence
  def anchor(); end

  def anchor=(anchor); end

  def implicit(); end

  def implicit=(implicit); end

  def initialize(anchor=T.unsafe(nil), tag=T.unsafe(nil), implicit=T.unsafe(nil), style=T.unsafe(nil)); end

  def style(); end

  def style=(style); end

  def tag=(tag); end
  ANY = ::T.let(nil, ::T.untyped)
  BLOCK = ::T.let(nil, ::T.untyped)
  FLOW = ::T.let(nil, ::T.untyped)
end

class Psych::Nodes::Sequence
end

class Psych::Nodes::Stream
  def encoding(); end

  def encoding=(encoding); end

  def initialize(encoding=T.unsafe(nil)); end
  ANY = ::T.let(nil, ::T.untyped)
  UTF16BE = ::T.let(nil, ::T.untyped)
  UTF16LE = ::T.let(nil, ::T.untyped)
  UTF8 = ::T.let(nil, ::T.untyped)
end

class Psych::Nodes::Stream
end

module Psych::Nodes
  extend ::T::Sig
end

class Psych::Omap
end

class Psych::Omap
end

class Psych::Parser
  def external_encoding=(external_encoding); end

  def handler(); end

  def handler=(handler); end

  def initialize(handler=T.unsafe(nil)); end

  def mark(); end

  def parse(*_); end
  ANY = ::T.let(nil, ::T.untyped)
  UTF16BE = ::T.let(nil, ::T.untyped)
  UTF16LE = ::T.let(nil, ::T.untyped)
  UTF8 = ::T.let(nil, ::T.untyped)
end

class Psych::Parser::Mark
end

class Psych::Parser::Mark
end

class Psych::Parser
end

class Psych::ScalarScanner
  def class_loader(); end

  def initialize(class_loader); end

  def parse_int(string); end

  def parse_time(string); end

  def tokenize(string); end
  FLOAT = ::T.let(nil, ::T.untyped)
  INTEGER = ::T.let(nil, ::T.untyped)
  TIME = ::T.let(nil, ::T.untyped)
end

class Psych::ScalarScanner
end

class Psych::Set
end

class Psych::Set
end

class Psych::Stream
  include ::Psych::Streaming
end

class Psych::Stream::Emitter
  def end_document(implicit_end=T.unsafe(nil)); end
end

class Psych::Stream::Emitter
end

class Psych::Stream
  extend ::Psych::Streaming::ClassMethods
end

module Psych::Streaming
  def start(encoding=T.unsafe(nil)); end
end

module Psych::Streaming::ClassMethods
  def new(io); end
end

module Psych::Streaming::ClassMethods
  extend ::T::Sig
end

module Psych::Streaming
  extend ::T::Sig
end

class Psych::SyntaxError
  def column(); end

  def context(); end

  def file(); end

  def initialize(file, line, col, offset, problem, context); end

  def line(); end

  def offset(); end

  def problem(); end
end

class Psych::SyntaxError
end

class Psych::TreeBuilder
  def end_document(implicit_end=T.unsafe(nil)); end

  def root(); end
end

class Psych::TreeBuilder
end

module Psych::Visitors
end

class Psych::Visitors::DepthFirst
  def initialize(block); end
end

class Psych::Visitors::DepthFirst
end

class Psych::Visitors::Emitter
  def initialize(io, options=T.unsafe(nil)); end

  def visit_Psych_Nodes_Alias(o); end

  def visit_Psych_Nodes_Document(o); end

  def visit_Psych_Nodes_Mapping(o); end

  def visit_Psych_Nodes_Scalar(o); end

  def visit_Psych_Nodes_Sequence(o); end

  def visit_Psych_Nodes_Stream(o); end
end

class Psych::Visitors::Emitter
end

class Psych::Visitors::JSONTree
  include ::Psych::JSON::RubyEvents
end

class Psych::Visitors::JSONTree
  def self.create(options=T.unsafe(nil)); end
end

class Psych::Visitors::NoAliasRuby
end

class Psych::Visitors::NoAliasRuby
end

class Psych::Visitors::ToRuby
  def class_loader(); end

  def initialize(ss, class_loader); end

  def visit_Psych_Nodes_Alias(o); end

  def visit_Psych_Nodes_Document(o); end

  def visit_Psych_Nodes_Mapping(o); end

  def visit_Psych_Nodes_Scalar(o); end

  def visit_Psych_Nodes_Sequence(o); end

  def visit_Psych_Nodes_Stream(o); end
  SHOVEL = ::T.let(nil, ::T.untyped)
end

class Psych::Visitors::ToRuby
  def self.create(); end
end

class Psych::Visitors::Visitor
  def accept(target); end
  DISPATCH = ::T.let(nil, ::T.untyped)
end

class Psych::Visitors::Visitor
end

class Psych::Visitors::YAMLTree
  def <<(object); end

  def finish(); end

  def finished(); end

  def finished?(); end

  def initialize(emitter, ss, options); end

  def push(object); end

  def start(encoding=T.unsafe(nil)); end

  def started(); end

  def started?(); end

  def tree(); end

  def visit_Array(o); end

  def visit_BasicObject(o); end

  def visit_BigDecimal(o); end

  def visit_Class(o); end

  def visit_Complex(o); end

  def visit_Date(o); end

  def visit_DateTime(o); end

  def visit_Encoding(o); end

  def visit_Exception(o); end

  def visit_FalseClass(o); end

  def visit_Float(o); end

  def visit_Hash(o); end

  def visit_Integer(o); end

  def visit_Module(o); end

  def visit_NameError(o); end

  def visit_NilClass(o); end

  def visit_Object(o); end

  def visit_Psych_Omap(o); end

  def visit_Psych_Set(o); end

  def visit_Range(o); end

  def visit_Rational(o); end

  def visit_Regexp(o); end

  def visit_String(o); end

  def visit_Struct(o); end

  def visit_Symbol(o); end

  def visit_Time(o); end

  def visit_TrueClass(o); end
  BINARY_RANGE = ::T.let(nil, ::T.untyped)
  NULL = ::T.let(nil, ::T.untyped)
  WS_RANGE = ::T.let(nil, ::T.untyped)
end

class Psych::Visitors::YAMLTree
  def self.create(options=T.unsafe(nil), emitter=T.unsafe(nil)); end

  def self.new(emitter=T.unsafe(nil), ss=T.unsafe(nil), options=T.unsafe(nil)); end
end

module Psych::Visitors
  extend ::T::Sig
end

module Psych
  extend ::T::Sig
  def self.add_builtin_type(type_tag, &block); end

  def self.add_domain_type(domain, type_tag, &block); end

  def self.add_private_type(type_tag, &block); end

  def self.add_ruby_type(type_tag, &block); end

  def self.add_tag(tag, klass); end

  def self.detect_implicit(thing); end

  def self.domain_types(); end

  def self.domain_types=(domain_types); end

  def self.dump(o, io=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.dump_stream(*objects); end

  def self.dump_tags(); end

  def self.dump_tags=(dump_tags); end

  def self.libyaml_version(); end

  def self.load(yaml, filename=T.unsafe(nil), fallback=T.unsafe(nil)); end

  def self.load_documents(yaml, &block); end

  def self.load_file(filename, fallback=T.unsafe(nil)); end

  def self.load_stream(yaml, filename=T.unsafe(nil)); end

  def self.load_tags(); end

  def self.load_tags=(load_tags); end

  def self.object_maker(klass, hash); end

  def self.parse(yaml, filename=T.unsafe(nil), fallback=T.unsafe(nil)); end

  def self.parse_file(filename); end

  def self.parse_stream(yaml, filename=T.unsafe(nil), &block); end

  def self.parser(); end

  def self.quick_emit(thing, opts=T.unsafe(nil), &block); end

  def self.read_type_class(type, reference); end

  def self.remove_type(type_tag); end

  def self.safe_load(yaml, whitelist_classes=T.unsafe(nil), whitelist_symbols=T.unsafe(nil), aliases=T.unsafe(nil), filename=T.unsafe(nil)); end

  def self.tagurize(thing); end

  def self.to_json(object); end
end

class PublicSuffix::Rule::Entry
  def self.[](*_); end

  def self.members(); end
end

module PublicSuffix::Rule
  extend ::T::Sig
end

module PublicSuffix
  extend ::T::Sig
end

module Puppet::Acceptance::AgentFqdnUtils
  extend ::T::Sig
end

module Puppet::Acceptance::AixUtil
  extend ::T::Sig
end

module Puppet::Acceptance::BeakerUtils
  extend ::T::Sig
end

module Puppet::Acceptance::CommandUtils
  extend ::T::Sig
end

module Puppet::Acceptance::EnvironmentUtils
  extend ::T::Sig
end

module Puppet::Acceptance::I18nDemoUtils
  extend ::T::Sig
end

module Puppet::Acceptance::I18nUtils
  extend ::T::Sig
end

module Puppet::Acceptance::IPSUtils
  extend ::T::Sig
end

module Puppet::Acceptance::ManifestUtils
  extend ::T::Sig
end

module Puppet::Acceptance::ModuleUtils
  extend ::T::Sig
end

module Puppet::Acceptance::PackageUtils
  extend ::T::Sig
end

class Puppet::Acceptance::PuppetTypeTestTools::Result
  def self.[](*_); end

  def self.members(); end
end

module Puppet::Acceptance::PuppetTypeTestTools
  extend ::T::Sig
end

module Puppet::Acceptance::RpmUtils
  extend ::T::Sig
end

module Puppet::Acceptance::SMFUtils
  extend ::T::Sig
end

module Puppet::Acceptance::ServiceUtils
  extend ::T::Sig
end

module Puppet::Acceptance::StaticCatalogUtils
  extend ::T::Sig
end

module Puppet::Acceptance::TempFileUtils
  extend ::T::Sig
end

module Puppet::Acceptance::WindowsUtils
  extend ::T::Sig
end

module Puppet::Acceptance
  extend ::T::Sig
end

module Puppet::Agent::Disabler
  extend ::T::Sig
end

module Puppet::Agent::Locker
  extend ::T::Sig
end

module Puppet::ApplicationSupport
  extend ::T::Sig
end

module Puppet::CertificateFactory
  extend ::T::Sig
end

module Puppet::Coercion
  extend ::T::Sig
end

module Puppet::CompilableResourceType
  extend ::T::Sig
end

module Puppet::Configurer::FactHandler
  extend ::T::Sig
end

module Puppet::Confine::Boolean
  extend ::T::Sig
end

module Puppet::Confiner
  extend ::T::Sig
end

class Puppet::DataBinding
  include ::Puppet::Indirector::Envelope
  include ::Puppet::Network::FormatSupport
end

class Puppet::DataBinding
  extend ::Puppet::Indirector::ClassMethods
end

module Puppet::DataSync
  extend ::T::Sig
end

module Puppet::DataTypes
  extend ::T::Sig
end

module Puppet::Environments::EnvironmentCreator
  extend ::T::Sig
end

module Puppet::Environments::EnvironmentLoader
  extend ::T::Sig
end

module Puppet::Environments
  extend ::T::Sig
end

module Puppet::Etc
  extend ::T::Sig
end

module Puppet::ExternalFileError
  extend ::T::Sig
end

class Puppet::FileBucket::File
  include ::Puppet::Indirector::Envelope
  include ::Puppet::Network::FormatSupport
end

class Puppet::FileBucket::File
  extend ::Puppet::Indirector::ClassMethods
end

module Puppet::FileBucket
  extend ::T::Sig
end

module Puppet::FileBucketFile
  extend ::T::Sig
end

class Puppet::FileServing::Content
  include ::Puppet::Indirector::Envelope
  include ::Puppet::Network::FormatSupport
end

class Puppet::FileServing::Content
  extend ::Puppet::Indirector::ClassMethods
end

class Puppet::FileServing::Fileset::FileSetEntry
  def self.[](*_); end

  def self.members(); end
end

class Puppet::FileServing::Metadata
  include ::Puppet::Indirector::Envelope
  include ::Puppet::Network::FormatSupport
end

class Puppet::FileServing::Metadata::MetaStat
  def ftype(*args, &block); end
end

class Puppet::FileServing::Metadata
  extend ::Puppet::Indirector::ClassMethods
end

module Puppet::FileServing::TerminusHelper
  extend ::T::Sig
end

module Puppet::FileServing::TerminusSelector
  extend ::T::Sig
end

class Puppet::FileSystem::Uniquefile
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

module Puppet::FileSystem
  extend ::T::Sig
end

module Puppet::Forge::Errors
  extend ::T::Sig
end

module Puppet::Functions
  extend ::T::Sig
end

module Puppet::Generate::Models::Type
  extend ::T::Sig
end

module Puppet::Generate::Models
  extend ::T::Sig
end

module Puppet::Generate
  extend ::T::Sig
end

module Puppet::GettextConfig
  extend ::T::Sig
end

module Puppet::Graph
  extend ::T::Sig
end

module Puppet::Indirector::ClassMethods
  extend ::T::Sig
end

module Puppet::Indirector::Envelope
  extend ::T::Sig
end

class Puppet::Indirector::Face
  def destroy(arg1, options=T.unsafe(nil)); end

  def find(*rest); end

  def info(options=T.unsafe(nil)); end

  def save(arg1, options=T.unsafe(nil)); end

  def search(arg1, options=T.unsafe(nil)); end
end

class Puppet::Indirector::FileContent::Http
  include ::Puppet::Network::HTTP::Compression::Active
end

class Puppet::Indirector::REST
  include ::Puppet::Network::HTTP::Compression::Active
end

class Puppet::Indirector::Terminus
  def self.catalog(name); end

  def self.certificate(name); end

  def self.certificate_request(name); end

  def self.data_binding(name); end

  def self.facts(name); end

  def self.file_bucket_file(name); end

  def self.file_content(name); end

  def self.file_metadata(name); end

  def self.indirector_testing(name); end

  def self.key(name); end

  def self.node(name); end

  def self.report(name); end

  def self.resource(name); end

  def self.status(name); end
end

module Puppet::Indirector
  extend ::T::Sig
end

class Puppet::IndirectorTesting
  include ::Puppet::Indirector::Envelope
  include ::Puppet::Network::FormatSupport
end

class Puppet::IndirectorTesting
  extend ::Puppet::Indirector::ClassMethods
end

module Puppet::InfoService
  extend ::T::Sig
end

class Puppet::Interface::Action
  def arguments(value=T.unsafe(nil)); end

  def arguments=(value); end

  def returns(value=T.unsafe(nil)); end

  def returns=(value); end
end

class Puppet::Interface::ActionBuilder
  def arguments(value); end

  def author(value); end

  def authors(value); end

  def copyright_owner(value); end

  def copyright_years(value); end

  def description(value); end

  def examples(value); end

  def license(value); end

  def notes(value); end

  def returns(value); end

  def short_description(value); end

  def summary(value); end
end

module Puppet::Interface::ActionManager
  extend ::T::Sig
end

module Puppet::Interface::DocGen
  extend ::T::Sig
end

module Puppet::Interface::FaceCollection
  extend ::T::Sig
end

module Puppet::Interface::FullDocs
  def examples(value=T.unsafe(nil)); end

  def examples=(value); end

  def license(value=T.unsafe(nil)); end

  def license=(value); end

  def notes(value=T.unsafe(nil)); end

  def notes=(value); end

  def short_description=(value); end
end

module Puppet::Interface::FullDocs
  extend ::T::Sig
end

class Puppet::Interface::OptionBuilder
  def !(value); end

  def default(value); end

  def description(value); end

  def summary(value); end
end

module Puppet::Interface::OptionManager
  extend ::T::Sig
end

module Puppet::Interface::TinyDocs
  def _validate_summary(value); end

  def description(value=T.unsafe(nil)); end

  def description=(value); end

  def summary(value=T.unsafe(nil)); end

  def summary=(value); end
end

module Puppet::Interface::TinyDocs
  extend ::T::Sig
end

module Puppet::MetaType::Manager
  extend ::T::Sig
end

module Puppet::MetaType
  extend ::T::Sig
end

class Puppet::Module
  def file(file); end

  def files(); end

  def files?(); end

  def locale(file); end

  def locales(); end

  def locales?(); end

  def manifest(file); end

  def manifests(); end

  def manifests?(); end

  def plugin(file); end

  def pluginfact(file); end

  def pluginfacts(); end

  def pluginfacts?(); end

  def plugins(); end

  def plugins?(); end

  def template(file); end

  def templates(); end

  def templates?(); end
end

module Puppet::ModuleTool::Applications
  extend ::T::Sig
end

module Puppet::ModuleTool::Errors
  extend ::T::Sig
end

module Puppet::ModuleTool::Shared
  extend ::T::Sig
end

module Puppet::ModuleTool::Tar
  extend ::T::Sig
end

module Puppet::ModuleTool
  extend ::T::Sig
end

module Puppet::ModuleTranslations
  extend ::T::Sig
end

module Puppet::Network::Authorization
  extend ::T::Sig
end

class Puppet::Network::DefaultAuthProvider
  def allow(*args); end

  def deny(*args); end
end

module Puppet::Network::FormatHandler
  extend ::T::Sig
end

module Puppet::Network::FormatSupport
  extend ::T::Sig
end

module Puppet::Network::HTTP::API::Master
  extend ::T::Sig
end

module Puppet::Network::HTTP::Compression::Active
  extend ::T::Sig
end

module Puppet::Network::HTTP::Compression::None
  extend ::T::Sig
end

module Puppet::Network::HTTP::Compression
  extend ::T::Sig
end

module Puppet::Network::HTTP::Error
  extend ::T::Sig
end

module Puppet::Network::HTTP::Handler
  extend ::T::Sig
end

module Puppet::Network::HTTP::Issues
  extend ::T::Sig
end

class Puppet::Network::HTTP::Request
  def self.[](*_); end

  def self.members(); end
end

module Puppet::Network::HTTP
  extend ::T::Sig
end

module Puppet::Network::HttpPool
  extend ::T::Sig
end

class Puppet::Network::Rights::Right
  def debug(args); end
end

module Puppet::Network
  extend ::T::Sig
end

class Puppet::Node
  include ::Puppet::Indirector::Envelope
  include ::Puppet::Network::FormatSupport
end

class Puppet::Node::Facts
  include ::Puppet::Indirector::Envelope
  include ::Puppet::Network::FormatSupport
end

module Puppet::Node::Facts::NodeExpirer
  extend ::T::Sig
end

class Puppet::Node::Facts
  extend ::Puppet::Indirector::ClassMethods
end

class Puppet::Node
  extend ::Puppet::Indirector::ClassMethods
end

module Puppet::Pal
  extend ::T::Sig
end

class Puppet::Parameter
  def isnamevar?(); end

  def required?(); end
end

module Puppet::Parser::AbstractCompiler
  extend ::T::Sig
end

class Puppet::Parser::Compiler
  def add_collection(*args, &block); end

  def add_relationship(*args, &block); end

  def classlist(*args, &block); end

  def delete_collection(*args, &block); end

  def findresource(*args, &block); end
end

module Puppet::Parser::Files
  extend ::T::Sig
end

module Puppet::Parser::Functions
  extend ::T::Sig
end

class Puppet::Parser::Scope
  def alert(args); end

  def crit(args); end

  def debug(args); end

  def emerg(args); end

  def err(args); end

  def info(args); end

  def notice(args); end

  def warning(args); end
end

class Puppet::Parser::TemplateWrapper
  def alert(args); end

  def crit(args); end

  def debug(args); end

  def emerg(args); end

  def err(args); end

  def info(args); end

  def notice(args); end

  def warning(args); end
end

class Puppet::Parser::TypeLoader
  def known_resource_types(*args, &block); end
end

module Puppet::Parser
  extend ::T::Sig
end

module Puppet::Plugins::Configuration
  extend ::T::Sig
end

module Puppet::Plugins::SyntaxCheckers
  extend ::T::Sig
end

module Puppet::Plugins
  extend ::T::Sig
end

module Puppet::Pops::Adaptable
  extend ::T::Sig
end

module Puppet::Pops::Adapters
  extend ::T::Sig
end

module Puppet::Pops::Evaluator::Collectors
  extend ::T::Sig
end

module Puppet::Pops::Evaluator::ExternalSyntaxSupport
  extend ::T::Sig
end

module Puppet::Pops::Evaluator::Runtime3ResourceSupport
  extend ::T::Sig
end

module Puppet::Pops::Evaluator::Runtime3Support
  extend ::T::Sig
end

module Puppet::Pops::Evaluator
  extend ::T::Sig
end

module Puppet::Pops::Functions
  extend ::T::Sig
end

module Puppet::Pops::Issues
  extend ::T::Sig
end

module Puppet::Pops::LabelProvider
  extend ::T::Sig
end

module Puppet::Pops::Loader::GemSupport
  extend ::T::Sig
end

module Puppet::Pops::Loader::LoaderPaths
  extend ::T::Sig
end

module Puppet::Pops::Loader::ModuleLoaders
  extend ::T::Sig
end

module Puppet::Pops::Loader::UriHelper
  extend ::T::Sig
end

module Puppet::Pops::Loader
  extend ::T::Sig
end

class Puppet::Pops::Lookup::Context
  def cache(*args, &block); end

  def cache_all(*args, &block); end

  def cache_has_key(*args, &block); end

  def cached_entries(*args, &block); end

  def cached_file_data(*args, &block); end

  def cached_value(*args, &block); end

  def environment_name(*args, &block); end

  def module_name(*args, &block); end
end

module Puppet::Pops::Lookup::DataProvider
  extend ::T::Sig
end

module Puppet::Pops::Lookup::Interpolation
  extend ::T::Sig
end

module Puppet::Pops::Lookup::LocationResolver
  extend ::T::Sig
end

module Puppet::Pops::Lookup::SubLookup
  extend ::T::Sig
end

module Puppet::Pops::Lookup
  extend ::T::Sig
end

module Puppet::Pops::Migration
  extend ::T::Sig
end

module Puppet::Pops::Model
  extend ::T::Sig
end

module Puppet::Pops::PN
  extend ::T::Sig
end

module Puppet::Pops::Parser::EppSupport
  extend ::T::Sig
end

module Puppet::Pops::Parser::HeredocSupport
  extend ::T::Sig
end

module Puppet::Pops::Parser::InterpolationSupport
  extend ::T::Sig
end

module Puppet::Pops::Parser::LexerSupport
  extend ::T::Sig
end

class Puppet::Pops::Parser::Parser
  def _reduce_1(val, _values, result); end

  def _reduce_100(val, _values, result); end

  def _reduce_101(val, _values, result); end

  def _reduce_102(val, _values, result); end

  def _reduce_103(val, _values, result); end

  def _reduce_104(val, _values, result); end

  def _reduce_105(val, _values, result); end

  def _reduce_106(val, _values, result); end

  def _reduce_107(val, _values, result); end

  def _reduce_108(val, _values, result); end

  def _reduce_109(val, _values, result); end

  def _reduce_11(val, _values, result); end

  def _reduce_110(val, _values, result); end

  def _reduce_111(val, _values, result); end

  def _reduce_112(val, _values, result); end

  def _reduce_113(val, _values, result); end

  def _reduce_114(val, _values, result); end

  def _reduce_115(val, _values, result); end

  def _reduce_116(val, _values, result); end

  def _reduce_117(val, _values, result); end

  def _reduce_118(val, _values, result); end

  def _reduce_12(val, _values, result); end

  def _reduce_120(val, _values, result); end

  def _reduce_121(val, _values, result); end

  def _reduce_122(val, _values, result); end

  def _reduce_123(val, _values, result); end

  def _reduce_124(val, _values, result); end

  def _reduce_126(val, _values, result); end

  def _reduce_127(val, _values, result); end

  def _reduce_128(val, _values, result); end

  def _reduce_129(val, _values, result); end

  def _reduce_13(val, _values, result); end

  def _reduce_130(val, _values, result); end

  def _reduce_131(val, _values, result); end

  def _reduce_135(val, _values, result); end

  def _reduce_136(val, _values, result); end

  def _reduce_137(val, _values, result); end

  def _reduce_138(val, _values, result); end

  def _reduce_139(val, _values, result); end

  def _reduce_140(val, _values, result); end

  def _reduce_141(val, _values, result); end

  def _reduce_142(val, _values, result); end

  def _reduce_145(val, _values, result); end

  def _reduce_146(val, _values, result); end

  def _reduce_147(val, _values, result); end

  def _reduce_15(val, _values, result); end

  def _reduce_150(val, _values, result); end

  def _reduce_151(val, _values, result); end

  def _reduce_152(val, _values, result); end

  def _reduce_153(val, _values, result); end

  def _reduce_154(val, _values, result); end

  def _reduce_155(val, _values, result); end

  def _reduce_156(val, _values, result); end

  def _reduce_159(val, _values, result); end

  def _reduce_16(val, _values, result); end

  def _reduce_160(val, _values, result); end

  def _reduce_161(val, _values, result); end

  def _reduce_162(val, _values, result); end

  def _reduce_163(val, _values, result); end

  def _reduce_167(val, _values, result); end

  def _reduce_17(val, _values, result); end

  def _reduce_170(val, _values, result); end

  def _reduce_171(val, _values, result); end

  def _reduce_172(val, _values, result); end

  def _reduce_173(val, _values, result); end

  def _reduce_174(val, _values, result); end

  def _reduce_175(val, _values, result); end

  def _reduce_178(val, _values, result); end

  def _reduce_180(val, _values, result); end

  def _reduce_181(val, _values, result); end

  def _reduce_185(val, _values, result); end

  def _reduce_186(val, _values, result); end

  def _reduce_187(val, _values, result); end

  def _reduce_188(val, _values, result); end

  def _reduce_19(val, _values, result); end

  def _reduce_193(val, _values, result); end

  def _reduce_194(val, _values, result); end

  def _reduce_195(val, _values, result); end

  def _reduce_196(val, _values, result); end

  def _reduce_197(val, _values, result); end

  def _reduce_198(val, _values, result); end

  def _reduce_199(val, _values, result); end

  def _reduce_2(val, _values, result); end

  def _reduce_20(val, _values, result); end

  def _reduce_200(val, _values, result); end

  def _reduce_201(val, _values, result); end

  def _reduce_206(val, _values, result); end

  def _reduce_207(val, _values, result); end

  def _reduce_208(val, _values, result); end

  def _reduce_209(val, _values, result); end

  def _reduce_21(val, _values, result); end

  def _reduce_210(val, _values, result); end

  def _reduce_211(val, _values, result); end

  def _reduce_212(val, _values, result); end

  def _reduce_213(val, _values, result); end

  def _reduce_214(val, _values, result); end

  def _reduce_215(val, _values, result); end

  def _reduce_216(val, _values, result); end

  def _reduce_217(val, _values, result); end

  def _reduce_218(val, _values, result); end

  def _reduce_219(val, _values, result); end

  def _reduce_22(val, _values, result); end

  def _reduce_220(val, _values, result); end

  def _reduce_221(val, _values, result); end

  def _reduce_222(val, _values, result); end

  def _reduce_223(val, _values, result); end

  def _reduce_224(val, _values, result); end

  def _reduce_225(val, _values, result); end

  def _reduce_226(val, _values, result); end

  def _reduce_227(val, _values, result); end

  def _reduce_228(val, _values, result); end

  def _reduce_229(val, _values, result); end

  def _reduce_230(val, _values, result); end

  def _reduce_231(val, _values, result); end

  def _reduce_232(val, _values, result); end

  def _reduce_234(val, _values, result); end

  def _reduce_236(val, _values, result); end

  def _reduce_237(val, _values, result); end

  def _reduce_238(val, _values, result); end

  def _reduce_24(val, _values, result); end

  def _reduce_248(val, _values, result); end

  def _reduce_249(val, _values, result); end

  def _reduce_25(val, _values, result); end

  def _reduce_250(val, _values, result); end

  def _reduce_251(val, _values, result); end

  def _reduce_252(val, _values, result); end

  def _reduce_253(val, _values, result); end

  def _reduce_254(val, _values, result); end

  def _reduce_255(val, _values, result); end

  def _reduce_256(val, _values, result); end

  def _reduce_257(val, _values, result); end

  def _reduce_258(val, _values, result); end

  def _reduce_259(val, _values, result); end

  def _reduce_26(val, _values, result); end

  def _reduce_260(val, _values, result); end

  def _reduce_261(val, _values, result); end

  def _reduce_264(val, _values, result); end

  def _reduce_265(val, _values, result); end

  def _reduce_266(val, _values, result); end

  def _reduce_267(val, _values, result); end

  def _reduce_268(val, _values, result); end

  def _reduce_269(val, _values, result); end

  def _reduce_27(val, _values, result); end

  def _reduce_272(val, _values, result); end

  def _reduce_273(val, _values, result); end

  def _reduce_275(val, _values, result); end

  def _reduce_28(val, _values, result); end

  def _reduce_29(val, _values, result); end

  def _reduce_3(val, _values, result); end

  def _reduce_30(val, _values, result); end

  def _reduce_300(val, _values, result); end

  def _reduce_31(val, _values, result); end

  def _reduce_32(val, _values, result); end

  def _reduce_33(val, _values, result); end

  def _reduce_34(val, _values, result); end

  def _reduce_39(val, _values, result); end

  def _reduce_4(val, _values, result); end

  def _reduce_40(val, _values, result); end

  def _reduce_41(val, _values, result); end

  def _reduce_42(val, _values, result); end

  def _reduce_43(val, _values, result); end

  def _reduce_44(val, _values, result); end

  def _reduce_45(val, _values, result); end

  def _reduce_46(val, _values, result); end

  def _reduce_47(val, _values, result); end

  def _reduce_48(val, _values, result); end

  def _reduce_49(val, _values, result); end

  def _reduce_5(val, _values, result); end

  def _reduce_50(val, _values, result); end

  def _reduce_51(val, _values, result); end

  def _reduce_52(val, _values, result); end

  def _reduce_53(val, _values, result); end

  def _reduce_54(val, _values, result); end

  def _reduce_55(val, _values, result); end

  def _reduce_56(val, _values, result); end

  def _reduce_57(val, _values, result); end

  def _reduce_58(val, _values, result); end

  def _reduce_59(val, _values, result); end

  def _reduce_6(val, _values, result); end

  def _reduce_60(val, _values, result); end

  def _reduce_61(val, _values, result); end

  def _reduce_62(val, _values, result); end

  def _reduce_63(val, _values, result); end

  def _reduce_64(val, _values, result); end

  def _reduce_65(val, _values, result); end

  def _reduce_67(val, _values, result); end

  def _reduce_68(val, _values, result); end

  def _reduce_69(val, _values, result); end

  def _reduce_7(val, _values, result); end

  def _reduce_8(val, _values, result); end

  def _reduce_9(val, _values, result); end

  def _reduce_93(val, _values, result); end

  def _reduce_94(val, _values, result); end

  def _reduce_95(val, _values, result); end

  def _reduce_96(val, _values, result); end

  def _reduce_97(val, _values, result); end

  def _reduce_98(val, _values, result); end

  def _reduce_99(val, _values, result); end
end

module Puppet::Pops::Parser::SlurpSupport
  extend ::T::Sig
end

module Puppet::Pops::Parser
  extend ::T::Sig
end

module Puppet::Pops::Patterns
  extend ::T::Sig
end

module Puppet::Pops::Pcore
  extend ::T::Sig
end

module Puppet::Pops::PuppetStack
  extend ::T::Sig
end

module Puppet::Pops::Resource
  extend ::T::Sig
end

module Puppet::Pops::Serialization::Extension::NotTabulated
  extend ::T::Sig
end

module Puppet::Pops::Serialization::Extension::SequenceStart
  extend ::T::Sig
end

module Puppet::Pops::Serialization::Extension
  extend ::T::Sig
end

module Puppet::Pops::Serialization::InstanceReader
  extend ::T::Sig
end

module Puppet::Pops::Serialization::InstanceWriter
  extend ::T::Sig
end

module Puppet::Pops::Serialization::JSON
  extend ::T::Sig
end

module Puppet::Pops::Serialization::JsonPath
  extend ::T::Sig
end

module Puppet::Pops::Serialization
  extend ::T::Sig
end

module Puppet::Pops::Time
  extend ::T::Sig
end

module Puppet::Pops::Types::Annotatable
  extend ::T::Sig
end

module Puppet::Pops::Types::InvocableMember
  extend ::T::Sig
end

module Puppet::Pops::Types::Iterable
  extend ::T::Sig
end

module Puppet::Pops::Types::IteratorProducer
  extend ::T::Sig
end

module Puppet::Pops::Types::PuppetObject
  extend ::T::Sig
end

module Puppet::Pops::Types::TypeAcceptor
  extend ::T::Sig
end

module Puppet::Pops::Types::TypeAsserter
  extend ::T::Sig
end

module Puppet::Pops::Types::TypeFactory
  extend ::T::Sig
end

module Puppet::Pops::Types::TypeWithMembers
  extend ::T::Sig
end

module Puppet::Pops::Types
  extend ::T::Sig
end

module Puppet::Pops::Utils
  extend ::T::Sig
end

class Puppet::Pops::Validation::Checker4_0
  include ::Puppet::Pops::Evaluator::ExternalSyntaxSupport
end

module Puppet::Pops::Validation
  extend ::T::Sig
end

module Puppet::Pops::Visitable
  extend ::T::Sig
end

module Puppet::Pops
  extend ::T::Sig
end

class Puppet::Property::Ensure
  def default(); end
end

class Puppet::Provider
  def alert(args); end

  def crit(args); end

  def debug(args); end

  def emerg(args); end

  def err(args); end

  def info(args); end

  def notice(args); end

  def warning(args); end
end

class Puppet::Provider::NameService::DirectoryService
  def dscl(*args); end

  def dseditgroup(*args); end

  def sw_vers(*args); end
end

class Puppet::Provider::NameService::DirectoryService
  def self.dscl(*args); end

  def self.dseditgroup(*args); end

  def self.sw_vers(*args); end
end

class Puppet::Provider
  def self.dochook_commands(); end

  def self.dochook_defaults(); end

  def self.dochook_features(); end
end

module Puppet::Reports::Http
  def process(); end

  def report_name(); end
end

module Puppet::Reports::Http
  extend ::Puppet::Util::Docs
  extend ::T::Sig
end

module Puppet::Reports::Log
  def process(); end

  def report_name(); end
end

module Puppet::Reports::Log
  extend ::Puppet::Util::Docs
  extend ::T::Sig
end

module Puppet::Reports::Store
  def process(); end

  def report_name(); end
end

module Puppet::Reports::Store
  extend ::Puppet::Util::Docs
  extend ::T::Sig
  def self.destroy(host); end

  def self.validate_host(host); end
end

class Puppet::Reports
  def self.report(name); end
end

class Puppet::Resource
  include ::Puppet::Indirector::Envelope
  include ::Puppet::Network::FormatSupport
  def <<(*args); end

  def delete(*args); end

  def empty?(*args); end

  def exported?(); end

  def has_key?(*args); end

  def keys(*args); end

  def length(*args); end

  def strict?(); end

  def virtual?(); end
end

module Puppet::Resource::CapabilityFinder
  extend ::T::Sig
end

class Puppet::Resource::Catalog
  include ::Puppet::Indirector::Envelope
  include ::Puppet::Network::FormatSupport
end

class Puppet::Resource::Catalog
  extend ::Puppet::Indirector::ClassMethods
end

class Puppet::Resource::Status
  def changed(); end

  def changed=(changed); end

  def changed?(); end

  def corrective_change=(corrective_change); end

  def corrective_change?(); end

  def failed(); end

  def failed=(failed); end

  def failed?(); end

  def failed_to_restart(); end

  def failed_to_restart=(failed_to_restart); end

  def failed_to_restart?(); end

  def out_of_sync(); end

  def out_of_sync=(out_of_sync); end

  def out_of_sync?(); end

  def restarted(); end

  def restarted=(restarted); end

  def restarted?(); end

  def scheduled(); end

  def scheduled=(scheduled); end

  def scheduled?(); end

  def skipped(); end

  def skipped=(skipped); end

  def skipped?(); end
end

class Puppet::Resource::Type
  include ::Puppet::Util::Warnings
  include ::Puppet::Util::Errors
  def application?(); end

  def capability_mapping?(); end

  def definition?(); end

  def hostclass?(); end

  def node?(); end

  def site?(); end
end

class Puppet::Resource::TypeCollection
  def applications(); end

  def capability_mappings(); end

  def definitions(); end

  def hostclasses(); end

  def nodes(); end
end

module Puppet::Resource::Validator
  extend ::T::Sig
end

class Puppet::Resource
  extend ::Puppet::Indirector::ClassMethods
end

Puppet::ResourceType = Puppet::Resource::Type

module Puppet::Rest::Routes
  extend ::Puppet::Network::HTTP::Compression::Active
  extend ::T::Sig
end

module Puppet::Rest
  extend ::T::Sig
end

module Puppet::SSL
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class Puppet::SSL::Certificate
  include ::Puppet::Indirector::Envelope
  include ::Puppet::Network::FormatSupport
end

class Puppet::SSL::Certificate
  extend ::Puppet::Indirector::ClassMethods
end

class Puppet::SSL::CertificateRequest
  include ::Puppet::Indirector::Envelope
  include ::Puppet::Network::FormatSupport
end

class Puppet::SSL::CertificateRequest
  extend ::Puppet::Indirector::ClassMethods
end

class Puppet::SSL::Key
  include ::Puppet::Indirector::Envelope
  include ::Puppet::Network::FormatSupport
end

class Puppet::SSL::Key
  extend ::Puppet::Indirector::ClassMethods
end

module Puppet::SSL::Oids
  extend ::T::Sig
end

class Puppet::SSL::SSLContext
  def self.[](*_); end

  def self.members(); end
end

module Puppet::SSL
  extend ::T::Sig
end

module Puppet::Scheduler
  extend ::T::Sig
end

class Puppet::Settings
  def each(*args, &block); end

  def each_key(*args, &block); end

  def each_pair(*args, &block); end
end

class Puppet::Settings::ConfigFile::Conf
  def self.[](*_); end

  def self.members(); end
end

class Puppet::Settings::ConfigFile::Meta
  def self.[](*_); end

  def self.members(); end
end

class Puppet::Settings::ConfigFile::Section
  def self.[](*_); end

  def self.members(); end
end

class Puppet::Settings::ConfigFile::Setting
  def self.[](*_); end

  def self.members(); end
end

class Puppet::Settings::IniFile::Line
  def self.[](*_); end

  def self.members(); end
end

module Puppet::Settings::IniFile::LineNumber
  extend ::T::Sig
end

class Puppet::Settings::IniFile::SectionLine
  def self.[](*_); end

  def self.members(); end
end

class Puppet::Settings::IniFile::SettingLine
  def self.[](*_); end

  def self.members(); end
end

class Puppet::Settings::Values
  def include?(*args, &block); end

  def lookup(*args, &block); end
end

class Puppet::Status
  include ::Puppet::Indirector::Envelope
  include ::Puppet::Network::FormatSupport
end

class Puppet::Status
  extend ::Puppet::Indirector::ClassMethods
end

module Puppet::SyntaxCheckers
  extend ::T::Sig
end

module Puppet::Test
  extend ::T::Sig
end

class Puppet::Transaction::Event
  def audited(); end

  def audited=(audited); end

  def corrective_change(); end

  def corrective_change=(corrective_change); end

  def desired_value(); end

  def desired_value=(desired_value); end

  def file(); end

  def file=(file); end

  def historical_value(); end

  def historical_value=(historical_value); end

  def invalidate_refreshes(); end

  def invalidate_refreshes=(invalidate_refreshes); end

  def line(); end

  def line=(line); end

  def message(); end

  def message=(message); end

  def name(); end

  def name=(name); end

  def previous_value(); end

  def previous_value=(previous_value); end

  def property(); end

  def redacted(); end

  def redacted=(redacted); end

  def resource(); end

  def source_description(); end

  def source_description=(source_description); end

  def status(); end
end

class Puppet::Transaction::Report
  include ::Puppet::Indirector::Envelope
  include ::Puppet::Network::FormatSupport
end

class Puppet::Transaction::Report
  extend ::Puppet::Indirector::ClassMethods
end

class Puppet::Transaction::ResourceHarness
  def relationship_graph(*args, &block); end
end

class Puppet::Transaction::ResourceHarness::ResourceApplicationContext
  def self.[](*_); end

  def self.members(); end
end

class Puppet::Type::A2mod
end

class Puppet::Type::A2mod::Ensure
  def set_absent(); end

  def set_present(); end
end

class Puppet::Type::A2mod::Ensure
end

class Puppet::Type::A2mod::ParameterName
end

class Puppet::Type::A2mod::ParameterName
end

class Puppet::Type::A2mod
end

class Puppet::Type::Component
  def [](param); end

  def []=(param, value); end

  def initialize(*args); end

  def refresh(); end

  def title=(str); end
end

class Puppet::Type::Component::ParameterName
end

class Puppet::Type::Component::ParameterName
end

class Puppet::Type::Component
end

class Puppet::Type::Exec
  include ::Puppet::Util::Execution
  def check_all_attributes(refreshing=T.unsafe(nil)); end

  def current_username(); end

  def output(); end

  def refresh(); end

  def validate(); end
end

module Puppet::Type::Exec::FeatureModule
  def feature?(name); end

  def features(); end

  def has_feature(*names); end

  def has_features(*names); end

  def satisfies?(*needed); end
end

module Puppet::Type::Exec::FeatureModule
  extend ::T::Sig
end

class Puppet::Type::Exec::ParameterCommand
  def unsafe_validate(command); end
end

class Puppet::Type::Exec::ParameterCommand
end

class Puppet::Type::Exec::ParameterCreates
  def check(value); end
end

class Puppet::Type::Exec::ParameterCreates
end

class Puppet::Type::Exec::ParameterCwd
end

class Puppet::Type::Exec::ParameterCwd
end

class Puppet::Type::Exec::ParameterEnvironment
  def unsafe_validate(values); end
end

class Puppet::Type::Exec::ParameterEnvironment
end

class Puppet::Type::Exec::ParameterGroup
end

class Puppet::Type::Exec::ParameterGroup
end

class Puppet::Type::Exec::ParameterLogoutput
  def default(); end
end

class Puppet::Type::Exec::ParameterLogoutput
end

class Puppet::Type::Exec::ParameterOnlyif
  def check(value); end

  def unsafe_validate(cmds); end
end

class Puppet::Type::Exec::ParameterOnlyif
end

class Puppet::Type::Exec::ParameterPath
  def value=(*values); end
end

class Puppet::Type::Exec::ParameterPath
end

class Puppet::Type::Exec::ParameterProvider
  def default(); end

  def unsafe_munge(provider); end

  def unsafe_validate(provider_class); end
end

class Puppet::Type::Exec::ParameterProvider
  def self.parenttype(); end

  def self.parenttype=(parenttype); end
end

class Puppet::Type::Exec::ParameterRefresh
  def unsafe_validate(command); end
end

class Puppet::Type::Exec::ParameterRefresh
end

class Puppet::Type::Exec::ParameterRefreshonly
  def check(value); end
end

class Puppet::Type::Exec::ParameterRefreshonly
end

class Puppet::Type::Exec::ParameterTimeout
  def default(); end
end

class Puppet::Type::Exec::ParameterTimeout
end

class Puppet::Type::Exec::ParameterTries
  def default(); end
end

class Puppet::Type::Exec::ParameterTries
end

class Puppet::Type::Exec::ParameterTry_sleep
  def default(); end
end

class Puppet::Type::Exec::ParameterTry_sleep
end

class Puppet::Type::Exec::ParameterUmask
end

class Puppet::Type::Exec::ParameterUmask
end

class Puppet::Type::Exec::ParameterUnless
  def check(value); end

  def unsafe_validate(cmds); end
end

class Puppet::Type::Exec::ParameterUnless
end

class Puppet::Type::Exec::ParameterUser
  def unsafe_validate(user); end
end

class Puppet::Type::Exec::ParameterUser
end

class Puppet::Type::Exec::ProviderPosix
  include ::Puppet::Type::Exec::FeatureModule
  def checkexe(command); end
end

class Puppet::Type::Exec::ProviderPosix
  extend ::Puppet::Type::Exec::FeatureModule
end

class Puppet::Type::Exec::ProviderShell
end

class Puppet::Type::Exec::ProviderShell
end

class Puppet::Type::Exec::ProviderWindows
  include ::Puppet::Type::Exec::FeatureModule
  def checkexe(command); end
end

class Puppet::Type::Exec::ProviderWindows
  extend ::Puppet::Type::Exec::FeatureModule
end

class Puppet::Type::Exec::Returns
  include ::Puppet::Util::Execution
  def change_to_s(currentvalue, newvalue); end

  def default(); end

  def output(); end
end

class Puppet::Type::Exec::Returns
end

class Puppet::Type::Exec
  def self.checks(); end

  def self.newcheck(name, options=T.unsafe(nil), &block); end
end

class Puppet::Type::File
  include ::Puppet::Util::Checksums
  include ::Puppet::Util::Backups
  include ::Puppet::Util::SymbolicFileMode
  def asuser(); end

  def bucket(); end

  def default_bucket(); end

  def eval_generate(); end

  def exist?(); end

  def force?(); end

  def initialize(hash); end

  def mark_children_for_purging(children); end

  def newchild(path); end

  def perform_recursion(path); end

  def purge?(); end

  def recurse(); end

  def recurse?(); end

  def recurse_link(children); end

  def recurse_local(); end

  def recurse_remote(children); end

  def recurse_remote_metadata(); end

  def remove_existing(should); end

  def remove_less_specific_files(files); end

  def replace?(); end

  def setchecksum(sum=T.unsafe(nil)); end

  def should_be_file?(); end

  def show_diff?(); end

  def stat(); end

  def validate(); end

  def write(property=T.unsafe(nil)); end
end

class Puppet::Type::File::Checksum_value
  include ::Puppet::DataSync
  include ::Puppet::Util::Checksums
  include ::Puppet::Util::Diff
  include ::Puppet::Util::Execution
end

class Puppet::Type::File::Checksum_value
end

class Puppet::Type::File::Content
  include ::Puppet::DataSync
  include ::Puppet::Util::Checksums
  include ::Puppet::Util::Diff
  include ::Puppet::Util::Execution
  def actual_content(); end

  def change_to_s(currentvalue, newvalue); end

  def content(); end

  def length(); end

  def should=(value); end

  def write(file); end
end

class Puppet::Type::File::Content
end

class Puppet::Type::File::Ctime
  def unsafe_validate(val); end
end

class Puppet::Type::File::Ctime
end

class Puppet::Type::File::Ensure
  include ::Puppet::Util::SymbolicFileMode
  def check(); end

  def insync?(currentvalue); end

  def set_absent(); end

  def set_directory(); end

  def set_file(); end

  def set_link(); end

  def set_present(); end
end

class Puppet::Type::File::Ensure
end

module Puppet::Type::File::FeatureModule
  def feature?(name); end

  def features(); end

  def has_feature(*names); end

  def has_features(*names); end

  def manages_symlinks?(); end

  def satisfies?(*needed); end
end

module Puppet::Type::File::FeatureModule
  extend ::T::Sig
end

class Puppet::Type::File::Group
  def insync?(current); end

  def is_to_s(currentvalue); end

  def should_to_s(newvalue); end

  def unsafe_validate(group); end
end

class Puppet::Type::File::Group
end

class Puppet::Type::File::Mode
  include ::Puppet::Util::SymbolicFileMode
  def change_to_s(old_value, desired); end

  def desired_mode_from_current(desired, current); end

  def dirmask(value); end

  def insync?(currentvalue); end

  def is_to_s(currentvalue); end

  def should_to_s(should_value); end
end

class Puppet::Type::File::Mode
end

class Puppet::Type::File::Mtime
  def unsafe_validate(val); end
end

class Puppet::Type::File::Mtime
end

class Puppet::Type::File::Owner
  include ::Puppet::Util::Warnings
  def insync?(current); end

  def is_to_s(currentvalue); end

  def should_to_s(newvalue); end
end

class Puppet::Type::File::Owner
end

class Puppet::Type::File::ParameterBackup
  def default(); end
end

class Puppet::Type::File::ParameterBackup
end

class Puppet::Type::File::ParameterChecksum
  include ::Puppet::Util::Checksums
  def default(); end

  def sum(content); end

  def sum_file(path); end

  def sum_stream(&block); end
end

class Puppet::Type::File::ParameterChecksum
end

class Puppet::Type::File::ParameterForce
  def default(); end
end

class Puppet::Type::File::ParameterForce
end

class Puppet::Type::File::ParameterIgnore
end

class Puppet::Type::File::ParameterIgnore
end

class Puppet::Type::File::ParameterLinks
  def default(); end
end

class Puppet::Type::File::ParameterLinks
end

class Puppet::Type::File::ParameterPath
end

class Puppet::Type::File::ParameterPath
end

class Puppet::Type::File::ParameterProvider
  def default(); end

  def unsafe_munge(provider); end

  def unsafe_validate(provider_class); end
end

class Puppet::Type::File::ParameterProvider
  def self.parenttype(); end

  def self.parenttype=(parenttype); end
end

class Puppet::Type::File::ParameterPurge
  def default(); end
end

class Puppet::Type::File::ParameterPurge
end

class Puppet::Type::File::ParameterRecurse
  def unsafe_validate(arg); end
end

class Puppet::Type::File::ParameterRecurse
end

class Puppet::Type::File::ParameterRecurselimit
end

class Puppet::Type::File::ParameterRecurselimit
end

class Puppet::Type::File::ParameterReplace
  def default(); end
end

class Puppet::Type::File::ParameterReplace
end

class Puppet::Type::File::ParameterSelinux_ignore_defaults
  def default(); end
end

class Puppet::Type::File::ParameterSelinux_ignore_defaults
end

class Puppet::Type::File::ParameterShow_diff
  def default(); end
end

class Puppet::Type::File::ParameterShow_diff
end

class Puppet::Type::File::ParameterSource
  include ::Puppet::Network::HTTP::Compression::Active
  def change_to_s(currentvalue, newvalue); end

  def checksum(); end

  def content(); end

  def copy_source_values(); end

  def full_path(); end

  def local(); end

  def local=(local); end

  def local?(); end

  def metadata(); end

  def metadata=(metadata); end

  def port(); end

  def server(); end

  def server?(); end

  def source(); end

  def source=(source); end

  def unsafe_munge(sources); end

  def unsafe_validate(sources); end

  def uri(); end

  def write(file); end
end

class Puppet::Type::File::ParameterSource
  def self.normalize(source); end
end

class Puppet::Type::File::ParameterSource_permissions
  def default(); end
end

class Puppet::Type::File::ParameterSource_permissions
end

class Puppet::Type::File::ParameterSourceselect
  def default(); end
end

class Puppet::Type::File::ParameterSourceselect
end

class Puppet::Type::File::ParameterStaging_location
end

class Puppet::Type::File::ParameterStaging_location
end

class Puppet::Type::File::ParameterValidate_cmd
end

class Puppet::Type::File::ParameterValidate_cmd
end

class Puppet::Type::File::ParameterValidate_replacement
  def default(); end
end

class Puppet::Type::File::ParameterValidate_replacement
end

class Puppet::Type::File::ProviderPosix
  include ::Puppet::Type::File::FeatureModule
  include ::Puppet::Util::POSIX
  def gid2name(id); end

  def group(); end

  def group=(should); end

  def mode(); end

  def mode=(value); end

  def name2gid(value); end

  def name2uid(value); end

  def owner(); end

  def owner=(should); end

  def uid2name(id); end
end

class Puppet::Type::File::ProviderPosix
  extend ::Puppet::Type::File::FeatureModule
end

class Puppet::Type::File::ProviderWindows
  include ::Puppet::Type::File::FeatureModule
  def gid2name(id); end

  def group(); end

  def group=(should); end

  def id2name(id); end

  def mode(); end

  def mode=(value); end

  def munge_windows_system_group(current, should); end

  def name2gid(value); end

  def name2id(value); end

  def name2uid(value); end

  def owner(); end

  def owner=(should); end

  def uid2name(id); end

  def validate(); end
end

class Puppet::Type::File::ProviderWindows
  extend ::Puppet::Type::File::FeatureModule
end

class Puppet::Type::File::Selrange
  def default(); end
end

class Puppet::Type::File::Selrange
end

class Puppet::Type::File::Selrole
  def default(); end
end

class Puppet::Type::File::Selrole
end

class Puppet::Type::File::Seltype
  def default(); end
end

class Puppet::Type::File::Seltype
end

class Puppet::Type::File::Seluser
  def default(); end
end

class Puppet::Type::File::Seluser
end

class Puppet::Type::File::Target
  def insync?(currentvalue); end

  def mklink(); end

  def set_notlink(); end
end

class Puppet::Type::File::Target
end

class Puppet::Type::File::Type
  def unsafe_validate(val); end
end

class Puppet::Type::File::Type
end

class Puppet::Type::File
  def self.[](path); end

  def self.remove_less_specific_files(files, parent_path, existing_files, &block); end
end

class Puppet::Type::Filebucket
  def bucket(); end
end

class Puppet::Type::Filebucket::ParameterName
end

class Puppet::Type::Filebucket::ParameterName
end

class Puppet::Type::Filebucket::ParameterPath
  def default(); end
end

class Puppet::Type::Filebucket::ParameterPath
end

class Puppet::Type::Filebucket::ParameterPort
end

class Puppet::Type::Filebucket::ParameterPort
end

class Puppet::Type::Filebucket::ParameterServer
end

class Puppet::Type::Filebucket::ParameterServer
end

class Puppet::Type::Filebucket
  def self.mkdefaultbucket(); end
end

class Puppet::Type::Group
  def allowdupe?(); end

  def auth_membership?(); end

  def exists?(); end

  def forcelocal?(); end

  def system?(); end
end

class Puppet::Type::Group::Attributes
end

class Puppet::Type::Group::Attributes
end

class Puppet::Type::Group::Ensure
  def set_absent(); end

  def set_present(); end
end

class Puppet::Type::Group::Ensure
end

module Puppet::Type::Group::FeatureModule
  def feature?(name); end

  def features(); end

  def has_feature(*names); end

  def has_features(*names); end

  def libuser?(); end

  def manages_aix_lam?(); end

  def manages_members?(); end

  def satisfies?(*needed); end

  def system_groups?(); end
end

module Puppet::Type::Group::FeatureModule
  extend ::T::Sig
end

class Puppet::Type::Group::Gid
  def unsafe_munge(gid); end
end

class Puppet::Type::Group::Gid
end

class Puppet::Type::Group::Members
  def actual_should(currentvalue, newvalue); end

  def change_to_s(currentvalue, newvalue); end

  def insync?(current); end

  def is_to_s(currentvalue); end

  def munge_members_value(value); end

  def should_to_s(newvalue); end
end

class Puppet::Type::Group::Members
end

class Puppet::Type::Group::ParameterAllowdupe
  def default(); end
end

class Puppet::Type::Group::ParameterAllowdupe
end

class Puppet::Type::Group::ParameterAttribute_membership
  def default(); end
end

class Puppet::Type::Group::ParameterAttribute_membership
end

class Puppet::Type::Group::ParameterAuth_membership
  def default(); end
end

class Puppet::Type::Group::ParameterAuth_membership
end

class Puppet::Type::Group::ParameterForcelocal
  def default(); end
end

class Puppet::Type::Group::ParameterForcelocal
end

class Puppet::Type::Group::ParameterIa_load_module
end

class Puppet::Type::Group::ParameterIa_load_module
end

class Puppet::Type::Group::ParameterName
end

class Puppet::Type::Group::ParameterName
end

class Puppet::Type::Group::ParameterProvider
  def default(); end

  def unsafe_munge(provider); end

  def unsafe_validate(provider_class); end
end

class Puppet::Type::Group::ParameterProvider
  def self.parenttype(); end

  def self.parenttype=(parenttype); end
end

class Puppet::Type::Group::ParameterSystem
  def default(); end
end

class Puppet::Type::Group::ParameterSystem
end

class Puppet::Type::Group::ProviderAix
  include ::Puppet::Type::Group::FeatureModule
  def add(*args); end

  def attributes(); end

  def gid(); end

  def gid=(value); end

  def list(*args); end

  def members(); end

  def members=(value); end

  def members_insync?(current, should); end

  def modify(*args); end
end

class Puppet::Type::Group::ProviderAix
  extend ::Puppet::Type::Group::FeatureModule
  def self.add(*args); end

  def self.delete(*args); end

  def self.find(group, ia_module_args=T.unsafe(nil)); end

  def self.list(*args); end

  def self.members_to_users(provider, members); end

  def self.modify(*args); end

  def self.users_to_members(users); end
end

class Puppet::Type::Group::ProviderDirectoryservice
  include ::Puppet::Type::Group::FeatureModule
  def attributes(); end

  def attributes=(*vals); end

  def gid(); end

  def gid=(*vals); end

  def members(); end

  def members=(*vals); end

  def members_insync?(current, should); end
end

class Puppet::Type::Group::ProviderDirectoryservice
  extend ::Puppet::Type::Group::FeatureModule
end

class Puppet::Type::Group::ProviderGroupadd
  include ::Puppet::Type::Group::FeatureModule
  def add(*args); end

  def addcmd(); end

  def attributes(); end

  def attributes=(*vals); end

  def check_allow_dup(); end

  def findgroup(key, value); end

  def gid(); end

  def gid=(*vals); end

  def localadd(*args); end

  def localdelete(*args); end

  def localgid(); end

  def localmodify(*args); end

  def members(); end

  def members=(*vals); end

  def modify(*args); end

  def modifycmd(param, value); end
end

class Puppet::Type::Group::ProviderGroupadd
  extend ::Puppet::Type::Group::FeatureModule
  def self.add(*args); end

  def self.delete(*args); end

  def self.localadd(*args); end

  def self.localdelete(*args); end

  def self.localmodify(*args); end

  def self.modify(*args); end
end

class Puppet::Type::Group::ProviderLdap
  include ::Puppet::Type::Group::FeatureModule
  def allowdupe(); end

  def allowdupe=(val); end

  def attribute_membership(); end

  def attribute_membership=(val); end

  def attributes(); end

  def attributes=(val); end

  def auth_membership(); end

  def auth_membership=(val); end

  def ensure(); end

  def ensure=(val); end

  def forcelocal(); end

  def forcelocal=(val); end

  def gid(); end

  def gid=(val); end

  def ia_load_module(); end

  def ia_load_module=(val); end

  def members(); end

  def members=(val); end

  def provider(); end

  def provider=(val); end

  def system(); end

  def system=(val); end
end

class Puppet::Type::Group::ProviderLdap
  extend ::Puppet::Type::Group::FeatureModule
  def self.name2id(group); end
end

class Puppet::Type::Group::ProviderPw
  include ::Puppet::Type::Group::FeatureModule
  def addcmd(); end

  def attributes(); end

  def attributes=(*vals); end

  def gid(); end

  def gid=(*vals); end

  def members(); end

  def members=(*vals); end

  def pw(*args); end
end

class Puppet::Type::Group::ProviderPw
  extend ::Puppet::Type::Group::FeatureModule
  def self.pw(*args); end
end

class Puppet::Type::Group::ProviderWindows_adsi
  include ::Puppet::Type::Group::FeatureModule
  def create(); end

  def delete(); end

  def exists?(); end

  def flush(); end

  def gid(); end

  def gid=(value); end

  def group(); end

  def initialize(value=T.unsafe(nil)); end

  def member_valid?(user_name); end

  def members(); end

  def members=(members); end

  def members_insync?(current, should); end

  def members_to_s(users); end
end

class Puppet::Type::Group::ProviderWindows_adsi
  extend ::Puppet::Type::Group::FeatureModule
end

class Puppet::Type::Group
end

class Puppet::Type::MetaParamAlias
  def unsafe_munge(aliases); end
end

class Puppet::Type::MetaParamAlias
end

class Puppet::Type::MetaParamAudit
  def all_properties(); end

  def properties_to_audit(list); end

  def unsafe_munge(args); end

  def unsafe_validate(list); end
end

class Puppet::Type::MetaParamAudit
end

class Puppet::Type::MetaParamBefore
end

class Puppet::Type::MetaParamBefore
end

class Puppet::Type::MetaParamConsume
end

class Puppet::Type::MetaParamConsume
end

class Puppet::Type::MetaParamExport
end

class Puppet::Type::MetaParamExport
end

class Puppet::Type::MetaParamLoglevel
  def default(); end

  def unsafe_munge(loglevel); end
end

class Puppet::Type::MetaParamLoglevel
end

class Puppet::Type::MetaParamNoop
end

class Puppet::Type::MetaParamNoop
end

class Puppet::Type::MetaParamNotify
end

class Puppet::Type::MetaParamNotify
end

class Puppet::Type::MetaParamRequire
end

class Puppet::Type::MetaParamRequire
end

class Puppet::Type::MetaParamSchedule
end

class Puppet::Type::MetaParamSchedule
end

class Puppet::Type::MetaParamStage
end

class Puppet::Type::MetaParamStage
end

class Puppet::Type::MetaParamSubscribe
end

class Puppet::Type::MetaParamSubscribe
end

class Puppet::Type::MetaParamTag
  def unsafe_munge(tags); end
end

class Puppet::Type::MetaParamTag
end

class Puppet::Type::Notify
end

class Puppet::Type::Notify::Message
  def default(); end
end

class Puppet::Type::Notify::Message
end

class Puppet::Type::Notify::ParameterName
end

class Puppet::Type::Notify::ParameterName
end

class Puppet::Type::Notify::ParameterWithpath
  def default(); end
end

class Puppet::Type::Notify::ParameterWithpath
end

class Puppet::Type::Notify
end

class Puppet::Type::Package
  def allow_virtual?(); end

  def clear(); end

  def exists?(); end

  def refresh(); end
end

class Puppet::Type::Package::Ensure
  def latest(); end

  def latest=(latest); end

  def set_absent(); end

  def set_held(); end

  def set_latest(); end

  def set_present(); end

  def set_purged(); end

  def should_to_s(newvalue=T.unsafe(nil)); end
end

class Puppet::Type::Package::Ensure
end

module Puppet::Type::Package::FeatureModule
  def feature?(name); end

  def features(); end

  def has_feature(*names); end

  def has_features(*names); end

  def holdable?(); end

  def install_options?(); end

  def installable?(); end

  def package_settings?(); end

  def purgeable?(); end

  def reinstallable?(); end

  def satisfies?(*needed); end

  def targetable?(); end

  def uninstall_options?(); end

  def uninstallable?(); end

  def upgradeable?(); end

  def versionable?(); end

  def virtual_packages?(); end
end

module Puppet::Type::Package::FeatureModule
  extend ::T::Sig
end

class Puppet::Type::Package::Package_settings
  def change_to_s(currentvalue, newvalue); end

  def is_to_s(currentvalue); end

  def should_to_s(newvalue); end
end

class Puppet::Type::Package::Package_settings
end

class Puppet::Type::Package::ParameterAdminfile
end

class Puppet::Type::Package::ParameterAdminfile
end

class Puppet::Type::Package::ParameterAllow_virtual
  def default(); end
end

class Puppet::Type::Package::ParameterAllow_virtual
end

class Puppet::Type::Package::ParameterAllowcdrom
end

class Puppet::Type::Package::ParameterAllowcdrom
end

class Puppet::Type::Package::ParameterCategory
end

class Puppet::Type::Package::ParameterCategory
end

class Puppet::Type::Package::ParameterCommand
  def default(); end
end

class Puppet::Type::Package::ParameterCommand
end

class Puppet::Type::Package::ParameterConfigfiles
  def default(); end
end

class Puppet::Type::Package::ParameterConfigfiles
end

class Puppet::Type::Package::ParameterDescription
end

class Puppet::Type::Package::ParameterDescription
end

class Puppet::Type::Package::ParameterFlavor
end

class Puppet::Type::Package::ParameterFlavor
end

class Puppet::Type::Package::ParameterInstall_options
end

class Puppet::Type::Package::ParameterInstall_options
end

class Puppet::Type::Package::ParameterInstance
end

class Puppet::Type::Package::ParameterInstance
end

class Puppet::Type::Package::ParameterName
end

class Puppet::Type::Package::ParameterName
end

class Puppet::Type::Package::ParameterPlatform
end

class Puppet::Type::Package::ParameterPlatform
end

class Puppet::Type::Package::ParameterProvider
  def default(); end

  def unsafe_munge(provider); end

  def unsafe_validate(provider_class); end
end

class Puppet::Type::Package::ParameterProvider
  def self.parenttype(); end

  def self.parenttype=(parenttype); end
end

class Puppet::Type::Package::ParameterReinstall_on_refresh
  def default(); end
end

class Puppet::Type::Package::ParameterReinstall_on_refresh
end

class Puppet::Type::Package::ParameterResponsefile
end

class Puppet::Type::Package::ParameterResponsefile
end

class Puppet::Type::Package::ParameterRoot
end

class Puppet::Type::Package::ParameterRoot
end

class Puppet::Type::Package::ParameterSource
end

class Puppet::Type::Package::ParameterSource
end

class Puppet::Type::Package::ParameterStatus
end

class Puppet::Type::Package::ParameterStatus
end

class Puppet::Type::Package::ParameterUninstall_options
end

class Puppet::Type::Package::ParameterUninstall_options
end

class Puppet::Type::Package::ParameterVendor
end

class Puppet::Type::Package::ParameterVendor
end

class Puppet::Type::Package::ProviderAix
  include ::Puppet::Type::Package::FeatureModule
  def install(useversion=T.unsafe(nil)); end

  def installp(*args); end

  def latest(); end

  def latest_info(); end

  def latest_info=(latest_info); end

  def lslpp(*args); end

  def query(); end

  def uninstall(); end

  def update(); end
end

class Puppet::Type::Package::ProviderAix
  extend ::Puppet::Type::Package::FeatureModule
  def self.installp(*args); end

  def self.lslpp(*args); end

  def self.pkglist(hash=T.unsafe(nil)); end

  def self.srclistcmd(source); end
end

class Puppet::Type::Package::ProviderAppdmg
  include ::Puppet::Type::Package::FeatureModule
  def curl(*args); end

  def ditto(*args); end

  def hdiutil(*args); end

  def install(); end

  def query(); end
end

class Puppet::Type::Package::ProviderAppdmg
  extend ::Puppet::Type::Package::FeatureModule
  def self.curl(*args); end

  def self.ditto(*args); end

  def self.hdiutil(*args); end

  def self.installapp(source, name, orig_source); end

  def self.installpkgdmg(source, name); end

  def self.instances_by_name(); end
end

class Puppet::Type::Package::ProviderApple
  include ::Puppet::Type::Package::FeatureModule
  def install(); end

  def installer(*args); end

  def query(); end
end

class Puppet::Type::Package::ProviderApple
  extend ::Puppet::Type::Package::FeatureModule
  def self.installer(*args); end

  def self.instance_by_name(); end
end

class Puppet::Type::Package::ProviderApt
  include ::Puppet::Util::Package
  def aptcache(*args); end

  def aptget(*args); end

  def checkforcdrom(); end

  def install_options(); end

  def preseed(*args); end

  def run_preseed(); end
end

class Puppet::Type::Package::ProviderApt
  def self.aptcache(*args); end

  def self.aptget(*args); end

  def self.preseed(*args); end
end

class Puppet::Type::Package::ProviderAptitude
  def aptitude(*args); end
end

class Puppet::Type::Package::ProviderAptitude
  def self.aptitude(*args); end
end

class Puppet::Type::Package::ProviderAptrpm
  include ::Puppet::Util::Package
  def aptcache(*args); end

  def aptget(*args); end

  def purge(); end
end

class Puppet::Type::Package::ProviderAptrpm
  def self.aptcache(*args); end

  def self.aptget(*args); end
end

class Puppet::Type::Package::ProviderBlastwave
  def pkgget(*args); end

  def pkgget_with_cat(*args); end
end

class Puppet::Type::Package::ProviderBlastwave
  def self.blastlist(hash); end

  def self.blastsplit(line); end

  def self.extended(mod); end

  def self.instances(hash=T.unsafe(nil)); end

  def self.pkgget(*args); end
end

class Puppet::Type::Package::ProviderDnf
end

class Puppet::Type::Package::ProviderDnf
end

class Puppet::Type::Package::ProviderDpkg
  include ::Puppet::Type::Package::FeatureModule
  def dpkg(*args); end

  def dpkg_deb(*args); end

  def dpkgquery(*args); end

  def hold(); end

  def install(); end

  def latest(); end

  def package_not_installed?(name); end

  def purge(); end

  def query(); end

  def unhold(); end

  def uninstall(); end

  def update(); end
  DPKG_QUERY_FORMAT_STRING = ::T.let(nil, ::T.untyped)
  FIELDS = ::T.let(nil, ::T.untyped)
  FIELDS_REGEX = ::T.let(nil, ::T.untyped)
end

class Puppet::Type::Package::ProviderDpkg
  extend ::Puppet::Type::Package::FeatureModule
  def self.dpkg(*args); end

  def self.dpkg_deb(*args); end

  def self.dpkgquery(*args); end

  def self.dpkgquery_piped(*args, &block); end

  def self.parse_line(line); end
end

class Puppet::Type::Package::ProviderFink
  include ::Puppet::Util::Package
  def aptcache(*args); end

  def aptget(*args); end

  def fink(*args); end

  def finkcmd(*args); end

  def run_preseed(); end
end

class Puppet::Type::Package::ProviderFink
  def self.aptcache(*args); end

  def self.aptget(*args); end

  def self.fink(*args); end
end

class Puppet::Type::Package::ProviderFreebsd
  def install(); end
end

class Puppet::Type::Package::ProviderFreebsd
end

class Puppet::Type::Package::ProviderGem
  include ::Puppet::Type::Package::FeatureModule
  def gemcmd(*args); end

  def install(useversion=T.unsafe(nil)); end

  def install_options(); end

  def insync?(is); end

  def latest(); end

  def query(); end

  def rubygem_version(command); end

  def uninstall(); end

  def uninstall_options(); end

  def update(); end
end

class Puppet::Type::Package::ProviderGem
  extend ::Puppet::Type::Package::FeatureModule
  def self.execute_gem_command(command, command_options); end

  def self.gemcmd(*args); end

  def self.gemlist(options); end

  def self.gemsplit(desc); end

  def self.instances(target_command=T.unsafe(nil)); end

  def self.provider_command(); end
end

class Puppet::Type::Package::ProviderHpux
  include ::Puppet::Type::Package::FeatureModule
  def install(); end

  def query(); end

  def standard_args(); end

  def swinstall(*args); end

  def swlist(*args); end

  def swremove(*args); end

  def uninstall(); end
end

class Puppet::Type::Package::ProviderHpux
  extend ::Puppet::Type::Package::FeatureModule
  def self.swinstall(*args); end

  def self.swlist(*args); end

  def self.swremove(*args); end
end

class Puppet::Type::Package::ProviderMacports
  include ::Puppet::Type::Package::FeatureModule
  def install(); end

  def latest(); end

  def port(*args); end

  def query(); end

  def uninstall(); end

  def update(); end
end

class Puppet::Type::Package::ProviderMacports
  extend ::Puppet::Type::Package::FeatureModule
  def self.hash_from_line(line, regex, fields); end

  def self.parse_info_query_line(line); end

  def self.parse_installed_query_line(line); end

  def self.port(*args); end
end

class Puppet::Type::Package::ProviderNim
  def nimclient(*args); end

  def rpm(*args); end
  HEADER_LINE_REGEX = ::T.let(nil, ::T.untyped)
  INSTALLP_PACKAGE_REGEX = ::T.let(nil, ::T.untyped)
  PACKAGE_LINE_REGEX = ::T.let(nil, ::T.untyped)
  RPM_PACKAGE_REGEX = ::T.let(nil, ::T.untyped)
end

class Puppet::Type::Package::ProviderNim
  def self.nimclient(*args); end

  def self.rpm(*args); end
end

class Puppet::Type::Package::ProviderOpenbsd
  include ::Puppet::Type::Package::FeatureModule
  def get_full_name(latest=T.unsafe(nil)); end

  def get_version(); end

  def install(latest=T.unsafe(nil)); end

  def install_options(); end

  def latest(); end

  def parse_pkgconf(); end

  def pkgadd(*args); end

  def pkgdelete(*args); end

  def pkginfo(*args); end

  def purge(); end

  def query(); end

  def uninstall(); end

  def uninstall_options(); end

  def update(); end
end

class Puppet::Type::Package::ProviderOpenbsd
  extend ::Puppet::Type::Package::FeatureModule
  def self.listcmd(); end

  def self.pkgadd(*args); end

  def self.pkgdelete(*args); end

  def self.pkginfo(*args); end
end

class Puppet::Type::Package::ProviderOpkg
  include ::Puppet::Type::Package::FeatureModule
  def install(); end

  def latest(); end

  def opkg(*args); end

  def query(); end

  def uninstall(); end

  def update(); end
end

class Puppet::Type::Package::ProviderOpkg
  extend ::Puppet::Type::Package::FeatureModule
  def self.opkg(*args); end
end

class Puppet::Type::Package::ProviderPacman
  include ::Puppet::Type::Package::FeatureModule
  def install(); end

  def latest(); end

  def pacman(*args); end

  def query(); end

  def uninstall(); end

  def update(); end
end

class Puppet::Type::Package::ProviderPacman
  extend ::Puppet::Type::Package::FeatureModule
  def self.get_installed_groups(installed_packages, filter=T.unsafe(nil)); end

  def self.get_installed_packages(); end

  def self.group?(name); end

  def self.pacman(*args); end

  def self.to_resource_hash(name, version); end

  def self.yaourt?(); end
end

class Puppet::Type::Package::ProviderPip
  include ::Puppet::Type::Package::FeatureModule
  def install(); end

  def install_options(); end

  def latest(); end

  def latest_with_new_pip(); end

  def latest_with_old_pip(); end

  def query(); end

  def uninstall(); end

  def update(); end
end

class Puppet::Type::Package::ProviderPip
  extend ::Puppet::Type::Package::FeatureModule
  def self.cmd(); end

  def self.instances(target_command=T.unsafe(nil)); end

  def self.parse(line); end

  def self.pip_version(command); end

  def self.provider_command(); end
end

class Puppet::Type::Package::ProviderPip3
end

class Puppet::Type::Package::ProviderPip3
end

class Puppet::Type::Package::ProviderPkg
  include ::Puppet::Type::Package::FeatureModule
  def exec_cmd(*cmd); end

  def hold(); end

  def install(nofail=T.unsafe(nil)); end

  def insync?(is); end

  def latest(); end

  def pkg(*args); end

  def query(); end

  def unhold(); end

  def uninstall(); end

  def update(); end
end

class Puppet::Type::Package::ProviderPkg
  extend ::Puppet::Type::Package::FeatureModule
  def self.ifo_flag(flags); end

  def self.parse_line(line); end

  def self.pkg(*args); end

  def self.pkg_state(state); end

  def self.ufoxi_flag(flags); end
end

class Puppet::Type::Package::ProviderPkgdmg
  include ::Puppet::Type::Package::FeatureModule
  def curl(*args); end

  def hdiutil(*args); end

  def install(); end

  def installer(*args); end

  def query(); end
end

class Puppet::Type::Package::ProviderPkgdmg
  extend ::Puppet::Type::Package::FeatureModule
  def self.curl(*args); end

  def self.hdiutil(*args); end

  def self.installer(*args); end

  def self.installpkg(source, name, orig_source); end

  def self.installpkgdmg(source, name); end

  def self.instance_by_name(); end
end

class Puppet::Type::Package::ProviderPkgin
  include ::Puppet::Type::Package::FeatureModule
  def install(); end

  def latest(); end

  def parse_pkgsearch_line(); end

  def pkgin(*args); end

  def query(); end

  def uninstall(); end

  def update(); end
end

class Puppet::Type::Package::ProviderPkgin
  extend ::Puppet::Type::Package::FeatureModule
  def self.parse_pkgin_line(package); end

  def self.pkgin(*args); end
end

class Puppet::Type::Package::ProviderPkgng
  include ::Puppet::Type::Package::FeatureModule
  def install(); end

  def latest(); end

  def origin(); end

  def pkg(*args); end

  def query(); end

  def repo_tag_from_urn(urn); end

  def uninstall(); end

  def update(); end

  def version(); end

  def version=(); end
end

class Puppet::Type::Package::ProviderPkgng
  extend ::Puppet::Type::Package::FeatureModule
  def self.cached_version_list(); end

  def self.get_latest_version(origin); end

  def self.get_query(); end

  def self.get_resource_info(name); end

  def self.get_version_list(); end

  def self.parse_pkg_query_line(line); end

  def self.pkg(*args); end

  def self.prefetch(resources); end
end

class Puppet::Type::Package::ProviderPkgutil
  def pkgsingle(resource); end

  def pkguti(*args); end

  def run_pkgutil(resource, *args); end
end

class Puppet::Type::Package::ProviderPkgutil
  def self.availlist(); end

  def self.healthcheck(); end

  def self.instances(hash=T.unsafe(nil)); end

  def self.noise?(line); end

  def self.parse_pkglist(output, hash=T.unsafe(nil)); end

  def self.pkgsplit(line); end

  def self.pkguti(*args); end
end

class Puppet::Type::Package::ProviderPortage
  include ::Puppet::Type::Package::FeatureModule
  def eix(*args); end

  def emerge(*args); end

  def install(); end

  def latest(); end

  def qatom(); end

  def qatom_bin(*args); end

  def qatom_output_format(); end

  def qatom_result_fields(); end

  def qatom_result_format(); end

  def query(); end

  def reinstall(); end

  def uninstall(); end

  def update(); end

  def update_eix(*args); end
end

class Puppet::Type::Package::ProviderPortage
  extend ::Puppet::Type::Package::FeatureModule
  def self.eix(*args); end

  def self.eix_install_versions_format(); end

  def self.eix_installed_versions_format(); end

  def self.eix_limit(); end

  def self.eix_result_fields(); end

  def self.eix_result_format(); end

  def self.eix_search_arguments(); end

  def self.eix_search_format(); end

  def self.eix_slot_versions_format(); end

  def self.eix_version_format(); end

  def self.emerge(*args); end

  def self.get_sets(); end

  def self.qatom_bin(*args); end

  def self.update_eix(*args); end
end

class Puppet::Type::Package::ProviderPorts
  def portinfo(*args); end

  def portuninstall(*args); end

  def portupgrade(*args); end

  def portversion(*args); end
end

class Puppet::Type::Package::ProviderPorts
  def self.portinfo(*args); end

  def self.portuninstall(*args); end

  def self.portupgrade(*args); end

  def self.portversion(*args); end
end

class Puppet::Type::Package::ProviderPortupgrade
  include ::Puppet::Type::Package::FeatureModule
  include ::Puppet::Util::Execution
  def install(); end

  def latest(); end

  def portinfo(*args); end

  def portinstall(*args); end

  def portuninstall(*args); end

  def portupgrade(*args); end

  def portversion(*args); end

  def query(); end

  def uninstall(); end

  def update(); end
end

class Puppet::Type::Package::ProviderPortupgrade
  extend ::Puppet::Type::Package::FeatureModule
  def self.portinfo(*args); end

  def self.portinstall(*args); end

  def self.portuninstall(*args); end

  def self.portupgrade(*args); end

  def self.portversion(*args); end
end

class Puppet::Type::Package::ProviderPuppet_gem
end

class Puppet::Type::Package::ProviderPuppet_gem
end

class Puppet::Type::Package::ProviderRpm
  include ::Puppet::Type::Package::FeatureModule
  def compare_values(s1, s2); end

  def install(); end

  def install_options(); end

  def insync?(is); end

  def latest(); end

  def query(); end

  def rpm(*args); end

  def rpm_compareEVR(should_hash, is_hash); end

  def rpm_parse_evr(s); end

  def rpmvercmp(str1, str2); end

  def uninstall(); end

  def uninstall_options(); end

  def update(); end
  NEVRA_FIELDS = ::T.let(nil, ::T.untyped)
  NEVRA_FORMAT = ::T.let(nil, ::T.untyped)
  NEVRA_REGEX = ::T.let(nil, ::T.untyped)
end

class Puppet::Type::Package::ProviderRpm
  extend ::Puppet::Type::Package::FeatureModule
  def self.current_version(); end

  def self.nevra_to_hash(line); end

  def self.nodigest(); end

  def self.nosignature(); end

  def self.rpm(*args); end
end

class Puppet::Type::Package::ProviderRug
  def rug(*args); end
end

class Puppet::Type::Package::ProviderRug
  def self.rug(*args); end
end

class Puppet::Type::Package::ProviderSun
  include ::Puppet::Type::Package::FeatureModule
  def if_have_value(prefix, value); end

  def info2hash(device=T.unsafe(nil)); end

  def install(); end

  def latest(); end

  def pkgadd(*args); end

  def pkginfo(*args); end

  def pkgrm(*args); end

  def prepare_cmd(opt); end

  def query(); end

  def uninstall(); end

  def update(); end
  Namemap = ::T.let(nil, ::T.untyped)
end

class Puppet::Type::Package::ProviderSun
  extend ::Puppet::Type::Package::FeatureModule
  def self.namemap(hash); end

  def self.parse_pkginfo(out); end

  def self.pkgadd(*args); end

  def self.pkginfo(*args); end

  def self.pkgrm(*args); end
end

class Puppet::Type::Package::ProviderSunfreeware
end

class Puppet::Type::Package::ProviderSunfreeware
end

class Puppet::Type::Package::ProviderTdnf
end

class Puppet::Type::Package::ProviderTdnf
end

class Puppet::Type::Package::ProviderUp2date
  def up2date(*args); end
end

class Puppet::Type::Package::ProviderUp2date
  def self.up2date(*args); end
end

class Puppet::Type::Package::ProviderUrpmi
  def purge(); end

  def urpme(*args); end

  def urpmi(*args); end

  def urpmq(*args); end
end

class Puppet::Type::Package::ProviderUrpmi
  def self.urpme(*args); end

  def self.urpmi(*args); end

  def self.urpmq(*args); end
end

class Puppet::Type::Package::ProviderWindows
  include ::Puppet::Type::Package::FeatureModule
  def check_result(hr); end

  def install(); end

  def install_options(); end

  def package(); end

  def package=(package); end

  def query(); end

  def uninstall(); end

  def uninstall_options(); end
  ERROR_SUCCESS = ::T.let(nil, ::T.untyped)
  ERROR_SUCCESS_REBOOT_INITIATED = ::T.let(nil, ::T.untyped)
  ERROR_SUCCESS_REBOOT_REQUIRED = ::T.let(nil, ::T.untyped)
end

class Puppet::Type::Package::ProviderWindows
  extend ::Puppet::Type::Package::FeatureModule
  def self.to_hash(pkg); end
end

class Puppet::Type::Package::ProviderYum
  def cmd(*args); end

  def purge(); end
end

class Puppet::Type::Package::ProviderYum
  def self.check_updates(disablerepo, enablerepo, disableexcludes); end

  def self.clear(); end

  def self.cmd(*args); end

  def self.error_level(); end

  def self.latest_package_version(package, disablerepo, enablerepo, disableexcludes); end

  def self.parse_updates(str); end

  def self.update_command(); end

  def self.update_to_hash(pkgname, pkgversion); end
end

class Puppet::Type::Package::ProviderZypper
  def zypper(*args); end

  def zypper_version(); end
end

class Puppet::Type::Package::ProviderZypper
  def self.latest_package_version(package); end

  def self.list_updates(); end

  def self.reset!(); end

  def self.zypper(*args); end
end

class Puppet::Type::Package
end

class Puppet::Type::Resources
  def able_to_ensure_absent?(resource); end

  def check(resource); end

  def generate(); end

  def purge?(); end

  def resource_type(); end

  def system_users(); end

  def user_check(resource); end
end

class Puppet::Type::Resources::ParameterName
  def unsafe_munge(v); end

  def unsafe_validate(name); end
end

class Puppet::Type::Resources::ParameterName
end

class Puppet::Type::Resources::ParameterPurge
  def default(); end
end

class Puppet::Type::Resources::ParameterPurge
end

class Puppet::Type::Resources::ParameterUnless_system_user
  def default(); end
end

class Puppet::Type::Resources::ParameterUnless_system_user
end

class Puppet::Type::Resources::ParameterUnless_uid
end

class Puppet::Type::Resources::ParameterUnless_uid
end

class Puppet::Type::Resources
  def self.reset_system_users_max_uid!(); end

  def self.system_users_max_uid(); end
end

class Puppet::Type::Schedule
  def match?(previous=T.unsafe(nil), now=T.unsafe(nil)); end
end

class Puppet::Type::Schedule::ParameterName
end

class Puppet::Type::Schedule::ParameterName
end

class Puppet::Type::Schedule::ParameterPeriod
  def match?(previous, now); end
end

class Puppet::Type::Schedule::ParameterPeriod
end

class Puppet::Type::Schedule::ParameterPeriodmatch
  def default(); end
end

class Puppet::Type::Schedule::ParameterPeriodmatch
end

class Puppet::Type::Schedule::ParameterRange
  def match?(previous, now); end

  def unsafe_munge(values); end

  def unsafe_validate(values); end

  def weekday_match?(day); end
end

class Puppet::Type::Schedule::ParameterRange
end

class Puppet::Type::Schedule::ParameterRepeat
  def default(); end

  def match?(previous, now); end
end

class Puppet::Type::Schedule::ParameterRepeat
end

class Puppet::Type::Schedule::ParameterWeekday
  def match?(previous, now); end

  def unsafe_munge(values); end

  def unsafe_validate(values); end

  def weekday_integer?(value); end

  def weekday_string?(value); end
end

class Puppet::Type::Schedule::ParameterWeekday
end

class Puppet::Type::Schedule
  def self.mkdefaultschedules(); end
end

class Puppet::Type::Service
  def refresh(); end
end

class Puppet::Type::Service::Enable
  def insync?(current); end

  def set_false(); end

  def set_manual(); end

  def set_mask(); end

  def set_true(); end
end

class Puppet::Type::Service::Enable
end

class Puppet::Type::Service::Ensure
  def set_running(); end

  def set_stopped(); end
end

class Puppet::Type::Service::Ensure
end

module Puppet::Type::Service::FeatureModule
  def configurable_timeout?(); end

  def controllable?(); end

  def enableable?(); end

  def feature?(name); end

  def features(); end

  def flaggable?(); end

  def has_feature(*names); end

  def has_features(*names); end

  def maskable?(); end

  def refreshable?(); end

  def satisfies?(*needed); end
end

module Puppet::Type::Service::FeatureModule
  extend ::T::Sig
end

class Puppet::Type::Service::Flags
end

class Puppet::Type::Service::Flags
end

class Puppet::Type::Service::ParameterBinary
end

class Puppet::Type::Service::ParameterBinary
end

class Puppet::Type::Service::ParameterControl
  def default(); end
end

class Puppet::Type::Service::ParameterControl
end

class Puppet::Type::Service::ParameterHasrestart
end

class Puppet::Type::Service::ParameterHasrestart
end

class Puppet::Type::Service::ParameterHasstatus
  def default(); end
end

class Puppet::Type::Service::ParameterHasstatus
end

class Puppet::Type::Service::ParameterManifest
end

class Puppet::Type::Service::ParameterManifest
end

class Puppet::Type::Service::ParameterName
end

class Puppet::Type::Service::ParameterName
end

class Puppet::Type::Service::ParameterPath
  def default(); end
end

class Puppet::Type::Service::ParameterPath
end

class Puppet::Type::Service::ParameterPattern
  def default(); end
end

class Puppet::Type::Service::ParameterPattern
end

class Puppet::Type::Service::ParameterProvider
  def default(); end

  def unsafe_munge(provider); end

  def unsafe_validate(provider_class); end
end

class Puppet::Type::Service::ParameterProvider
  def self.parenttype(); end

  def self.parenttype=(parenttype); end
end

class Puppet::Type::Service::ParameterRestart
end

class Puppet::Type::Service::ParameterRestart
end

class Puppet::Type::Service::ParameterStart
end

class Puppet::Type::Service::ParameterStart
end

class Puppet::Type::Service::ParameterStatus
end

class Puppet::Type::Service::ParameterStatus
end

class Puppet::Type::Service::ParameterStop
end

class Puppet::Type::Service::ParameterStop
end

class Puppet::Type::Service::ParameterTimeout
  def default(); end
end

class Puppet::Type::Service::ParameterTimeout
end

class Puppet::Type::Service::ProviderBase
  def kill(*args); end

  def start(); end

  def startcmd(); end

  def status(); end

  def statuscmd(); end

  def stop(); end

  def stopcmd(); end
end

class Puppet::Type::Service::ProviderBase
  def self.kill(*args); end
end

class Puppet::Type::Service::ProviderBsd
  def disable(); end

  def enable(); end

  def enabled?(); end

  def rcconf_dir(); end
end

class Puppet::Type::Service::ProviderBsd
end

class Puppet::Type::Service::ProviderDaemontools
  def daemon(); end

  def disable(); end

  def enable(); end

  def enabled?(); end

  def service(); end

  def servicedir(); end

  def servicedir=(servicedir); end

  def setupservice(); end

  def svc(*args); end

  def svstat(*args); end
end

class Puppet::Type::Service::ProviderDaemontools
  def self.daemondir(); end

  def self.defpath(); end

  def self.defpath=(defpath); end

  def self.svc(*args); end

  def self.svstat(*args); end
end

class Puppet::Type::Service::ProviderDebian
  def disable(); end

  def enable(); end

  def enabled?(); end

  def get_start_link_count(); end

  def invoke_rc(*args); end

  def service(*args); end

  def update_rc(*args); end
end

class Puppet::Type::Service::ProviderDebian
  def self.invoke_rc(*args); end

  def self.service(*args); end

  def self.update_rc(*args); end
end

class Puppet::Type::Service::ProviderFreebsd
  def disable(); end

  def enable(); end

  def enabled?(); end

  def error(msg); end

  def extract_value_name(name, rc_index, regex, regex_index); end

  def rc_add(service, rcvar, yesno); end

  def rc_edit(yesno); end

  def rc_replace(service, rcvar, yesno); end

  def rcconf(); end

  def rcconf_dir(); end

  def rcconf_local(); end

  def rcvar(); end

  def rcvar_name(); end

  def rcvar_value(); end

  def service_name(); end
end

class Puppet::Type::Service::ProviderFreebsd
end

class Puppet::Type::Service::ProviderGentoo
  def disable(); end

  def enable(); end

  def enabled?(); end

  def update(*args); end
end

class Puppet::Type::Service::ProviderGentoo
  def self.update(*args); end
end

class Puppet::Type::Service::ProviderInit
  def hasstatus=(value); end

  def initscript(); end

  def paths(); end

  def search(name); end
end

class Puppet::Type::Service::ProviderInit
  def self.defpath(); end

  def self.excludes(); end

  def self.get_services(defpath, exclude=T.unsafe(nil)); end

  def self.is_init?(script=T.unsafe(nil)); end
end

class Puppet::Type::Service::ProviderLaunchd
  def binary(); end

  def binary=(val); end

  def control(); end

  def control=(val); end

  def disable(); end

  def enable(); end

  def enable=(val); end

  def enabled?(); end

  def ensure(); end

  def ensure=(val); end

  def exists?(); end

  def flags(); end

  def flags=(val); end

  def flush(); end

  def hasrestart(); end

  def hasrestart=(val); end

  def hasstatus(); end

  def hasstatus=(val); end

  def launchctl(*args); end

  def manifest(); end

  def manifest=(val); end

  def path(); end

  def path=(val); end

  def pattern(); end

  def pattern=(val); end

  def plist_from_label(label); end

  def provider(); end

  def provider=(val); end

  def restart=(val); end

  def start=(val); end

  def status=(val); end

  def stop=(val); end

  def timeout(); end

  def timeout=(val); end
end

class Puppet::Type::Service::ProviderLaunchd
  def self.get_os_version(); end

  def self.job_list(); end

  def self.jobsearch(label=T.unsafe(nil)); end

  def self.launchctl(*args); end

  def self.launchd_overrides(); end

  def self.launchd_paths(); end

  def self.make_label_to_path_map(refresh=T.unsafe(nil)); end

  def self.prefetch(resources); end

  def self.read_overrides(); end

  def self.read_plist(path); end

  def self.return_globbed_list_of_file_paths(path); end
end

class Puppet::Type::Service::ProviderOpenbsd
  def disable(); end

  def enable(); end

  def enabled?(); end

  def flags(); end

  def flags=(value); end

  def rcctl(*args); end

  def running?(); end
end

class Puppet::Type::Service::ProviderOpenbsd
  def self.rcctl(*args); end
end

class Puppet::Type::Service::ProviderOpenrc
  def disable(); end

  def enable(); end

  def enabled?(); end

  def rcservice(*args); end

  def rcstatus(*args); end

  def rcupdate(*args); end
  STATUSLINE = ::T.let(nil, ::T.untyped)
end

class Puppet::Type::Service::ProviderOpenrc
  def self.rcservice(*args); end

  def self.rcstatus(*args); end

  def self.rcupdate(*args); end
end

class Puppet::Type::Service::ProviderOpenwrt
  def disable(); end

  def enable(); end

  def enabled?(); end
end

class Puppet::Type::Service::ProviderOpenwrt
end

class Puppet::Type::Service::ProviderRcng
end

class Puppet::Type::Service::ProviderRcng
end

class Puppet::Type::Service::ProviderRedhat
  def chkconfig(*args); end

  def disable(); end

  def enable(); end

  def enabled?(); end

  def service(*args); end
end

class Puppet::Type::Service::ProviderRedhat
  def self.chkconfig(*args); end

  def self.service(*args); end
end

class Puppet::Type::Service::ProviderRunit
  def sv(*args); end
end

class Puppet::Type::Service::ProviderRunit
  def self.sv(*args); end
end

class Puppet::Type::Service::ProviderService
  include ::Puppet::Type::Service::FeatureModule
  def restart(); end

  def restartcmd(); end

  def texecute(type, command, fof=T.unsafe(nil), squelch=T.unsafe(nil), combine=T.unsafe(nil)); end

  def ucommand(type, fof=T.unsafe(nil)); end
end

class Puppet::Type::Service::ProviderService
  extend ::Puppet::Type::Service::FeatureModule
end

class Puppet::Type::Service::ProviderSmf
  def adm(*args); end

  def complete_service?(); end

  def disable(); end

  def enable(); end

  def enabled?(); end

  def service_fmri(); end

  def service_states(); end

  def setupservice(); end

  def supports_incomplete_services?(); end

  def svccfg(*args); end

  def svcs(*args); end

  def wait(*desired_state); end
end

class Puppet::Type::Service::ProviderSmf
  def self.adm(*args); end

  def self.svccfg(*args); end

  def self.svcs(*args); end
end

class Puppet::Type::Service::ProviderSrc
  def chitab(*args); end

  def default_action(); end

  def default_runlevel(); end

  def disable(); end

  def enable(); end

  def enabled?(); end

  def lsitab(*args); end

  def lssrc(*args); end

  def mkitab(*args); end

  def refresh(*args); end

  def rmitab(*args); end

  def startsrc(*args); end

  def stopsrc(*args); end

  def wait(desired_state); end
end

class Puppet::Type::Service::ProviderSrc
  def self.chitab(*args); end

  def self.lsitab(*args); end

  def self.lssrc(*args); end

  def self.mkitab(*args); end

  def self.refresh(*args); end

  def self.rmitab(*args); end

  def self.startsrc(*args); end

  def self.stopsrc(*args); end
end

class Puppet::Type::Service::ProviderSystemd
  def cached_enabled?(); end

  def daemon_reload?(); end

  def debian_enabled?(); end

  def disable(); end

  def enable(); end

  def enabled?(); end

  def get_start_link_count(); end

  def mask(); end

  def prepare_error_message(name, action, exception); end

  def systemctl(*args); end

  def systemctl_change_enable(action); end

  def unmask(); end
end

class Puppet::Type::Service::ProviderSystemd
  def self.systemctl(*args); end
end

class Puppet::Type::Service::ProviderUpstart
  def initctl(*args); end

  def overscript(); end

  def status_exec(*args); end

  def upstart_version(); end
end

class Puppet::Type::Service::ProviderUpstart
  def self.get_services(exclude=T.unsafe(nil)); end

  def self.has_initctl?(); end

  def self.initctl(*args); end

  def self.restart(*args); end

  def self.start(*args); end

  def self.status_exec(*args); end

  def self.stop(*args); end
end

class Puppet::Type::Service::ProviderWindows
  def default_timeout(); end

  def disable(); end

  def enable(); end

  def enabled?(); end

  def manual_start(); end

  def start(); end

  def status(); end

  def stop(); end
end

class Puppet::Type::Service::ProviderWindows
end

class Puppet::Type::Service
end

class Puppet::Type::Stage
end

class Puppet::Type::Stage::ParameterName
end

class Puppet::Type::Stage::ParameterName
end

class Puppet::Type::Stage
end

class Puppet::Type::Tidy
  def generate(); end

  def initialize(hash); end

  def matches?(path); end

  def mkfile(path); end

  def rmdirs?(); end

  def stat(path); end

  def tidy?(path); end

  def validate(); end
end

class Puppet::Type::Tidy::ParameterAge
  def convert(unit, multi); end

  def tidy?(path, stat); end

  def unsafe_munge(age); end
end

class Puppet::Type::Tidy::ParameterAge
end

class Puppet::Type::Tidy::ParameterBackup
end

class Puppet::Type::Tidy::ParameterBackup
end

class Puppet::Type::Tidy::ParameterMatches
  def tidy?(path, stat); end
end

class Puppet::Type::Tidy::ParameterMatches
end

class Puppet::Type::Tidy::ParameterPath
end

class Puppet::Type::Tidy::ParameterPath
end

class Puppet::Type::Tidy::ParameterRecurse
  def unsafe_validate(arg); end
end

class Puppet::Type::Tidy::ParameterRecurse
end

class Puppet::Type::Tidy::ParameterRmdirs
end

class Puppet::Type::Tidy::ParameterRmdirs
end

class Puppet::Type::Tidy::ParameterSize
  def convert(unit, multi); end

  def tidy?(path, stat); end

  def unsafe_munge(size); end
end

class Puppet::Type::Tidy::ParameterSize
end

class Puppet::Type::Tidy::ParameterType
  def default(); end
end

class Puppet::Type::Tidy::ParameterType
end

class Puppet::Type::Tidy
end

class Puppet::Type::Usee_type
end

class Puppet::Type::Usee_type::ParameterName
end

class Puppet::Type::Usee_type::ParameterName
end

class Puppet::Type::Usee_type
end

class Puppet::Type::User
  def allowdupe?(); end

  def exists?(); end

  def find_unmanaged_keys(); end

  def forcelocal?(); end

  def generate(); end

  def managehome?(); end

  def system?(); end

  def unknown_keys_in_file(keyfile); end
end

class Puppet::Type::User::Attributes
end

class Puppet::Type::User::Attributes
end

class Puppet::Type::User::Auths
end

class Puppet::Type::User::Auths
end

class Puppet::Type::User::Comment
  def change_to_s(currentvalue, newvalue); end
end

class Puppet::Type::User::Comment
end

class Puppet::Type::User::Ensure
  def set_absent(); end

  def set_present(); end

  def set_role(); end
end

class Puppet::Type::User::Ensure
end

class Puppet::Type::User::Expiry
end

class Puppet::Type::User::Expiry
end

module Puppet::Type::User::FeatureModule
  def allows_duplicates?(); end

  def feature?(name); end

  def features(); end

  def has_feature(*names); end

  def has_features(*names); end

  def libuser?(); end

  def manages_aix_lam?(); end

  def manages_expiry?(); end

  def manages_homedir?(); end

  def manages_loginclass?(); end

  def manages_password_age?(); end

  def manages_password_salt?(); end

  def manages_passwords?(); end

  def manages_shell?(); end

  def manages_solaris_rbac?(); end

  def satisfies?(*needed); end

  def system_users?(); end
end

module Puppet::Type::User::FeatureModule
  extend ::T::Sig
end

class Puppet::Type::User::Gid
end

class Puppet::Type::User::Gid
end

class Puppet::Type::User::Groups
  def change_to_s(currentvalue, newvalue); end

  def insync?(current); end
end

class Puppet::Type::User::Groups
end

class Puppet::Type::User::Home
end

class Puppet::Type::User::Home
end

class Puppet::Type::User::Iterations
end

class Puppet::Type::User::Iterations
end

class Puppet::Type::User::Keys
end

class Puppet::Type::User::Keys
end

class Puppet::Type::User::Loginclass
end

class Puppet::Type::User::Loginclass
end

class Puppet::Type::User::ParameterAllowdupe
  def default(); end
end

class Puppet::Type::User::ParameterAllowdupe
end

class Puppet::Type::User::ParameterAttribute_membership
  def default(); end
end

class Puppet::Type::User::ParameterAttribute_membership
end

class Puppet::Type::User::ParameterAuth_membership
  def default(); end
end

class Puppet::Type::User::ParameterAuth_membership
end

class Puppet::Type::User::ParameterForcelocal
  def default(); end
end

class Puppet::Type::User::ParameterForcelocal
end

class Puppet::Type::User::ParameterIa_load_module
end

class Puppet::Type::User::ParameterIa_load_module
end

class Puppet::Type::User::ParameterKey_membership
  def default(); end
end

class Puppet::Type::User::ParameterKey_membership
end

class Puppet::Type::User::ParameterManagehome
  def default(); end

  def unsafe_validate(val); end
end

class Puppet::Type::User::ParameterManagehome
end

class Puppet::Type::User::ParameterMembership
  def default(); end
end

class Puppet::Type::User::ParameterMembership
end

class Puppet::Type::User::ParameterName
end

class Puppet::Type::User::ParameterName
end

class Puppet::Type::User::ParameterProfile_membership
  def default(); end
end

class Puppet::Type::User::ParameterProfile_membership
end

class Puppet::Type::User::ParameterProvider
  def default(); end

  def unsafe_munge(provider); end

  def unsafe_validate(provider_class); end
end

class Puppet::Type::User::ParameterProvider
  def self.parenttype(); end

  def self.parenttype=(parenttype); end
end

class Puppet::Type::User::ParameterPurge_ssh_keys
  def default(); end
end

class Puppet::Type::User::ParameterPurge_ssh_keys
end

class Puppet::Type::User::ParameterRole_membership
  def default(); end
end

class Puppet::Type::User::ParameterRole_membership
end

class Puppet::Type::User::ParameterSystem
  def default(); end
end

class Puppet::Type::User::ParameterSystem
end

class Puppet::Type::User::Password
  def is_sensitive(); end
end

class Puppet::Type::User::Password
end

class Puppet::Type::User::Password_max_age
end

class Puppet::Type::User::Password_max_age
end

class Puppet::Type::User::Password_min_age
end

class Puppet::Type::User::Password_min_age
end

class Puppet::Type::User::Password_warn_days
end

class Puppet::Type::User::Password_warn_days
end

class Puppet::Type::User::Profiles
end

class Puppet::Type::User::Profiles
end

class Puppet::Type::User::Project
end

class Puppet::Type::User::Project
end

class Puppet::Type::User::ProviderAix
  include ::Puppet::Type::User::FeatureModule
  def add(*args); end

  def attributes(); end

  def chpasswd(*args); end

  def comment(); end

  def comment=(value); end

  def expiry(); end

  def expiry=(value); end

  def gid(); end

  def gid=(value); end

  def groups(); end

  def groups=(value); end

  def home(); end

  def home=(value); end

  def list(*args); end

  def modify(*args); end

  def parse_password(f); end

  def password(); end

  def password=(value); end

  def password_max_age(); end

  def password_max_age=(value); end

  def password_min_age(); end

  def password_min_age=(value); end

  def password_warn_days(); end

  def password_warn_days=(value); end

  def shell(); end

  def shell=(value); end

  def uid(); end

  def uid=(value); end
end

class Puppet::Type::User::ProviderAix
  extend ::Puppet::Type::User::FeatureModule
  def self.add(*args); end

  def self.chpasswd(*args); end

  def self.delete(*args); end

  def self.expires_to_expiry(provider, expires); end

  def self.expiry_to_expires(expiry); end

  def self.gid_to_pgrp(provider, gid); end

  def self.group_provider(); end

  def self.groups_attribute_to_property(provider, _groups); end

  def self.groups_property_to_attribute(groups); end

  def self.list(*args); end

  def self.modify(*args); end

  def self.pgrp_to_gid(provider, pgrp); end
end

class Puppet::Type::User::ProviderDirectoryservice
  include ::Puppet::Type::User::FeatureModule
  def allowdupe(); end

  def allowdupe=(val); end

  def assert_full_pbkdf2_password(); end

  def attribute_membership(); end

  def attribute_membership=(val); end

  def attributes(); end

  def attributes=(val); end

  def auth_membership(); end

  def auth_membership=(val); end

  def auths(); end

  def auths=(val); end

  def base64_decode_string(value); end

  def comment(); end

  def comment=(value); end

  def create(); end

  def create_attribute_with_dscl(path, username, keyname, value); end

  def create_new_user(username); end

  def delete(); end

  def dscacheutil(*args); end

  def dscl(*args); end

  def dsimport(*args); end

  def ensure(); end

  def ensure=(val); end

  def exists?(); end

  def expiry(); end

  def expiry=(val); end

  def flush_dscl_cache(); end

  def forcelocal(); end

  def forcelocal=(val); end

  def get_shadow_hash_data(users_plist); end

  def get_users_plist(username); end

  def gid(); end

  def gid=(value); end

  def groups(); end

  def groups=(value); end

  def home(); end

  def home=(value); end

  def ia_load_module(); end

  def ia_load_module=(val); end

  def iterations(); end

  def iterations=(value); end

  def key_membership(); end

  def key_membership=(val); end

  def keys(); end

  def keys=(val); end

  def loginclass(); end

  def loginclass=(val); end

  def managehome(); end

  def managehome=(val); end

  def membership(); end

  def membership=(val); end

  def merge_attribute_with_dscl(path, username, keyname, value); end

  def next_system_id(min_id=T.unsafe(nil)); end

  def password(); end

  def password=(value); end

  def password_max_age(); end

  def password_max_age=(val); end

  def password_min_age(); end

  def password_min_age=(val); end

  def password_warn_days(); end

  def password_warn_days=(val); end

  def profile_membership(); end

  def profile_membership=(val); end

  def profiles(); end

  def profiles=(val); end

  def project(); end

  def project=(val); end

  def provider(); end

  def provider=(val); end

  def purge_ssh_keys(); end

  def purge_ssh_keys=(val); end

  def role_membership(); end

  def role_membership=(val); end

  def roles(); end

  def roles=(val); end

  def salt(); end

  def salt=(value); end

  def set_attribute_with_dscl(dscl_command, path, username, keyname, value); end

  def set_salted_pbkdf2(users_plist, shadow_hash_data, field, value); end

  def set_salted_sha512(users_plist, shadow_hash_data, value); end

  def set_shadow_hash_data(users_plist, binary_plist); end

  def shell(); end

  def shell=(value); end

  def system(); end

  def system=(val); end

  def uid(); end

  def uid=(value); end

  def users_plist_dir(); end

  def uuidgen(*args); end

  def write_password_to_users_plist(value); end

  def write_to_file(filename, value); end

  def write_users_plist_to_disk(users_plist); end
end

class Puppet::Type::User::ProviderDirectoryservice
  extend ::Puppet::Type::User::FeatureModule
  def self.convert_binary_to_hash(plist_data); end

  def self.convert_hash_to_binary(plist_data); end

  def self.ds_to_ns_attribute_map(); end

  def self.dscacheutil(*args); end

  def self.dscl(*args); end

  def self.dsimport(*args); end

  def self.generate_attribute_hash(input_hash); end

  def self.get_all_users(); end

  def self.get_attribute_from_dscl(path, username, keyname); end

  def self.get_embedded_binary_plist(shadow_hash_data); end

  def self.get_list_of_groups(); end

  def self.get_os_version(); end

  def self.get_salted_sha512(embedded_binary_plist); end

  def self.get_salted_sha512_pbkdf2(field, embedded_binary_plist); end

  def self.get_sha1(guid); end

  def self.ns_to_ds_attribute_map(); end

  def self.password_hash_dir(); end

  def self.prefetch(resources); end

  def self.uuidgen(*args); end
end

class Puppet::Type::User::ProviderHpuxuseradd
  def exec_getprpw(user, opts); end

  def trusted(); end
end

class Puppet::Type::User::ProviderHpuxuseradd
end

class Puppet::Type::User::ProviderLdap
  include ::Puppet::Type::User::FeatureModule
  def allowdupe(); end

  def allowdupe=(val); end

  def attribute_membership(); end

  def attribute_membership=(val); end

  def attributes(); end

  def attributes=(val); end

  def auth_membership(); end

  def auth_membership=(val); end

  def auths(); end

  def auths=(val); end

  def comment(); end

  def comment=(val); end

  def ensure(); end

  def ensure=(val); end

  def expiry(); end

  def expiry=(val); end

  def forcelocal(); end

  def forcelocal=(val); end

  def gid(); end

  def gid=(value); end

  def group2id(group); end

  def groups(); end

  def groups=(values); end

  def home(); end

  def home=(val); end

  def ia_load_module(); end

  def ia_load_module=(val); end

  def iterations(); end

  def iterations=(val); end

  def key_membership(); end

  def key_membership=(val); end

  def keys(); end

  def keys=(val); end

  def loginclass(); end

  def loginclass=(val); end

  def managehome(); end

  def managehome=(val); end

  def membership(); end

  def membership=(val); end

  def password(); end

  def password=(val); end

  def password_max_age(); end

  def password_max_age=(val); end

  def password_min_age(); end

  def password_min_age=(val); end

  def password_warn_days(); end

  def password_warn_days=(val); end

  def profile_membership(); end

  def profile_membership=(val); end

  def profiles(); end

  def profiles=(val); end

  def project(); end

  def project=(val); end

  def provider(); end

  def provider=(val); end

  def purge_ssh_keys(); end

  def purge_ssh_keys=(val); end

  def role_membership(); end

  def role_membership=(val); end

  def roles(); end

  def roles=(val); end

  def salt(); end

  def salt=(val); end

  def shell(); end

  def shell=(val); end

  def system(); end

  def system=(val); end

  def uid(); end

  def uid=(val); end
end

class Puppet::Type::User::ProviderLdap
  extend ::Puppet::Type::User::FeatureModule
end

class Puppet::Type::User::ProviderOpenbsd
  def loginclass=(value); end
end

class Puppet::Type::User::ProviderOpenbsd
end

class Puppet::Type::User::ProviderPw
  include ::Puppet::Type::User::FeatureModule
  def addcmd(); end

  def attributes(); end

  def attributes=(*vals); end

  def auths(); end

  def auths=(*vals); end

  def comment(); end

  def comment=(*vals); end

  def expiry(); end

  def expiry=(*vals); end

  def gid(); end

  def gid=(*vals); end

  def groups=(*vals); end

  def home(); end

  def home=(*vals); end

  def iterations(); end

  def iterations=(*vals); end

  def keys(); end

  def keys=(*vals); end

  def loginclass(); end

  def loginclass=(*vals); end

  def password(); end

  def password=(cryptopw); end

  def password_max_age(); end

  def password_max_age=(*vals); end

  def password_min_age(); end

  def password_min_age=(*vals); end

  def password_warn_days(); end

  def password_warn_days=(*vals); end

  def profiles(); end

  def profiles=(*vals); end

  def project(); end

  def project=(*vals); end

  def pw(*args); end

  def roles(); end

  def roles=(*vals); end

  def salt(); end

  def salt=(*vals); end

  def shell(); end

  def shell=(*vals); end

  def uid(); end

  def uid=(*vals); end
end

class Puppet::Type::User::ProviderPw
  extend ::Puppet::Type::User::FeatureModule
  def self.pw(*args); end
end

class Puppet::Type::User::ProviderUser_role_add
  def build_keys_cmd(keys_hash); end

  def command(cmd); end

  def create_role(); end

  def destroy(); end

  def flush(); end

  def is_role?(); end

  def keys=(keys_hash); end

  def managed_attributes(); end

  def password=(cryptopw); end

  def remove_managed_attributes(); end

  def role_add(*args); end

  def role_delete(*args); end

  def role_modify(*args); end

  def run(cmd, msg); end

  def shadow_entry(); end

  def transition(type); end

  def user_attributes(); end
end

class Puppet::Type::User::ProviderUser_role_add
  def self.role_add(*args); end

  def self.role_delete(*args); end

  def self.role_modify(*args); end
end

class Puppet::Type::User::ProviderUseradd
  include ::Puppet::Type::User::FeatureModule
  def add(*args); end

  def add_properties(); end

  def addcmd(); end

  def attributes(); end

  def attributes=(*vals); end

  def auths(); end

  def auths=(*vals); end

  def check_allow_dup(); end

  def check_manage_home(); end

  def check_system_users(); end

  def check_valid_shell(); end

  def comment(); end

  def comment=(*vals); end

  def expiry(); end

  def expiry=(*vals); end

  def finduser(key, value); end

  def gid(); end

  def gid=(*vals); end

  def groups=(*vals); end

  def groups?(); end

  def home(); end

  def home=(*vals); end

  def iterations(); end

  def iterations=(*vals); end

  def keys(); end

  def keys=(*vals); end

  def local_username(); end

  def localadd(*args); end

  def localdelete(*args); end

  def localmodify(*args); end

  def localpassword(*args); end

  def localuid(); end

  def loginclass(); end

  def loginclass=(*vals); end

  def modify(*args); end

  def modifycmd(param, value); end

  def passcmd(); end

  def password(); end

  def password=(*vals); end

  def password_max_age(); end

  def password_max_age=(*vals); end

  def password_min_age(); end

  def password_min_age=(*vals); end

  def password_warn_days(); end

  def password_warn_days=(*vals); end

  def profiles(); end

  def profiles=(*vals); end

  def project(); end

  def project=(*vals); end

  def property_manages_password_age?(property); end

  def roles(); end

  def roles=(*vals); end

  def salt(); end

  def salt=(*vals); end

  def shell(); end

  def shell=(value); end

  def uid(); end

  def uid=(*vals); end
end

class Puppet::Type::User::ProviderUseradd
  extend ::Puppet::Type::User::FeatureModule
  def self.add(*args); end

  def self.delete(*args); end

  def self.localadd(*args); end

  def self.localdelete(*args); end

  def self.localmodify(*args); end

  def self.localpassword(*args); end

  def self.modify(*args); end

  def self.password(*args); end
end

class Puppet::Type::User::ProviderWindows_adsi
  include ::Puppet::Type::User::FeatureModule
  def comment(); end

  def comment=(value); end

  def create(); end

  def delete(); end

  def exists?(); end

  def flush(); end

  def gid(); end

  def gid=(v); end

  def groups(); end

  def groups=(groups); end

  def groups_insync?(current, should); end

  def groups_to_s(groups); end

  def home(); end

  def home=(value); end

  def initialize(value=T.unsafe(nil)); end

  def password(); end

  def password=(value); end

  def shell(); end

  def shell=(v); end

  def uid(); end

  def uid=(value); end

  def user(); end
end

class Puppet::Type::User::ProviderWindows_adsi
  extend ::Puppet::Type::User::FeatureModule
end

class Puppet::Type::User::Roles
end

class Puppet::Type::User::Roles
end

class Puppet::Type::User::Salt
end

class Puppet::Type::User::Salt
end

class Puppet::Type::User::Shell
end

class Puppet::Type::User::Shell
end

class Puppet::Type::User::Uid
end

class Puppet::Type::User::Uid
end

class Puppet::Type::User
end

class Puppet::Type::Whit
  def refresh(); end
end

class Puppet::Type::Whit::ParameterName
end

class Puppet::Type::Whit::ParameterName
end

class Puppet::Type::Whit
end

class Puppet::Type
  def self.newa2mod(*args); end

  def self.newcomponent(*args); end

  def self.newexec(*args); end

  def self.newfile(*args); end

  def self.newfilebucket(*args); end

  def self.newgroup(*args); end

  def self.newnotify(*args); end

  def self.newpackage(*args); end

  def self.newresources(*args); end

  def self.newschedule(*args); end

  def self.newservice(*args); end

  def self.newstage(*args); end

  def self.newtidy(*args); end

  def self.newusee_type(*args); end

  def self.newuser(*args); end

  def self.newwhit(*args); end
end

module Puppet::Util::AtFork
  extend ::T::Sig
end

module Puppet::Util::Backups
  extend ::T::Sig
end

module Puppet::Util::CharacterEncoding
  extend ::T::Sig
end

module Puppet::Util::Checksums
  extend ::T::Sig
end

module Puppet::Util::ClassGen
  extend ::T::Sig
end

module Puppet::Util::Colors
  extend ::T::Sig
end

module Puppet::Util::CommandLine::Trollop
  extend ::T::Sig
end

module Puppet::Util::Connection
  extend ::T::Sig
end

module Puppet::Util::ConstantInflector
  extend ::T::Sig
end

module Puppet::Util::Diff
  extend ::T::Sig
end

module Puppet::Util::Docs
  extend ::T::Sig
end

module Puppet::Util::Errors
  extend ::T::Sig
end

module Puppet::Util::Execution
  extend ::T::Sig
end

class Puppet::Util::FileNamespaceAdapter
  def file_to_namespace(); end

  def file_to_namespace=(file_to_namespace); end
end

class Puppet::Util::FileNamespaceAdapter
end

module Puppet::Util::FileParsing
  extend ::T::Sig
end

class Puppet::Util::FileType::FileTypeAixtab
  def read(); end

  def real_read(); end

  def real_write(text); end

  def remove(); end

  def write(text); end
end

class Puppet::Util::FileType::FileTypeAixtab
end

class Puppet::Util::FileType::FileTypeCrontab
  def initialize(user); end

  def path=(user); end

  def read(); end

  def real_read(); end

  def real_write(text); end

  def remove(); end

  def write(text); end
end

class Puppet::Util::FileType::FileTypeCrontab
end

class Puppet::Util::FileType::FileTypeFlat
  def backup(); end

  def read(); end

  def real_read(); end

  def real_write(text); end

  def remove(); end

  def write(text); end
end

class Puppet::Util::FileType::FileTypeFlat
end

class Puppet::Util::FileType::FileTypeRam
  def read(); end

  def real_read(); end

  def real_write(text); end

  def remove(); end

  def write(text); end
end

class Puppet::Util::FileType::FileTypeRam
  def self.clear(); end
end

class Puppet::Util::FileType::FileTypeSuntab
  def read(); end

  def real_read(); end

  def real_write(text); end

  def remove(); end

  def write(text); end
end

class Puppet::Util::FileType::FileTypeSuntab
end

module Puppet::Util::HttpProxy
  extend ::T::Sig
end

module Puppet::Util::IniConfig
  extend ::T::Sig
end

module Puppet::Util::InstanceLoader
  extend ::T::Sig
end

module Puppet::Util::Json
  extend ::T::Sig
end

module Puppet::Util::Ldap
  extend ::T::Sig
end

module Puppet::Util::Libuser
  extend ::T::Sig
end

module Puppet::Util::Limits
  extend ::T::Sig
end

class Puppet::Util::Log::DestArray
  def handle(msg); end

  def initialize(messages); end
end

class Puppet::Util::Log::DestArray
end

class Puppet::Util::Log::DestConsole
  include ::Puppet::Util::Colors
  def handle(msg); end
end

class Puppet::Util::Log::DestConsole
end

class Puppet::Util::Log::DestEventlog
  def close(); end

  def handle(msg); end

  def to_native(level); end
end

class Puppet::Util::Log::DestEventlog
  def self.suitable?(obj); end
end

class Puppet::Util::Log::DestFile
  def autoflush(); end

  def autoflush=(autoflush); end

  def close(); end

  def flush(); end

  def handle(msg); end

  def initialize(path); end
end

class Puppet::Util::Log::DestFile
end

class Puppet::Util::Log::DestLogstash_event
  def format(msg); end

  def handle(msg); end
end

class Puppet::Util::Log::DestLogstash_event
end

class Puppet::Util::Log::DestReport
  def handle(msg); end

  def initialize(report); end

  def report(); end
end

class Puppet::Util::Log::DestReport
end

class Puppet::Util::Log::DestSyslog
  def close(); end

  def handle(msg); end
end

class Puppet::Util::Log::DestSyslog
  def self.suitable?(obj); end
end

class Puppet::Util::Log
  def self.autoflush=(v); end

  def self.close(destination); end

  def self.create(hash); end

  def self.destinations(); end

  def self.eachlevel(); end

  def self.flush(); end

  def self.flushqueue(); end

  def self.force_flushqueue(); end

  def self.level(); end

  def self.level=(level); end

  def self.levels(); end

  def self.newdestination(dest); end

  def self.newmessage(msg); end

  def self.queuemessage(msg); end

  def self.reopen(); end

  def self.sendlevel?(level); end

  def self.with_destination(destination, &block); end
end

module Puppet::Util::Logging
  def alert(args); end

  def crit(args); end

  def emerg(args); end

  def err(args); end

  def info(args); end

  def notice(args); end

  def warning(args); end
end

module Puppet::Util::Logging
  extend ::T::Sig
end

module Puppet::Util::MonkeyPatches
  extend ::T::Sig
end

module Puppet::Util::NetworkDevice::Transport
  extend ::T::Sig
end

module Puppet::Util::POSIX
  extend ::T::Sig
end

module Puppet::Util::Package
  extend ::T::Sig
end

module Puppet::Util::Platform
  extend ::T::Sig
end

module Puppet::Util::Plist
  extend ::T::Sig
end

module Puppet::Util::Profiler
  extend ::T::Sig
end

module Puppet::Util::ProviderFeatures
  extend ::T::Sig
end

module Puppet::Util::PsychSupport
  extend ::T::Sig
end

module Puppet::Util::RDoc
  extend ::T::Sig
end

class Puppet::Util::Reference
  def self.reference(name); end
end

module Puppet::Util::RetryAction
  extend ::T::Sig
end

module Puppet::Util::RubyGems
  extend ::T::Sig
end

module Puppet::Util::SELinux
  extend ::T::Sig
end

module Puppet::Util::SSL
  extend ::T::Sig
end

module Puppet::Util::SUIDManager
  extend ::T::Sig
  def self.egid(*args, &block); end

  def self.egid=(*args, &block); end

  def self.euid(*args, &block); end

  def self.euid=(*args, &block); end

  def self.gid(*args, &block); end

  def self.gid=(*args, &block); end

  def self.groups(*args, &block); end

  def self.uid(*args, &block); end

  def self.uid=(*args, &block); end
end

module Puppet::Util::Splayer
  extend ::T::Sig
end

class Puppet::Util::Storage
  def self.instance(); end
end

module Puppet::Util::SymbolicFileMode
  extend ::T::Sig
end

module Puppet::Util::Tagging
  extend ::T::Sig
end

module Puppet::Util::Terminal
  extend ::T::Sig
end

module Puppet::Util::Warnings
  extend ::T::Sig
end

module Puppet::Util::Watcher::Common
  extend ::T::Sig
end

module Puppet::Util::Watcher
  extend ::T::Sig
end

module Puppet::Util::Windows::ADSI
  extend ::T::Sig
end

module Puppet::Util::Windows::File
  extend ::T::Sig
end

module Puppet::Util::Windows::Registry
  extend ::T::Sig
end

module Puppet::Util::Windows::SID
  extend ::T::Sig
end

module Puppet::Util::Windows::String
  extend ::T::Sig
end

module Puppet::Util::Windows
  extend ::T::Sig
end

module Puppet::Util::Yaml
  extend ::T::Sig
end

module Puppet::Util
  extend ::T::Sig
end

module Puppet::X509::PemStore
  extend ::T::Sig
end

module Puppet::X509
  extend ::T::Sig
end

module Puppet
  extend ::T::Sig
end

module PuppetSpec::CharacterEncoding
  extend ::T::Sig
end

module PuppetSpec::Compiler
  extend ::T::Sig
end

module PuppetSpec::Files
  extend ::T::Sig
end

module PuppetSpec::Fixtures
  extend ::T::Sig
end

module PuppetSpec::Language
  extend ::T::Sig
end

module PuppetSpec::ModuleTool::SharedFunctions
  extend ::T::Sig
end

module PuppetSpec::ModuleTool
  extend ::T::Sig
end

module PuppetSpec::Modules
  extend ::T::Sig
end

module PuppetSpec::Pops
  def have_any_issues(*expected, &block_arg); end

  def have_issue(*expected, &block_arg); end
end

module PuppetSpec::Pops
  extend ::T::Sig
end

module PuppetSpec::SSL
  extend ::T::Sig
end

module PuppetSpec::Scope
  extend ::T::Sig
end

module PuppetSpec::Settings
  extend ::T::Sig
end

module PuppetSpec
  extend ::T::Sig
end

module PuppetX::Acceptance
  extend ::T::Sig
end

module PuppetX
  extend ::T::Sig
end

Queue = Thread::Queue

module RDoc::AddClassModuleComment
  extend ::T::Sig
end

module RDoc::Encoding
  extend ::T::Sig
end

module RDoc::Generator::Markup
  extend ::T::Sig
end

module RDoc::Generator
  extend ::T::Sig
end

module RDoc::I18n
  extend ::T::Sig
end

class RDoc::Markdown
  def break_on_newline=(enable); end

  def break_on_newline?(); end

  def css=(enable); end

  def css?(); end

  def definition_lists=(enable); end

  def definition_lists?(); end

  def github=(enable); end

  def github?(); end

  def html=(enable); end

  def html?(); end

  def notes=(enable); end

  def notes?(); end

  def strike=(enable); end

  def strike?(); end
end

class RDoc::Markup::AttrChanger
  def self.[](*_); end

  def self.members(); end
end

class RDoc::Markup::Formatter::InlineTag
  def self.[](*_); end

  def self.members(); end
end

class RDoc::Markup::Heading
  def self.[](*_); end

  def self.members(); end
end

module RDoc::Page
  extend ::T::Sig
end

class RDoc::Parser::RipperStateLex::InnerStateLex
end

class RDoc::Parser::RipperStateLex::Token
  def self.[](*_); end

  def self.members(); end
end

module RDoc::Parser::RubyTools
  extend ::T::Sig
end

module RDoc::Parser::Text
  extend ::T::Sig
end

module RDoc::PuppetParserCore
  extend ::T::Sig
end

class RDoc::PuppetParserRDoc2
  def input_file_name(); end

  def input_file_name=(input_file_name); end

  def top_level(); end

  def top_level=(top_level); end
end

module RDoc::PuppetTopLevel
  extend ::T::Sig
end

module RDoc::RI::Paths
  extend ::T::Sig
end

module RDoc::RI
  extend ::T::Sig
end

module RDoc::Text
  extend ::T::Sig
end

module RDoc::TokenStream
  extend ::T::Sig
end

module RDoc
  extend ::T::Sig
end

module REXML
  COPYRIGHT = ::T.let(nil, ::T.untyped)
  Copyright = ::T.let(nil, ::T.untyped)
  DATE = ::T.let(nil, ::T.untyped)
  REVISION = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class REXML::AttlistDecl
  include ::Enumerable
  def [](key); end

  def each(&block); end

  def element_name(); end

  def include?(key); end

  def initialize(source); end

  def node_type(); end

  def write(out, indent=T.unsafe(nil)); end
end

class REXML::AttlistDecl
end

class REXML::Attribute
  include ::REXML::Node
  include ::REXML::Namespace
  include ::REXML::XMLTokens
  def ==(other); end

  def doctype(); end

  def element(); end

  def element=(element); end

  def initialize(first, second=T.unsafe(nil), parent=T.unsafe(nil)); end

  def namespace(arg=T.unsafe(nil)); end

  def node_type(); end

  def normalized=(normalized); end

  def remove(); end

  def to_s(); end

  def to_string(); end

  def value(); end

  def write(output, indent=T.unsafe(nil)); end

  def xpath(); end
  NEEDS_A_SECOND_CHECK = ::T.let(nil, ::T.untyped)
  PATTERN = ::T.let(nil, ::T.untyped)
end

class REXML::Attribute
end

class REXML::Attributes
  def <<(attribute); end

  def [](name); end

  def []=(name, value); end

  def add(attribute); end

  def delete(attribute); end

  def delete_all(name); end

  def each_attribute(); end

  def get_attribute(name); end

  def get_attribute_ns(namespace, name); end

  def initialize(element); end

  def namespaces(); end

  def prefixes(); end
end

class REXML::Attributes
end

class REXML::CData
  def initialize(first, whitespace=T.unsafe(nil), parent=T.unsafe(nil)); end

  def write(output=T.unsafe(nil), indent=T.unsafe(nil), transitive=T.unsafe(nil), ie_hack=T.unsafe(nil)); end
  ILLEGAL = ::T.let(nil, ::T.untyped)
  START = ::T.let(nil, ::T.untyped)
  STOP = ::T.let(nil, ::T.untyped)
end

class REXML::CData
end

class REXML::Child
  include ::REXML::Node
  def bytes(); end

  def document(); end

  def initialize(parent=T.unsafe(nil)); end

  def next_sibling(); end

  def next_sibling=(other); end

  def parent(); end

  def parent=(other); end

  def previous_sibling(); end

  def previous_sibling=(other); end

  def remove(); end

  def replace_with(child); end
end

class REXML::Child
end

class REXML::Comment
  include ::Comparable
  def ==(other); end

  def initialize(first, second=T.unsafe(nil)); end

  def node_type(); end

  def string(); end

  def string=(string); end

  def to_s(); end

  def write(output, indent=T.unsafe(nil), transitive=T.unsafe(nil), ie_hack=T.unsafe(nil)); end
  START = ::T.let(nil, ::T.untyped)
  STOP = ::T.let(nil, ::T.untyped)
end

class REXML::Comment
end

class REXML::Declaration
  def initialize(src); end

  def to_s(); end

  def write(output, indent); end
end

class REXML::Declaration
end

class REXML::DocType
  include ::REXML::XMLTokens
  def add(child); end

  def attribute_of(element, attribute); end

  def attributes_of(element); end

  def context(); end

  def entities(); end

  def entity(name); end

  def external_id(); end

  def initialize(first, parent=T.unsafe(nil)); end

  def name(); end

  def namespaces(); end

  def node_type(); end

  def notation(name); end

  def notations(); end

  def public(); end

  def system(); end

  def write(output, indent=T.unsafe(nil), transitive=T.unsafe(nil), ie_hack=T.unsafe(nil)); end
  DEFAULT_ENTITIES = ::T.let(nil, ::T.untyped)
  PUBLIC = ::T.let(nil, ::T.untyped)
  START = ::T.let(nil, ::T.untyped)
  STOP = ::T.let(nil, ::T.untyped)
  SYSTEM = ::T.let(nil, ::T.untyped)
end

class REXML::DocType
end

class REXML::Document
  def <<(child); end

  def add(child); end

  def add_element(arg=T.unsafe(nil), arg2=T.unsafe(nil)); end

  def doctype(); end

  def encoding(); end

  def entity_expansion_count(); end

  def initialize(source=T.unsafe(nil), context=T.unsafe(nil)); end

  def record_entity_expansion(); end

  def stand_alone?(); end

  def version(); end

  def write(*arguments); end

  def xml_decl(); end
  DECLARATION = ::T.let(nil, ::T.untyped)
end

class REXML::Document
  def self.entity_expansion_limit(); end

  def self.entity_expansion_limit=(val); end

  def self.entity_expansion_text_limit(); end

  def self.entity_expansion_text_limit=(val); end

  def self.parse_stream(source, listener); end
end

class REXML::Element
  include ::REXML::Namespace
  include ::REXML::XMLTokens
  def add_attribute(key, value=T.unsafe(nil)); end

  def add_attributes(hash); end

  def add_element(element, attrs=T.unsafe(nil)); end

  def add_namespace(prefix, uri=T.unsafe(nil)); end

  def add_text(text); end

  def attribute(name, namespace=T.unsafe(nil)); end

  def attributes(); end

  def cdatas(); end

  def comments(); end

  def context(); end

  def context=(context); end

  def delete_attribute(key); end

  def delete_element(element); end

  def delete_namespace(namespace=T.unsafe(nil)); end

  def each_element(xpath=T.unsafe(nil), &block); end

  def each_element_with_attribute(key, value=T.unsafe(nil), max=T.unsafe(nil), name=T.unsafe(nil), &block); end

  def each_element_with_text(text=T.unsafe(nil), max=T.unsafe(nil), name=T.unsafe(nil), &block); end

  def elements(); end

  def get_elements(xpath); end

  def get_text(path=T.unsafe(nil)); end

  def has_attributes?(); end

  def has_elements?(); end

  def has_text?(); end

  def ignore_whitespace_nodes(); end

  def initialize(arg=T.unsafe(nil), parent=T.unsafe(nil), context=T.unsafe(nil)); end

  def instructions(); end

  def namespace(prefix=T.unsafe(nil)); end

  def namespaces(); end

  def next_element(); end

  def node_type(); end

  def prefixes(); end

  def previous_element(); end

  def raw(); end

  def root(); end

  def root_node(); end

  def text(path=T.unsafe(nil)); end

  def text=(text); end

  def texts(); end

  def whitespace(); end

  def write(output=T.unsafe(nil), indent=T.unsafe(nil), transitive=T.unsafe(nil), ie_hack=T.unsafe(nil)); end

  def xpath(); end
  UNDEFINED = ::T.let(nil, ::T.untyped)
end

class REXML::Element
end

class REXML::ElementDecl
end

class REXML::ElementDecl
end

class REXML::Elements
  include ::Enumerable
  def <<(element=T.unsafe(nil)); end

  def [](index, name=T.unsafe(nil)); end

  def []=(index, element); end

  def add(element=T.unsafe(nil)); end

  def collect(xpath=T.unsafe(nil)); end

  def delete(element); end

  def delete_all(xpath); end

  def each(xpath=T.unsafe(nil)); end

  def empty?(); end

  def index(element); end

  def initialize(parent); end

  def inject(xpath=T.unsafe(nil), initial=T.unsafe(nil)); end

  def size(); end

  def to_a(xpath=T.unsafe(nil)); end
end

class REXML::Elements
end

module REXML::Encoding
  def decode(string); end

  def encode(string); end

  def encoding(); end

  def encoding=(encoding); end
end

module REXML::Encoding
  extend ::T::Sig
end

class REXML::Entity
  include ::REXML::XMLTokens
  def external(); end

  def initialize(stream, value=T.unsafe(nil), parent=T.unsafe(nil), reference=T.unsafe(nil)); end

  def name(); end

  def ndata(); end

  def normalized(); end

  def pubid(); end

  def ref(); end

  def to_s(); end

  def unnormalized(); end

  def value(); end

  def write(out, indent=T.unsafe(nil)); end
  ENTITYDECL = ::T.let(nil, ::T.untyped)
  ENTITYDEF = ::T.let(nil, ::T.untyped)
  ENTITYVALUE = ::T.let(nil, ::T.untyped)
  EXTERNALID = ::T.let(nil, ::T.untyped)
  GEDECL = ::T.let(nil, ::T.untyped)
  NDATADECL = ::T.let(nil, ::T.untyped)
  PEDECL = ::T.let(nil, ::T.untyped)
  PEDEF = ::T.let(nil, ::T.untyped)
  PEREFERENCE = ::T.let(nil, ::T.untyped)
  PEREFERENCE_RE = ::T.let(nil, ::T.untyped)
  PUBIDCHAR = ::T.let(nil, ::T.untyped)
  PUBIDLITERAL = ::T.let(nil, ::T.untyped)
  SYSTEMLITERAL = ::T.let(nil, ::T.untyped)
end

class REXML::Entity
  def self.matches?(string); end
end

module REXML::EntityConst
  AMP = ::T.let(nil, ::T.untyped)
  APOS = ::T.let(nil, ::T.untyped)
  GT = ::T.let(nil, ::T.untyped)
  LT = ::T.let(nil, ::T.untyped)
  QUOT = ::T.let(nil, ::T.untyped)
end

module REXML::EntityConst
  extend ::T::Sig
end

class REXML::ExternalEntity
  def initialize(src); end

  def to_s(); end

  def write(output, indent); end
end

class REXML::ExternalEntity
end

module REXML::Formatters
end

class REXML::Formatters::Default
  def initialize(ie_hack=T.unsafe(nil)); end

  def write(node, output); end

  def write_cdata(node, output); end

  def write_comment(node, output); end

  def write_document(node, output); end

  def write_element(node, output); end

  def write_instruction(node, output); end

  def write_text(node, output); end
end

class REXML::Formatters::Default
end

class REXML::Formatters::Pretty
  def compact(); end

  def compact=(compact); end

  def initialize(indentation=T.unsafe(nil), ie_hack=T.unsafe(nil)); end

  def width(); end

  def width=(width); end
end

class REXML::Formatters::Pretty
end

module REXML::Formatters
  extend ::T::Sig
end

module REXML::Functions
  INTERNAL_METHODS = ::T.let(nil, ::T.untyped)
end

module REXML::Functions
  extend ::T::Sig
  def self.boolean(object=T.unsafe(nil)); end

  def self.ceiling(number); end

  def self.compare_language(lang1, lang2); end

  def self.concat(*objects); end

  def self.contains(string, test); end

  def self.context=(value); end

  def self.count(node_set); end

  def self.false(); end

  def self.floor(number); end

  def self.get_namespace(node_set=T.unsafe(nil)); end

  def self.id(object); end

  def self.lang(language); end

  def self.last(); end

  def self.local_name(node_set=T.unsafe(nil)); end

  def self.name(node_set=T.unsafe(nil)); end

  def self.namespace_context(); end

  def self.namespace_context=(x); end

  def self.namespace_uri(node_set=T.unsafe(nil)); end

  def self.normalize_space(string=T.unsafe(nil)); end

  def self.not(object); end

  def self.number(object=T.unsafe(nil)); end

  def self.position(); end

  def self.processing_instruction(node); end

  def self.round(number); end

  def self.send(name, *args); end

  def self.singleton_method_added(name); end

  def self.starts_with(string, test); end

  def self.string(object=T.unsafe(nil)); end

  def self.string_length(string); end

  def self.string_value(o); end

  def self.substring(string, start, length=T.unsafe(nil)); end

  def self.substring_after(string, test); end

  def self.substring_before(string, test); end

  def self.sum(nodes); end

  def self.text(); end

  def self.translate(string, tr1, tr2); end

  def self.true(); end

  def self.variables(); end

  def self.variables=(x); end
end

class REXML::IOSource
  def initialize(arg, block_size=T.unsafe(nil), encoding=T.unsafe(nil)); end
end

class REXML::IOSource
end

class REXML::Instruction
  def ==(other); end

  def content(); end

  def content=(content); end

  def initialize(target, content=T.unsafe(nil)); end

  def node_type(); end

  def target(); end

  def target=(target); end

  def write(writer, indent=T.unsafe(nil), transitive=T.unsafe(nil), ie_hack=T.unsafe(nil)); end
  START = ::T.let(nil, ::T.untyped)
  STOP = ::T.let(nil, ::T.untyped)
end

class REXML::Instruction
end

module REXML::Namespace
  include ::REXML::XMLTokens
  def expanded_name(); end

  def fully_expanded_name(); end

  def has_name?(other, ns=T.unsafe(nil)); end

  def local_name(); end

  def name(); end

  def name=(name); end

  def prefix(); end

  def prefix=(prefix); end
  NAMESPLIT = ::T.let(nil, ::T.untyped)
end

module REXML::Namespace
  extend ::T::Sig
end

module REXML::Node
  def each_recursive(&block); end

  def find_first_recursive(&block); end

  def indent(to, ind); end

  def index_in_parent(); end

  def next_sibling_node(); end

  def parent?(); end

  def previous_sibling_node(); end

  def to_s(indent=T.unsafe(nil)); end
end

module REXML::Node
  extend ::T::Sig
end

class REXML::NotationDecl
  def initialize(name, middle, pub, sys); end

  def name(); end

  def public(); end

  def public=(public); end

  def system(); end

  def system=(system); end

  def to_s(); end

  def write(output, indent=T.unsafe(nil)); end
end

class REXML::NotationDecl
end

class REXML::Output
  include ::REXML::Encoding
  def <<(content); end

  def initialize(real_IO, encd=T.unsafe(nil)); end
end

class REXML::Output
end

class REXML::Parent
  include ::Enumerable
  def <<(object); end

  def [](index); end

  def []=(*args); end

  def add(object); end

  def children(); end

  def deep_clone(); end

  def delete(object); end

  def delete_at(index); end

  def delete_if(&block); end

  def each(&block); end

  def each_child(&block); end

  def each_index(&block); end

  def index(child); end

  def insert_after(child1, child2); end

  def insert_before(child1, child2); end

  def length(); end

  def push(object); end

  def replace_child(to_replace, replacement); end

  def size(); end

  def to_a(); end

  def unshift(object); end
end

class REXML::Parent
end

class REXML::ParseException
  def context(); end

  def continued_exception(); end

  def continued_exception=(continued_exception); end

  def initialize(message, source=T.unsafe(nil), parser=T.unsafe(nil), exception=T.unsafe(nil)); end

  def line(); end

  def parser(); end

  def parser=(parser); end

  def position(); end

  def source(); end

  def source=(source); end
end

class REXML::ParseException
end

module REXML::Parsers
end

class REXML::Parsers::BaseParser
  def add_listener(listener); end

  def empty?(); end

  def entity(reference, entities); end

  def has_next?(); end

  def initialize(source); end

  def normalize(input, entities=T.unsafe(nil), entity_filter=T.unsafe(nil)); end

  def peek(depth=T.unsafe(nil)); end

  def position(); end

  def pull(); end

  def source(); end

  def stream=(source); end

  def unnormalize(string, entities=T.unsafe(nil), filter=T.unsafe(nil)); end

  def unshift(token); end
  ATTDEF = ::T.let(nil, ::T.untyped)
  ATTDEF_RE = ::T.let(nil, ::T.untyped)
  ATTLISTDECL_PATTERN = ::T.let(nil, ::T.untyped)
  ATTLISTDECL_START = ::T.let(nil, ::T.untyped)
  ATTRIBUTE_PATTERN = ::T.let(nil, ::T.untyped)
  ATTTYPE = ::T.let(nil, ::T.untyped)
  ATTVALUE = ::T.let(nil, ::T.untyped)
  CDATA_END = ::T.let(nil, ::T.untyped)
  CDATA_PATTERN = ::T.let(nil, ::T.untyped)
  CDATA_START = ::T.let(nil, ::T.untyped)
  CLOSE_MATCH = ::T.let(nil, ::T.untyped)
  COMBININGCHAR = ::T.let(nil, ::T.untyped)
  COMMENT_PATTERN = ::T.let(nil, ::T.untyped)
  COMMENT_START = ::T.let(nil, ::T.untyped)
  DEFAULTDECL = ::T.let(nil, ::T.untyped)
  DEFAULT_ENTITIES = ::T.let(nil, ::T.untyped)
  DIGIT = ::T.let(nil, ::T.untyped)
  DOCTYPE_END = ::T.let(nil, ::T.untyped)
  DOCTYPE_PATTERN = ::T.let(nil, ::T.untyped)
  DOCTYPE_START = ::T.let(nil, ::T.untyped)
  ELEMENTDECL_PATTERN = ::T.let(nil, ::T.untyped)
  ELEMENTDECL_START = ::T.let(nil, ::T.untyped)
  ENCODING = ::T.let(nil, ::T.untyped)
  ENTITYDECL = ::T.let(nil, ::T.untyped)
  ENTITYDEF = ::T.let(nil, ::T.untyped)
  ENTITYVALUE = ::T.let(nil, ::T.untyped)
  ENTITY_START = ::T.let(nil, ::T.untyped)
  ENUMERATEDTYPE = ::T.let(nil, ::T.untyped)
  ENUMERATION = ::T.let(nil, ::T.untyped)
  EREFERENCE = ::T.let(nil, ::T.untyped)
  EXTENDER = ::T.let(nil, ::T.untyped)
  EXTERNALID = ::T.let(nil, ::T.untyped)
  GEDECL = ::T.let(nil, ::T.untyped)
  IDENTITY = ::T.let(nil, ::T.untyped)
  INSTRUCTION_PATTERN = ::T.let(nil, ::T.untyped)
  INSTRUCTION_START = ::T.let(nil, ::T.untyped)
  LETTER = ::T.let(nil, ::T.untyped)
  MISSING_ATTRIBUTE_QUOTES = ::T.let(nil, ::T.untyped)
  NAME = ::T.let(nil, ::T.untyped)
  NAMECHAR = ::T.let(nil, ::T.untyped)
  NAME_STR = ::T.let(nil, ::T.untyped)
  NCNAME_STR = ::T.let(nil, ::T.untyped)
  NDATADECL = ::T.let(nil, ::T.untyped)
  NMTOKEN = ::T.let(nil, ::T.untyped)
  NMTOKENS = ::T.let(nil, ::T.untyped)
  NOTATIONDECL_START = ::T.let(nil, ::T.untyped)
  NOTATIONTYPE = ::T.let(nil, ::T.untyped)
  PEDECL = ::T.let(nil, ::T.untyped)
  PEDEF = ::T.let(nil, ::T.untyped)
  PEREFERENCE = ::T.let(nil, ::T.untyped)
  PUBIDCHAR = ::T.let(nil, ::T.untyped)
  PUBIDLITERAL = ::T.let(nil, ::T.untyped)
  PUBLIC = ::T.let(nil, ::T.untyped)
  REFERENCE = ::T.let(nil, ::T.untyped)
  REFERENCE_RE = ::T.let(nil, ::T.untyped)
  STANDALONE = ::T.let(nil, ::T.untyped)
  SYSTEM = ::T.let(nil, ::T.untyped)
  SYSTEMENTITY = ::T.let(nil, ::T.untyped)
  SYSTEMLITERAL = ::T.let(nil, ::T.untyped)
  TAG_MATCH = ::T.let(nil, ::T.untyped)
  TEXT_PATTERN = ::T.let(nil, ::T.untyped)
  UNAME_STR = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  XMLDECL_PATTERN = ::T.let(nil, ::T.untyped)
  XMLDECL_START = ::T.let(nil, ::T.untyped)
end

class REXML::Parsers::BaseParser
end

class REXML::Parsers::StreamParser
  def add_listener(listener); end

  def initialize(source, listener); end

  def parse(); end
end

class REXML::Parsers::StreamParser
end

class REXML::Parsers::TreeParser
  def add_listener(listener); end

  def initialize(source, build_context=T.unsafe(nil)); end

  def parse(); end
end

class REXML::Parsers::TreeParser
end

class REXML::Parsers::XPathParser
  include ::REXML::XMLTokens
  def abbreviate(path); end

  def expand(path); end

  def namespaces=(namespaces); end

  def parse(path); end

  def predicate(path); end

  def predicate_to_string(path, &block); end
  AXIS = ::T.let(nil, ::T.untyped)
  LITERAL = ::T.let(nil, ::T.untyped)
  NCNAMETEST = ::T.let(nil, ::T.untyped)
  NODE_TYPE = ::T.let(nil, ::T.untyped)
  NT = ::T.let(nil, ::T.untyped)
  NUMBER = ::T.let(nil, ::T.untyped)
  PI = ::T.let(nil, ::T.untyped)
  QNAME = ::T.let(nil, ::T.untyped)
  VARIABLE_REFERENCE = ::T.let(nil, ::T.untyped)
end

class REXML::Parsers::XPathParser
end

module REXML::Parsers
  extend ::T::Sig
end

module REXML::Security
end

module REXML::Security
  extend ::T::Sig
  def self.entity_expansion_limit(); end

  def self.entity_expansion_limit=(val); end

  def self.entity_expansion_text_limit(); end

  def self.entity_expansion_text_limit=(val); end
end

class REXML::Source
  include ::REXML::Encoding
  def buffer(); end

  def consume(pattern); end

  def current_line(); end

  def empty?(); end

  def encoding=(enc); end

  def initialize(arg, encoding=T.unsafe(nil)); end

  def line(); end

  def match(pattern, cons=T.unsafe(nil)); end

  def match_to(char, pattern); end

  def match_to_consume(char, pattern); end

  def position(); end

  def read(); end

  def scan(pattern, cons=T.unsafe(nil)); end
end

class REXML::Source
end

class REXML::SourceFactory
end

class REXML::SourceFactory
  def self.create_from(arg); end
end

class REXML::SyncEnumerator
  include ::Enumerable
  def each(); end

  def initialize(*enums); end

  def length(); end

  def size(); end
end

class REXML::SyncEnumerator
end

class REXML::Text
  include ::Comparable
  def <<(to_append); end

  def doctype(); end

  def empty?(); end

  def indent_text(string, level=T.unsafe(nil), style=T.unsafe(nil), indentfirstline=T.unsafe(nil)); end

  def initialize(arg, respect_whitespace=T.unsafe(nil), parent=T.unsafe(nil), raw=T.unsafe(nil), entity_filter=T.unsafe(nil), illegal=T.unsafe(nil)); end

  def node_type(); end

  def parent=(parent); end

  def raw(); end

  def raw=(raw); end

  def to_s(); end

  def value(); end

  def value=(val); end

  def wrap(string, width, addnewline=T.unsafe(nil)); end

  def write(writer, indent=T.unsafe(nil), transitive=T.unsafe(nil), ie_hack=T.unsafe(nil)); end

  def write_with_substitution(out, input); end

  def xpath(); end
  EREFERENCE = ::T.let(nil, ::T.untyped)
  NEEDS_A_SECOND_CHECK = ::T.let(nil, ::T.untyped)
  NUMERICENTITY = ::T.let(nil, ::T.untyped)
  REFERENCE = ::T.let(nil, ::T.untyped)
  SETUTITSBUS = ::T.let(nil, ::T.untyped)
  SLAICEPS = ::T.let(nil, ::T.untyped)
  SPECIALS = ::T.let(nil, ::T.untyped)
  SUBSTITUTES = ::T.let(nil, ::T.untyped)
  VALID_CHAR = ::T.let(nil, ::T.untyped)
  VALID_XML_CHARS = ::T.let(nil, ::T.untyped)
end

class REXML::Text
  def self.check(string, pattern, doctype); end

  def self.expand(ref, doctype, filter); end

  def self.normalize(input, doctype=T.unsafe(nil), entity_filter=T.unsafe(nil)); end

  def self.read_with_substitution(input, illegal=T.unsafe(nil)); end

  def self.unnormalize(string, doctype=T.unsafe(nil), filter=T.unsafe(nil), illegal=T.unsafe(nil)); end
end

class REXML::UndefinedNamespaceException
  def initialize(prefix, source, parser); end
end

class REXML::UndefinedNamespaceException
end

module REXML::Validation
end

class REXML::Validation::ValidationException
  def initialize(msg); end
end

class REXML::Validation::ValidationException
end

module REXML::Validation
  extend ::T::Sig
end

class REXML::XMLDecl
  include ::REXML::Encoding
  def ==(other); end

  def dowrite(); end

  def encoding=(enc); end

  def initialize(version=T.unsafe(nil), encoding=T.unsafe(nil), standalone=T.unsafe(nil)); end

  def node_type(); end

  def nowrite(); end

  def old_enc=(encoding); end

  def stand_alone?(); end

  def standalone(); end

  def standalone=(standalone); end

  def version(); end

  def version=(version); end

  def write(writer, indent=T.unsafe(nil), transitive=T.unsafe(nil), ie_hack=T.unsafe(nil)); end

  def writeencoding(); end

  def writethis(); end

  def xmldecl(version, encoding, standalone); end
  DEFAULT_ENCODING = ::T.let(nil, ::T.untyped)
  DEFAULT_STANDALONE = ::T.let(nil, ::T.untyped)
  DEFAULT_VERSION = ::T.let(nil, ::T.untyped)
  START = ::T.let(nil, ::T.untyped)
  STOP = ::T.let(nil, ::T.untyped)
end

class REXML::XMLDecl
  def self.default(); end
end

module REXML::XMLTokens
  NAME = ::T.let(nil, ::T.untyped)
  NAMECHAR = ::T.let(nil, ::T.untyped)
  NAME_CHAR = ::T.let(nil, ::T.untyped)
  NAME_START_CHAR = ::T.let(nil, ::T.untyped)
  NAME_STR = ::T.let(nil, ::T.untyped)
  NCNAME_STR = ::T.let(nil, ::T.untyped)
  NMTOKEN = ::T.let(nil, ::T.untyped)
  NMTOKENS = ::T.let(nil, ::T.untyped)
  REFERENCE = ::T.let(nil, ::T.untyped)
end

module REXML::XMLTokens
  extend ::T::Sig
end

class REXML::XPath
  include ::REXML::Functions
  EMPTY_HASH = ::T.let(nil, ::T.untyped)
end

class REXML::XPath
  def self.each(element, path=T.unsafe(nil), namespaces=T.unsafe(nil), variables=T.unsafe(nil), &block); end

  def self.first(element, path=T.unsafe(nil), namespaces=T.unsafe(nil), variables=T.unsafe(nil)); end

  def self.match(element, path=T.unsafe(nil), namespaces=T.unsafe(nil), variables=T.unsafe(nil)); end
end

class REXML::XPathParser
  include ::REXML::XMLTokens
  def []=(variable_name, value); end

  def first(path_stack, node); end

  def get_first(path, nodeset); end

  def match(path_stack, nodeset); end

  def namespaces=(namespaces=T.unsafe(nil)); end

  def parse(path, nodeset); end

  def predicate(path, nodeset); end

  def variables=(vars=T.unsafe(nil)); end
  ALL = ::T.let(nil, ::T.untyped)
  ELEMENTS = ::T.let(nil, ::T.untyped)
  LITERAL = ::T.let(nil, ::T.untyped)
end

class REXML::XPathParser
end

module REXML
  extend ::T::Sig
end

class RSpec::CollectionMatchers::Have
  include ::RSpec::Matchers::Composable
end

module RSpec::CollectionMatchers::Syntax::ExpectExpressionGenerator
  extend ::T::Sig
end

module RSpec::CollectionMatchers::Syntax::ShouldExpressionGenerator
  extend ::T::Sig
end

module RSpec::CollectionMatchers::Syntax
  extend ::T::Sig
end

module RSpec::CollectionMatchers
  extend ::T::Sig
end

class RSpec::Core::Configuration
  include ::RSpec::Core::Configuration::Readers
  def default_color=(default_color); end

  def default_color?(); end

  def default_path?(); end

  def detail_color=(detail_color); end

  def detail_color?(); end

  def drb=(drb); end

  def drb?(); end

  def drb_port=(drb_port); end

  def drb_port?(); end

  def dry_run=(dry_run); end

  def dry_run?(); end

  def error_stream=(error_stream); end

  def error_stream?(); end

  def fail_fast=(fail_fast); end

  def fail_fast?(); end

  def fail_if_no_examples=(fail_if_no_examples); end

  def fail_if_no_examples?(); end

  def failure_color=(failure_color); end

  def failure_color?(); end

  def failure_exit_code=(failure_exit_code); end

  def failure_exit_code?(); end

  def fixed_color=(fixed_color); end

  def fixed_color?(); end

  def max_displayed_failure_line_count=(max_displayed_failure_line_count); end

  def max_displayed_failure_line_count?(); end

  def ordering_registry(*args, &block); end

  def pending_color=(pending_color); end

  def pending_color?(); end

  def profile_examples=(profile_examples); end

  def profile_examples?(); end

  def project_source_dirs=(project_source_dirs); end

  def project_source_dirs?(); end

  def register_ordering(*args, &block); end

  def run_all_when_everything_filtered=(run_all_when_everything_filtered); end

  def run_all_when_everything_filtered?(); end

  def seed(*args, &block); end

  def seed_used?(*args, &block); end

  def silence_filter_announcements=(silence_filter_announcements); end

  def silence_filter_announcements?(); end

  def start_time=(start_time); end

  def start_time?(); end

  def success_color=(success_color); end

  def success_color?(); end

  def threadsafe=(threadsafe); end

  def threadsafe?(); end

  def tty=(tty); end

  def tty?(); end
end

module RSpec::Core::Configuration::ExposeCurrentExample
  extend ::T::Sig
end

module RSpec::Core::DSL
  extend ::T::Sig
end

class RSpec::Core::Example
  def execution_result(); end

  def file_path(); end

  def full_description(); end

  def location(); end

  def pending(); end

  def skip(); end
end

class RSpec::Core::Example::ExecutionResult
  extend ::RSpec::Core::HashImitatable::ClassMethods
end

class RSpec::Core::Example::Procsy
  def ===(*a, &b); end

  def [](*a, &b); end

  def arity(*a, &b); end

  def binding(*a, &b); end

  def clock(*a, &b); end

  def clock=(*a, &b); end

  def clone(*a, &b); end

  def curry(*a, &b); end

  def description(*a, &b); end

  def dup(*a, &b); end

  def duplicate_with(*a, &b); end

  def example_group(*a, &b); end

  def example_group_instance(*a, &b); end

  def exception(*a, &b); end

  def execution_result(*a, &b); end

  def file_path(*a, &b); end

  def full_description(*a, &b); end

  def hash(*a, &b); end

  def id(*a, &b); end

  def inspect_output(*a, &b); end

  def lambda?(*a, &b); end

  def location(*a, &b); end

  def location_rerun_argument(*a, &b); end

  def parameters(*a, &b); end

  def pending(*a, &b); end

  def pending?(*a, &b); end

  def reporter(*a, &b); end

  def rerun_argument(*a, &b); end

  def skip(*a, &b); end

  def skipped?(*a, &b); end

  def source_location(*a, &b); end

  def update_inherited_metadata(*a, &b); end

  def yield(*a, &b); end
end

class RSpec::Core::ExampleGroup
  def self.described_class(); end

  def self.example(*all_args, &block); end

  def self.example_group(*args, &example_group_block); end

  def self.fcontext(*args, &example_group_block); end

  def self.fdescribe(*args, &example_group_block); end

  def self.fexample(*all_args, &block); end

  def self.file_path(); end

  def self.fit(*all_args, &block); end

  def self.focus(*all_args, &block); end

  def self.fspecify(*all_args, &block); end

  def self.it(*all_args, &block); end

  def self.it_behaves_like(name, *args, &customization_block); end

  def self.it_should_behave_like(name, *args, &customization_block); end

  def self.location(); end

  def self.pending(*all_args, &block); end

  def self.skip(*all_args, &block); end

  def self.specify(*all_args, &block); end

  def self.xcontext(*args, &example_group_block); end

  def self.xdescribe(*args, &example_group_block); end

  def self.xexample(*all_args, &block); end

  def self.xit(*all_args, &block); end

  def self.xspecify(*all_args, &block); end
end

module RSpec::Core::FilterableItemRepository
  extend ::T::Sig
end

module RSpec::Core::FlatMap
  extend ::T::Sig
end

module RSpec::Core::Formatters::ConsoleCodes
  extend ::T::Sig
end

class RSpec::Core::Formatters::DeprecationFormatter::GeneratedDeprecationMessage
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Core::Formatters::DeprecationFormatter::SpecifiedDeprecationMessage
  def self.[](*_); end

  def self.members(); end
end

module RSpec::Core::Formatters::ExceptionPresenter::Factory::EmptyBacktraceFormatter
  extend ::T::Sig
end

module RSpec::Core::Formatters::Helpers
  extend ::T::Sig
end

class RSpec::Core::Formatters::SnippetExtractor
  def beginning_line_number(); end

  def max_line_count(); end

  def source(); end
end

module RSpec::Core::Formatters::SyntaxHighlighter::CodeRayImplementation
  extend ::T::Sig
end

module RSpec::Core::Formatters::SyntaxHighlighter::NoSyntaxHighlightingImplementation
  extend ::T::Sig
end

module RSpec::Core::Formatters
  extend ::T::Sig
end

module RSpec::Core::HashImitatable
  def <(*args, &block); end

  def <=(*args, &block); end

  def >(*args, &block); end

  def >=(*args, &block); end

  def all?(*args, &block); end

  def any?(*args, &block); end

  def assoc(*args, &block); end

  def chunk(*args, &block); end

  def chunk_while(*args, &block); end

  def clear(*args, &block); end

  def collect(*args, &block); end

  def collect_concat(*args, &block); end

  def compare_by_identity(*args, &block); end

  def compare_by_identity?(*args, &block); end

  def count(*args, &block); end

  def cycle(*args, &block); end

  def default(*args, &block); end

  def default=(*args, &block); end

  def default_proc(*args, &block); end

  def default_proc=(*args, &block); end

  def delete(*args, &block); end

  def delete_if(*args, &block); end

  def detect(*args, &block); end

  def dig(*args, &block); end

  def drop(*args, &block); end

  def drop_while(*args, &block); end

  def each(*args, &block); end

  def each_cons(*args, &block); end

  def each_entry(*args, &block); end

  def each_key(*args, &block); end

  def each_pair(*args, &block); end

  def each_slice(*args, &block); end

  def each_value(*args, &block); end

  def each_with_index(*args, &block); end

  def each_with_object(*args, &block); end

  def empty?(*args, &block); end

  def entries(*args, &block); end

  def fetch(*args, &block); end

  def fetch_values(*args, &block); end

  def find(*args, &block); end

  def find_all(*args, &block); end

  def find_index(*args, &block); end

  def first(*args, &block); end

  def flat_map(*args, &block); end

  def flatten(*args, &block); end

  def grep(*args, &block); end

  def grep_v(*args, &block); end

  def group_by(*args, &block); end

  def has_key?(*args, &block); end

  def has_value?(*args, &block); end

  def include?(*args, &block); end

  def index(*args, &block); end

  def inject(*args, &block); end

  def invert(*args, &block); end

  def keep_if(*args, &block); end

  def key(*args, &block); end

  def key?(*args, &block); end

  def keys(*args, &block); end

  def lazy(*args, &block); end

  def length(*args, &block); end

  def map(*args, &block); end

  def max(*args, &block); end

  def max_by(*args, &block); end

  def member?(*args, &block); end

  def merge(*args, &block); end

  def merge!(*args, &block); end

  def min(*args, &block); end

  def min_by(*args, &block); end

  def minmax(*args, &block); end

  def minmax_by(*args, &block); end

  def none?(*args, &block); end

  def one?(*args, &block); end

  def partition(*args, &block); end

  def rassoc(*args, &block); end

  def reduce(*args, &block); end

  def rehash(*args, &block); end

  def reject(*args, &block); end

  def reject!(*args, &block); end

  def replace(*args, &block); end

  def reverse_each(*args, &block); end

  def select(*args, &block); end

  def select!(*args, &block); end

  def shift(*args, &block); end

  def size(*args, &block); end

  def slice_after(*args, &block); end

  def slice_before(*args, &block); end

  def slice_when(*args, &block); end

  def sort(*args, &block); end

  def sort_by(*args, &block); end

  def store(*args, &block); end

  def take(*args, &block); end

  def take_while(*args, &block); end

  def to_a(*args, &block); end

  def to_hash(*args, &block); end

  def to_proc(*args, &block); end

  def to_set(*args, &block); end

  def uniq(*args, &block); end

  def update(*args, &block); end

  def value?(*args, &block); end

  def values(*args, &block); end

  def values_at(*args, &block); end

  def zip(*args, &block); end
end

module RSpec::Core::HashImitatable::ClassMethods
  extend ::T::Sig
end

module RSpec::Core::HashImitatable
  extend ::T::Sig
end

class RSpec::Core::Hooks::Hook
  def self.[](*_); end

  def self.members(); end
end

module RSpec::Core::Hooks
  extend ::T::Sig
end

class RSpec::Core::Invocations::PrintHelp
  def self.[](*_); end

  def self.members(); end
end

module RSpec::Core::Invocations
  extend ::T::Sig
end

class RSpec::Core::LegacyExampleGroupHash
  extend ::RSpec::Core::HashImitatable::ClassMethods
end

module RSpec::Core::MemoizedHelpers::ClassMethods
  extend ::T::Sig
end

module RSpec::Core::MemoizedHelpers
  extend ::T::Sig
end

module RSpec::Core::Metadata
  extend ::T::Sig
end

module RSpec::Core::MetadataFilter
  extend ::T::Sig
end

module RSpec::Core::MultipleExceptionError::InterfaceTag
  extend ::T::Sig
end

class RSpec::Core::Notifications::DeprecationNotification
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Core::Notifications::ExampleNotification
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Core::Notifications::GroupNotification
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Core::Notifications::MessageNotification
  def self.[](*_); end

  def self.members(); end
end

module RSpec::Core::Notifications::NullColorizer
  extend ::T::Sig
end

class RSpec::Core::Notifications::SeedNotification
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Core::Notifications::StartNotification
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Core::Notifications::SummaryNotification
  def self.[](*_); end

  def self.members(); end
end

module RSpec::Core::Notifications
  extend ::T::Sig
end

module RSpec::Core::Ordering
  extend ::T::Sig
end

class RSpec::Core::OutputWrapper
  def <<(*args, &block); end

  def advise(*args, &block); end

  def autoclose=(*args, &block); end

  def autoclose?(*args, &block); end

  def beep(*args, &block); end

  def binmode(*args, &block); end

  def binmode?(*args, &block); end

  def bytes(*args, &block); end

  def chars(*args, &block); end

  def close(*args, &block); end

  def close_on_exec=(*args, &block); end

  def close_on_exec?(*args, &block); end

  def close_read(*args, &block); end

  def close_write(*args, &block); end

  def closed?(*args, &block); end

  def codepoints(*args, &block); end

  def cooked(*args, &block); end

  def cooked!(*args, &block); end

  def cursor(*args, &block); end

  def cursor=(*args, &block); end

  def each(*args, &block); end

  def each_byte(*args, &block); end

  def each_char(*args, &block); end

  def each_codepoint(*args, &block); end

  def each_line(*args, &block); end

  def echo=(*args, &block); end

  def echo?(*args, &block); end

  def eof(*args, &block); end

  def eof?(*args, &block); end

  def external_encoding(*args, &block); end

  def fcntl(*args, &block); end

  def fdatasync(*args, &block); end

  def fileno(*args, &block); end

  def flush(*args, &block); end

  def fsync(*args, &block); end

  def getbyte(*args, &block); end

  def getc(*args, &block); end

  def getch(*args, &block); end

  def getpass(*args, &block); end

  def gets(*args, &block); end

  def goto(*args, &block); end

  def iflush(*args, &block); end

  def inspect(*args, &block); end

  def internal_encoding(*args, &block); end

  def ioctl(*args, &block); end

  def ioflush(*args, &block); end

  def isatty(*args, &block); end

  def lineno(*args, &block); end

  def lineno=(*args, &block); end

  def lines(*args, &block); end

  def noecho(*args, &block); end

  def nonblock(*args, &block); end

  def nonblock=(*args, &block); end

  def nonblock?(*args, &block); end

  def nread(*args, &block); end

  def oflush(*args, &block); end

  def pathconf(*args, &block); end

  def pid(*args, &block); end

  def pos(*args, &block); end

  def pos=(*args, &block); end

  def pressed?(*args, &block); end

  def print(*args, &block); end

  def printf(*args, &block); end

  def putc(*args, &block); end

  def puts(*args, &block); end

  def raw(*args, &block); end

  def raw!(*args, &block); end

  def read(*args, &block); end

  def read_nonblock(*args, &block); end

  def readbyte(*args, &block); end

  def readchar(*args, &block); end

  def readline(*args, &block); end

  def readlines(*args, &block); end

  def readpartial(*args, &block); end

  def ready?(*args, &block); end

  def reopen(*args, &block); end

  def rewind(*args, &block); end

  def seek(*args, &block); end

  def set_encoding(*args, &block); end

  def stat(*args, &block); end

  def sync(*args, &block); end

  def sync=(*args, &block); end

  def sysread(*args, &block); end

  def sysseek(*args, &block); end

  def syswrite(*args, &block); end

  def tell(*args, &block); end

  def to_i(*args, &block); end

  def to_io(*args, &block); end

  def tty?(*args, &block); end

  def ungetbyte(*args, &block); end

  def ungetc(*args, &block); end

  def wait(*args, &block); end

  def wait_readable(*args, &block); end

  def wait_writable(*args, &block); end

  def winsize(*args, &block); end

  def winsize=(*args, &block); end

  def write(*args, &block); end

  def write_nonblock(*args, &block); end
end

module RSpec::Core::Pending
  extend ::T::Sig
end

module RSpec::Core::RubyProject
  extend ::T::Sig
end

module RSpec::Core::SharedContext
  include ::RSpec::Its
  def after(*args, &block); end

  def append_after(*args, &block); end

  def append_before(*args, &block); end

  def around(*args, &block); end

  def before(*args, &block); end

  def context(*args, &block); end

  def describe(*args, &block); end

  def hooks(*args, &block); end

  def let(*args, &block); end

  def let!(*args, &block); end

  def prepend_after(*args, &block); end

  def prepend_before(*args, &block); end

  def subject(*args, &block); end

  def subject!(*args, &block); end
end

class RSpec::Core::SharedContext::Recording
  def self.[](*_); end

  def self.members(); end
end

module RSpec::Core::SharedContext
  extend ::T::Sig
end

module RSpec::Core::SharedExampleGroup::TopLevelDSL
  extend ::T::Sig
end

module RSpec::Core::SharedExampleGroup
  extend ::T::Sig
end

module RSpec::Core::ShellEscape
  extend ::T::Sig
end

class RSpec::Core::Time
  def self.now(); end
end

module RSpec::Core::Version
  extend ::T::Sig
end

module RSpec::Core::Warnings
  extend ::T::Sig
end

module RSpec::Core::World::Null
  extend ::T::Sig
end

module RSpec::Core
  extend ::T::Sig
end

module RSpec::ExampleGroups
  extend ::T::Sig
end

class RSpec::Expectations::BlockSnippetExtractor::BlockLocator
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Expectations::BlockSnippetExtractor::BlockTokenExtractor
  def body_tokens(); end

  def state(); end
end

class RSpec::Expectations::BlockSnippetExtractor::BlockTokenExtractor
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Expectations::Configuration
  def color=(color); end
end

module RSpec::Expectations::ExpectationHelper
  extend ::T::Sig
end

module RSpec::Expectations::ExpectationTarget::InstanceMethods
  extend ::T::Sig
end

module RSpec::Expectations::Syntax
  extend ::T::Sig
end

module RSpec::Expectations::Version
  extend ::T::Sig
end

module RSpec::Expectations
  extend ::T::Sig
end

module RSpec::Its
  extend ::T::Sig
end

module RSpec::Matchers
  def a_block_changing(*args, &block); end

  def a_block_outputting(*args, &block); end

  def a_block_raising(*args, &block); end

  def a_block_throwing(*args, &block); end

  def a_block_yielding_control(*args, &block); end

  def a_block_yielding_successive_args(*args, &block); end

  def a_block_yielding_with_args(*args, &block); end

  def a_block_yielding_with_no_args(*args, &block); end

  def a_collection_containing_exactly(*args, &block); end

  def a_collection_ending_with(*args, &block); end

  def a_collection_including(*args, &block); end

  def a_collection_starting_with(*args, &block); end

  def a_falsey_value(*args, &block); end

  def a_falsy_value(*args, &block); end

  def a_hash_including(*args, &block); end

  def a_kind_of(*args, &block); end

  def a_nil_value(*args, &block); end

  def a_range_covering(*args, &block); end

  def a_string_ending_with(*args, &block); end

  def a_string_including(*args, &block); end

  def a_string_matching(*args, &block); end

  def a_string_starting_with(*args, &block); end

  def a_truthy_value(*args, &block); end

  def a_value(*args, &block); end

  def a_value_between(*args, &block); end

  def a_value_within(*args, &block); end

  def an_instance_of(*args, &block); end

  def an_object_eq_to(*args, &block); end

  def an_object_eql_to(*args, &block); end

  def an_object_equal_to(*args, &block); end

  def an_object_existing(*args, &block); end

  def an_object_having_attributes(*args, &block); end

  def an_object_matching(*args, &block); end

  def an_object_responding_to(*args, &block); end

  def an_object_satisfying(*args, &block); end

  def be_falsy(*args, &block); end

  def be_one_of(*expected, &block_arg); end

  def changing(*args, &block); end

  def containing_exactly(*args, &block); end

  def covering(*args, &block); end

  def ending_with(*args, &block); end

  def eq_to(*args, &block); end

  def eql_to(*args, &block); end

  def equal_attributes_of(*expected, &block_arg); end

  def equal_resource_attributes_of(*expected, &block_arg); end

  def equal_to(*args, &block); end

  def existing(*args, &block); end

  def exit_with(*expected, &block_arg); end

  def expect(value=T.unsafe(nil), &block); end

  def have_matching_element(*expected, &block_arg); end

  def have_matching_log(*expected, &block_arg); end

  def have_printed(*expected, &block_arg); end

  def having_attributes(*args, &block); end

  def include_in_order(*expected, &block_arg); end

  def including(*args, &block); end

  def match_tokens2(*expected, &block_arg); end

  def matching(*args, &block); end

  def raising(*args, &block); end

  def responding_to(*args, &block); end

  def satisfying(*args, &block); end

  def starting_with(*args, &block); end

  def throwing(*args, &block); end

  def within(*args, &block); end

  def yielding_control(*args, &block); end

  def yielding_successive_args(*args, &block); end

  def yielding_with_args(*args, &block); end

  def yielding_with_no_args(*args, &block); end
end

module RSpec::Matchers::BlockAliases
  extend ::T::Sig
end

module RSpec::Matchers::BuiltIn::BaseMatcher::DefaultFailureMessages
  extend ::T::Sig
end

module RSpec::Matchers::BuiltIn::BaseMatcher::HashFormatting
  extend ::T::Sig
end

class RSpec::Matchers::BuiltIn::Be
  def <(operand); end

  def <=(operand); end

  def ==(operand); end

  def ===(operand); end

  def =~(operand); end

  def >(operand); end

  def >=(operand); end
end

module RSpec::Matchers::BuiltIn::BeHelpers
  extend ::T::Sig
end

class RSpec::Matchers::BuiltIn::ContainExactly::PairingsMaximizer::Solution
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Matchers::BuiltIn::OperatorMatcher
  def !=(_expected); end

  def !~(_expected); end

  def <(expected); end

  def <=(expected); end

  def ==(expected); end

  def ===(expected); end

  def =~(expected); end

  def >(expected); end

  def >=(expected); end
end

module RSpec::Matchers::BuiltIn
  extend ::T::Sig
end

module RSpec::Matchers::Composable
  extend ::T::Sig
end

module RSpec::Matchers::DSL::DefaultImplementations
  extend ::T::Sig
end

module RSpec::Matchers::DSL::Macros::Deprecated
  extend ::T::Sig
end

module RSpec::Matchers::DSL::Macros
  extend ::T::Sig
end

module RSpec::Matchers::DSL
  extend ::T::Sig
end

module RSpec::Matchers::EnglishPhrasing
  extend ::T::Sig
end

module RSpec::Matchers
  extend ::T::Sig
end

module RSpec::Support::AllExceptionsExceptOnesWeMustNotRescue
  extend ::T::Sig
end

class RSpec::Support::EncodedString
  def ==(*args, &block); end

  def empty?(*args, &block); end

  def encoding(*args, &block); end

  def eql?(*args, &block); end

  def lines(*args, &block); end
end

module RSpec::Support::FuzzyMatcher
  extend ::T::Sig
end

module RSpec::Support::OS
  extend ::T::Sig
end

class RSpec::Support::ObjectFormatter::BaseInspector
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Support::ObjectFormatter::InspectableItem
  def self.[](*_); end

  def self.members(); end
end

module RSpec::Support::RecursiveConstMethods
  extend ::T::Sig
end

module RSpec::Support::Ruby
  extend ::T::Sig
end

module RSpec::Support::RubyFeatures
  extend ::T::Sig
end

module RSpec::Support::Version
  extend ::T::Sig
end

module RSpec::Support::Warnings
  extend ::T::Sig
end

module RSpec::Support
  extend ::T::Sig
  def self.require_rspec_core(f); end

  def self.require_rspec_expectations(f); end

  def self.require_rspec_matchers(f); end

  def self.require_rspec_support(f); end
end

module RSpec
  extend ::T::Sig
  def self.context(*args, &example_group_block); end

  def self.describe(*args, &example_group_block); end

  def self.example_group(*args, &example_group_block); end

  def self.fcontext(*args, &example_group_block); end

  def self.fdescribe(*args, &example_group_block); end

  def self.xcontext(*args, &example_group_block); end

  def self.xdescribe(*args, &example_group_block); end
end

module Racc
  Racc_No_Extensions = ::T.let(nil, ::T.untyped)
end

class Racc::CparseParams
end

class Racc::CparseParams
end

class Racc::ParseError
  extend ::T::Sig
end

class Racc::Parser
  Racc_Runtime_Core_Id_C = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version_C = ::T.let(nil, ::T.untyped)
end

class Racc::Parser
  extend ::T::Sig
end

module Racc
  extend ::T::Sig
end

module Rake::Cloneable
  extend ::T::Sig
end

module Rake::DSL
  include ::FileUtils::StreamUtils_
end

module Rake::DSL
  extend ::T::Sig
end

module Rake::FileUtilsExt
  include ::FileUtils::StreamUtils_
  def cd(*args, &block); end

  def chdir(*args, &block); end

  def chmod(*args, &block); end

  def chmod_R(*args, &block); end

  def chown(*args, &block); end

  def chown_R(*args, &block); end

  def copy(*args, &block); end

  def cp(*args, &block); end

  def cp_r(*args, &block); end

  def install(*args, &block); end

  def link(*args, &block); end

  def ln(*args, &block); end

  def ln_s(*args, &block); end

  def ln_sf(*args, &block); end

  def makedirs(*args, &block); end

  def mkdir(*args, &block); end

  def mkdir_p(*args, &block); end

  def mkpath(*args, &block); end

  def move(*args, &block); end

  def mv(*args, &block); end

  def remove(*args, &block); end

  def rm(*args, &block); end

  def rm_f(*args, &block); end

  def rm_r(*args, &block); end

  def rm_rf(*args, &block); end

  def rmdir(*args, &block); end

  def rmtree(*args, &block); end

  def safe_unlink(*args, &block); end

  def symlink(*args, &block); end

  def touch(*args, &block); end
end

module Rake::FileUtilsExt
  extend ::FileUtils::StreamUtils_
  extend ::T::Sig
end

class Rake::TaskLib
  include ::FileUtils::StreamUtils_
end

module Random::Formatter
  extend ::T::Sig
end

class Random
  extend ::T::Sig
  def self.raw_seed(_); end
end

class Range
  extend ::T::Sig
end

class RangeError
  extend ::T::Sig
end

class Rational
  extend ::T::Sig
end

module RbConfig
  extend ::T::Sig
  def self.expand(val, config=T.unsafe(nil)); end

  def self.ruby(); end
end

module Readline
  extend ::T::Sig
  def self.delete_text(*_); end

  def self.emacs_editing_mode?(); end

  def self.get_screen_size(); end

  def self.insert_text(_); end

  def self.point=(point); end

  def self.pre_input_hook(); end

  def self.pre_input_hook=(pre_input_hook); end

  def self.redisplay(); end

  def self.refresh_line(); end

  def self.set_screen_size(_, _1); end

  def self.special_prefixes(); end

  def self.special_prefixes=(special_prefixes); end

  def self.vi_editing_mode?(); end
end

class Regexp
  extend ::T::Sig
  def self.union(*_); end
end

class RegexpError
  extend ::T::Sig
end

module RelationshipGraphMatchers
  extend ::T::Sig
end

class Resolv::DNS
  def extract_resources(msg, name, typeclass); end

  def fetch_resource(name, typeclass); end

  def lazy_initialize(); end

  def make_tcp_requester(host, port); end

  def make_udp_requester(); end
  RequestID = ::T.let(nil, ::T.untyped)
  RequestIDMutex = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Config
  def generate_candidates(name); end

  def generate_timeouts(); end

  def initialize(config_info=T.unsafe(nil)); end

  def lazy_initialize(); end

  def nameserver_port(); end

  def resolv(name); end

  def single?(); end

  def timeouts=(values); end
  InitialTimeout = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Config::NXDomain
end

class Resolv::DNS::Config::NXDomain
end

class Resolv::DNS::Config::OtherResolvError
end

class Resolv::DNS::Config::OtherResolvError
end

class Resolv::DNS::Config
  def self.default_config_hash(filename=T.unsafe(nil)); end

  def self.parse_resolv_conf(filename); end
end

module Resolv::DNS::Label
end

class Resolv::DNS::Label::Str
  def ==(other); end

  def downcase(); end

  def eql?(other); end

  def initialize(string); end

  def string(); end
end

class Resolv::DNS::Label::Str
end

module Resolv::DNS::Label
  extend ::T::Sig
  def self.split(arg); end
end

class Resolv::DNS::Message
  def ==(other); end

  def aa(); end

  def aa=(aa); end

  def add_additional(name, ttl, data); end

  def add_answer(name, ttl, data); end

  def add_authority(name, ttl, data); end

  def add_question(name, typeclass); end

  def additional(); end

  def answer(); end

  def authority(); end

  def each_additional(); end

  def each_answer(); end

  def each_authority(); end

  def each_question(); end

  def each_resource(); end

  def encode(); end

  def id(); end

  def id=(id); end

  def initialize(id=T.unsafe(nil)); end

  def opcode(); end

  def opcode=(opcode); end

  def qr(); end

  def qr=(qr); end

  def question(); end

  def ra(); end

  def ra=(ra); end

  def rcode(); end

  def rcode=(rcode); end

  def rd(); end

  def rd=(rd); end

  def tc(); end

  def tc=(tc); end
end

class Resolv::DNS::Message::MessageDecoder
  def get_bytes(len=T.unsafe(nil)); end

  def get_label(); end

  def get_labels(); end

  def get_length16(); end

  def get_name(); end

  def get_question(); end

  def get_rr(); end

  def get_string(); end

  def get_string_list(); end

  def get_unpack(template); end

  def initialize(data); end
end

class Resolv::DNS::Message::MessageDecoder
end

class Resolv::DNS::Message::MessageEncoder
  def put_bytes(d); end

  def put_label(d); end

  def put_labels(d); end

  def put_length16(); end

  def put_name(d); end

  def put_pack(template, *d); end

  def put_string(d); end

  def put_string_list(ds); end
end

class Resolv::DNS::Message::MessageEncoder
end

class Resolv::DNS::Message
  def self.decode(m); end
end

class Resolv::DNS::Name
  def ==(other); end

  def [](i); end

  def eql?(other); end

  def length(); end

  def to_a(); end
end

module Resolv::DNS::OpCode
  IQuery = ::T.let(nil, ::T.untyped)
  Notify = ::T.let(nil, ::T.untyped)
  Query = ::T.let(nil, ::T.untyped)
  Status = ::T.let(nil, ::T.untyped)
  Update = ::T.let(nil, ::T.untyped)
end

module Resolv::DNS::OpCode
  extend ::T::Sig
end

class Resolv::DNS::Query
  def encode_rdata(msg); end
end

class Resolv::DNS::Query
  def self.decode_rdata(msg); end
end

module Resolv::DNS::RCode
  BADALG = ::T.let(nil, ::T.untyped)
  BADKEY = ::T.let(nil, ::T.untyped)
  BADMODE = ::T.let(nil, ::T.untyped)
  BADNAME = ::T.let(nil, ::T.untyped)
  BADSIG = ::T.let(nil, ::T.untyped)
  BADTIME = ::T.let(nil, ::T.untyped)
  BADVERS = ::T.let(nil, ::T.untyped)
  FormErr = ::T.let(nil, ::T.untyped)
  NXDomain = ::T.let(nil, ::T.untyped)
  NXRRSet = ::T.let(nil, ::T.untyped)
  NoError = ::T.let(nil, ::T.untyped)
  NotAuth = ::T.let(nil, ::T.untyped)
  NotImp = ::T.let(nil, ::T.untyped)
  NotZone = ::T.let(nil, ::T.untyped)
  Refused = ::T.let(nil, ::T.untyped)
  ServFail = ::T.let(nil, ::T.untyped)
  YXDomain = ::T.let(nil, ::T.untyped)
  YXRRSet = ::T.let(nil, ::T.untyped)
end

module Resolv::DNS::RCode
  extend ::T::Sig
end

class Resolv::DNS::Requester
  def close(); end

  def request(sender, tout); end

  def sender_for(addr, msg); end
end

class Resolv::DNS::Requester::ConnectedUDP
  def initialize(host, port=T.unsafe(nil)); end

  def lazy_initialize(); end

  def recv_reply(readable_socks); end

  def sender(msg, data, host=T.unsafe(nil), port=T.unsafe(nil)); end
end

class Resolv::DNS::Requester::ConnectedUDP::Sender
  def data(); end

  def send(); end
end

class Resolv::DNS::Requester::ConnectedUDP::Sender
end

class Resolv::DNS::Requester::ConnectedUDP
end

class Resolv::DNS::Requester::MDNSOneShot
end

class Resolv::DNS::Requester::MDNSOneShot
end

class Resolv::DNS::Requester::RequestError
end

class Resolv::DNS::Requester::RequestError
end

class Resolv::DNS::Requester::Sender
  def initialize(msg, data, sock); end
end

class Resolv::DNS::Requester::Sender
end

class Resolv::DNS::Requester::TCP
  def initialize(host, port=T.unsafe(nil)); end

  def recv_reply(readable_socks); end

  def sender(msg, data, host=T.unsafe(nil), port=T.unsafe(nil)); end
end

class Resolv::DNS::Requester::TCP::Sender
  def data(); end

  def send(); end
end

class Resolv::DNS::Requester::TCP::Sender
end

class Resolv::DNS::Requester::TCP
end

class Resolv::DNS::Requester::UnconnectedUDP
  def initialize(*nameserver_port); end

  def lazy_initialize(); end

  def recv_reply(readable_socks); end

  def sender(msg, data, host, port=T.unsafe(nil)); end
end

class Resolv::DNS::Requester::UnconnectedUDP::Sender
  def data(); end

  def initialize(msg, data, sock, host, port); end

  def send(); end
end

class Resolv::DNS::Requester::UnconnectedUDP::Sender
end

class Resolv::DNS::Requester::UnconnectedUDP
end

class Resolv::DNS::Requester
end

class Resolv::DNS::Resource
  def ==(other); end

  def eql?(other); end
  ClassHash = ::T.let(nil, ::T.untyped)
  ClassInsensitiveTypes = ::T.let(nil, ::T.untyped)
  ClassValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::ANY
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::CNAME
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::Generic
  def self.create(type_value, class_value); end
end

class Resolv::DNS::Resource::HINFO
  TypeValue = ::T.let(nil, ::T.untyped)
end

module Resolv::DNS::Resource::IN
  ClassValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::A
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::AAAA
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::ANY
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::ANY
end

class Resolv::DNS::Resource::IN::CNAME
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::CNAME
end

class Resolv::DNS::Resource::IN::HINFO
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::HINFO
end

class Resolv::DNS::Resource::IN::LOC
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::LOC
end

class Resolv::DNS::Resource::IN::MINFO
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::MINFO
end

class Resolv::DNS::Resource::IN::MX
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::MX
end

class Resolv::DNS::Resource::IN::NS
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::NS
end

class Resolv::DNS::Resource::IN::PTR
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::PTR
end

class Resolv::DNS::Resource::IN::SOA
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::SOA
end

class Resolv::DNS::Resource::IN::SRV
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::TXT
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::TXT
end

class Resolv::DNS::Resource::IN::WKS
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

module Resolv::DNS::Resource::IN
  extend ::T::Sig
end

class Resolv::DNS::Resource::LOC
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::MINFO
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::MX
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::NS
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::PTR
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::SOA
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::TXT
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource
  def self.get_class(type_value, class_value); end
end

class Resolv::DNS
  def self.allocate_request_id(host, port); end

  def self.bind_random_port(udpsock, bind_host=T.unsafe(nil)); end

  def self.free_request_id(host, port, id); end

  def self.random(arg); end

  def self.rangerand(range); end
end

class Resolv::Hosts
  def lazy_initialize(); end
end

class Resolv::IPv4
  def ==(other); end

  def eql?(other); end
end

class Resolv::IPv6
  def ==(other); end

  def eql?(other); end
end

class Resolv::LOC::Alt
  def ==(other); end

  def eql?(other); end
end

class Resolv::LOC::Coord
  def ==(other); end

  def eql?(other); end
end

class Resolv::LOC::Size
  def ==(other); end

  def eql?(other); end
end

module Resolv::LOC
  extend ::T::Sig
end

class Ripper
  def column(); end

  def encoding(); end

  def end_seen?(); end

  def error?(); end

  def filename(); end

  def initialize(*_); end

  def lineno(); end

  def parse(); end

  def yydebug(); end

  def yydebug=(yydebug); end
  EVENTS = ::T.let(nil, ::T.untyped)
  PARSER_EVENTS = ::T.let(nil, ::T.untyped)
  PARSER_EVENT_TABLE = ::T.let(nil, ::T.untyped)
  SCANNER_EVENTS = ::T.let(nil, ::T.untyped)
  SCANNER_EVENT_TABLE = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class Ripper::Filter
  def column(); end

  def filename(); end

  def initialize(src, filename=T.unsafe(nil), lineno=T.unsafe(nil)); end

  def lineno(); end

  def parse(init=T.unsafe(nil)); end
end

class Ripper::Filter
end

class Ripper::Lexer
  def lex(); end

  def tokenize(); end
end

class Ripper::Lexer::Elem
  def event(); end

  def event=(_); end

  def pos(); end

  def pos=(_); end

  def tok(); end

  def tok=(_); end
end

class Ripper::Lexer::Elem
  def self.[](*_); end

  def self.members(); end
end

class Ripper::Lexer
end

class Ripper::SexpBuilder
  def on_BEGIN(*args); end

  def on_CHAR(tok); end

  def on_END(*args); end

  def on___end__(tok); end

  def on_alias(*args); end

  def on_alias_error(*args); end

  def on_aref(*args); end

  def on_aref_field(*args); end

  def on_arg_ambiguous(*args); end

  def on_arg_paren(*args); end

  def on_args_add(*args); end

  def on_args_add_block(*args); end

  def on_args_add_star(*args); end

  def on_args_new(*args); end

  def on_array(*args); end

  def on_assign(*args); end

  def on_assign_error(*args); end

  def on_assoc_new(*args); end

  def on_assoc_splat(*args); end

  def on_assoclist_from_args(*args); end

  def on_backref(tok); end

  def on_backtick(tok); end

  def on_bare_assoc_hash(*args); end

  def on_begin(*args); end

  def on_binary(*args); end

  def on_block_var(*args); end

  def on_block_var_add_block(*args); end

  def on_block_var_add_star(*args); end

  def on_blockarg(*args); end

  def on_bodystmt(*args); end

  def on_brace_block(*args); end

  def on_break(*args); end

  def on_call(*args); end

  def on_case(*args); end

  def on_class(*args); end

  def on_class_name_error(*args); end

  def on_comma(tok); end

  def on_command(*args); end

  def on_command_call(*args); end

  def on_comment(tok); end

  def on_const(tok); end

  def on_const_path_field(*args); end

  def on_const_path_ref(*args); end

  def on_const_ref(*args); end

  def on_cvar(tok); end

  def on_def(*args); end

  def on_defined(*args); end

  def on_defs(*args); end

  def on_do_block(*args); end

  def on_dot2(*args); end

  def on_dot3(*args); end

  def on_dyna_symbol(*args); end

  def on_else(*args); end

  def on_elsif(*args); end

  def on_embdoc(tok); end

  def on_embdoc_beg(tok); end

  def on_embdoc_end(tok); end

  def on_embexpr_beg(tok); end

  def on_embexpr_end(tok); end

  def on_embvar(tok); end

  def on_ensure(*args); end

  def on_excessed_comma(*args); end

  def on_fcall(*args); end

  def on_field(*args); end

  def on_float(tok); end

  def on_for(*args); end

  def on_gvar(tok); end

  def on_hash(*args); end

  def on_heredoc_beg(tok); end

  def on_heredoc_end(tok); end

  def on_ident(tok); end

  def on_if(*args); end

  def on_if_mod(*args); end

  def on_ifop(*args); end

  def on_ignored_nl(tok); end

  def on_imaginary(tok); end

  def on_int(tok); end

  def on_ivar(tok); end

  def on_kw(tok); end

  def on_label(tok); end

  def on_label_end(tok); end

  def on_lambda(*args); end

  def on_lbrace(tok); end

  def on_lbracket(tok); end

  def on_lparen(tok); end

  def on_magic_comment(*args); end

  def on_massign(*args); end

  def on_method_add_arg(*args); end

  def on_method_add_block(*args); end

  def on_mlhs_add(*args); end

  def on_mlhs_add_star(*args); end

  def on_mlhs_new(*args); end

  def on_mlhs_paren(*args); end

  def on_module(*args); end

  def on_mrhs_add(*args); end

  def on_mrhs_add_star(*args); end

  def on_mrhs_new(*args); end

  def on_mrhs_new_from_args(*args); end

  def on_next(*args); end

  def on_nl(tok); end

  def on_op(tok); end

  def on_opassign(*args); end

  def on_operator_ambiguous(*args); end

  def on_param_error(*args); end

  def on_params(*args); end

  def on_paren(*args); end

  def on_parse_error(*args); end

  def on_period(tok); end

  def on_program(*args); end

  def on_qsymbols_add(*args); end

  def on_qsymbols_beg(tok); end

  def on_qsymbols_new(*args); end

  def on_qwords_add(*args); end

  def on_qwords_beg(tok); end

  def on_qwords_new(*args); end

  def on_rational(tok); end

  def on_rbrace(tok); end

  def on_rbracket(tok); end

  def on_redo(*args); end

  def on_regexp_add(*args); end

  def on_regexp_beg(tok); end

  def on_regexp_end(tok); end

  def on_regexp_literal(*args); end

  def on_regexp_new(*args); end

  def on_rescue(*args); end

  def on_rescue_mod(*args); end

  def on_rest_param(*args); end

  def on_retry(*args); end

  def on_return(*args); end

  def on_return0(*args); end

  def on_rparen(tok); end

  def on_sclass(*args); end

  def on_semicolon(tok); end

  def on_sp(tok); end

  def on_stmts_add(*args); end

  def on_stmts_new(*args); end

  def on_string_add(*args); end

  def on_string_concat(*args); end

  def on_string_content(*args); end

  def on_string_dvar(*args); end

  def on_string_embexpr(*args); end

  def on_string_literal(*args); end

  def on_super(*args); end

  def on_symbeg(tok); end

  def on_symbol(*args); end

  def on_symbol_literal(*args); end

  def on_symbols_add(*args); end

  def on_symbols_beg(tok); end

  def on_symbols_new(*args); end

  def on_tlambda(tok); end

  def on_tlambeg(tok); end

  def on_top_const_field(*args); end

  def on_top_const_ref(*args); end

  def on_tstring_beg(tok); end

  def on_tstring_content(tok); end

  def on_tstring_end(tok); end

  def on_unary(*args); end

  def on_undef(*args); end

  def on_unless(*args); end

  def on_unless_mod(*args); end

  def on_until(*args); end

  def on_until_mod(*args); end

  def on_var_alias(*args); end

  def on_var_field(*args); end

  def on_var_ref(*args); end

  def on_vcall(*args); end

  def on_void_stmt(*args); end

  def on_when(*args); end

  def on_while(*args); end

  def on_while_mod(*args); end

  def on_word_add(*args); end

  def on_word_new(*args); end

  def on_words_add(*args); end

  def on_words_beg(tok); end

  def on_words_new(*args); end

  def on_words_sep(tok); end

  def on_xstring_add(*args); end

  def on_xstring_literal(*args); end

  def on_xstring_new(*args); end

  def on_yield(*args); end

  def on_yield0(*args); end

  def on_zsuper(*args); end
end

class Ripper::SexpBuilder
end

class Ripper::SexpBuilderPP
end

class Ripper::SexpBuilderPP
end

class Ripper::TokenPattern
  def initialize(pattern); end

  def match(str); end

  def match_list(tokens); end
  MAP = ::T.let(nil, ::T.untyped)
end

class Ripper::TokenPattern::CompileError
end

class Ripper::TokenPattern::CompileError
end

class Ripper::TokenPattern::Error
end

class Ripper::TokenPattern::Error
end

class Ripper::TokenPattern::MatchData
  def initialize(tokens, match); end

  def string(n=T.unsafe(nil)); end
end

class Ripper::TokenPattern::MatchData
end

class Ripper::TokenPattern::MatchError
end

class Ripper::TokenPattern::MatchError
end

class Ripper::TokenPattern
  def self.compile(*_); end
end

class Ripper
  extend ::T::Sig
  def self.dedent_string(_, _1); end

  def self.lex(src, filename=T.unsafe(nil), lineno=T.unsafe(nil)); end

  def self.parse(src, filename=T.unsafe(nil), lineno=T.unsafe(nil)); end

  def self.token_match(src, pattern); end
end

class RubyLex
  include ::RubyToken
  def Fail(err=T.unsafe(nil), *rest); end

  def Raise(err=T.unsafe(nil), *rest); end

  def char_no(); end

  def each_top_level_statement(); end

  def eof?(); end

  def exception_on_syntax_error(); end

  def exception_on_syntax_error=(exception_on_syntax_error); end

  def get_readed(); end

  def getc(); end

  def getc_of_rests(); end

  def gets(); end

  def identify_comment(); end

  def identify_gvar(); end

  def identify_here_document(); end

  def identify_identifier(); end

  def identify_number(); end

  def identify_quotation(); end

  def identify_string(ltype, quoted=T.unsafe(nil)); end

  def identify_string_dvar(); end

  def indent(); end

  def initialize_input(); end

  def lex(); end

  def lex_init(); end

  def lex_int2(); end

  def line_no(); end

  def peek(i=T.unsafe(nil)); end

  def peek_equal?(str); end

  def peek_match?(regexp); end

  def prompt(); end

  def read_escape(); end

  def readed_auto_clean_up(); end

  def readed_auto_clean_up=(readed_auto_clean_up); end

  def seek(); end

  def set_input(io, p=T.unsafe(nil), &block); end

  def set_prompt(p=T.unsafe(nil), &block); end

  def skip_space(); end

  def skip_space=(skip_space); end

  def token(); end

  def ungetc(c=T.unsafe(nil)); end
  DEINDENT_CLAUSE = ::T.let(nil, ::T.untyped)
  DLtype2Token = ::T.let(nil, ::T.untyped)
  ENINDENT_CLAUSE = ::T.let(nil, ::T.untyped)
  Ltype2Token = ::T.let(nil, ::T.untyped)
  PERCENT_LTYPE = ::T.let(nil, ::T.untyped)
  PERCENT_PAREN = ::T.let(nil, ::T.untyped)
end

class RubyLex::AlreadyDefinedToken
end

class RubyLex::AlreadyDefinedToken
end

class RubyLex::SyntaxError
end

class RubyLex::SyntaxError
end

class RubyLex::TerminateLineInput
end

class RubyLex::TerminateLineInput
end

class RubyLex::TkReading2TokenDuplicateError
end

class RubyLex::TkReading2TokenDuplicateError
end

class RubyLex::TkReading2TokenNoKey
end

class RubyLex::TkReading2TokenNoKey
end

class RubyLex::TkSymbol2TokenNoKey
end

class RubyLex::TkSymbol2TokenNoKey
end

class RubyLex
  extend ::Exception2MessageMapper
  def self.debug?(); end

  def self.debug_level(); end

  def self.debug_level=(debug_level); end

  def self.included(mod); end
end

module RubyToken
  def Token(token, value=T.unsafe(nil)); end
  EXPR_ARG = ::T.let(nil, ::T.untyped)
  EXPR_BEG = ::T.let(nil, ::T.untyped)
  EXPR_CLASS = ::T.let(nil, ::T.untyped)
  EXPR_DOT = ::T.let(nil, ::T.untyped)
  EXPR_END = ::T.let(nil, ::T.untyped)
  EXPR_FNAME = ::T.let(nil, ::T.untyped)
  EXPR_MID = ::T.let(nil, ::T.untyped)
  TkReading2Token = ::T.let(nil, ::T.untyped)
  TkSymbol2Token = ::T.let(nil, ::T.untyped)
  TokenDefinitions = ::T.let(nil, ::T.untyped)
end

class RubyToken::TkALIAS
end

class RubyToken::TkALIAS
end

class RubyToken::TkAMPER
end

class RubyToken::TkAMPER
end

class RubyToken::TkAND
end

class RubyToken::TkAND
end

class RubyToken::TkANDOP
end

class RubyToken::TkANDOP
end

class RubyToken::TkAREF
end

class RubyToken::TkAREF
end

class RubyToken::TkASET
end

class RubyToken::TkASET
end

class RubyToken::TkASSIGN
end

class RubyToken::TkASSIGN
end

class RubyToken::TkASSOC
end

class RubyToken::TkASSOC
end

class RubyToken::TkAT
end

class RubyToken::TkAT
end

class RubyToken::TkBACKQUOTE
end

class RubyToken::TkBACKQUOTE
end

class RubyToken::TkBACKSLASH
end

class RubyToken::TkBACKSLASH
end

class RubyToken::TkBACK_REF
end

class RubyToken::TkBACK_REF
end

class RubyToken::TkBEGIN
end

class RubyToken::TkBEGIN
end

class RubyToken::TkBITAND
end

class RubyToken::TkBITAND
end

class RubyToken::TkBITNOT
end

class RubyToken::TkBITNOT
end

class RubyToken::TkBITOR
end

class RubyToken::TkBITOR
end

class RubyToken::TkBITXOR
end

class RubyToken::TkBITXOR
end

class RubyToken::TkBREAK
end

class RubyToken::TkBREAK
end

class RubyToken::TkCASE
end

class RubyToken::TkCASE
end

class RubyToken::TkCLASS
end

class RubyToken::TkCLASS
end

class RubyToken::TkCMP
end

class RubyToken::TkCMP
end

class RubyToken::TkCOLON
end

class RubyToken::TkCOLON
end

class RubyToken::TkCOLON2
end

class RubyToken::TkCOLON2
end

class RubyToken::TkCOLON3
end

class RubyToken::TkCOLON3
end

class RubyToken::TkCOMMA
end

class RubyToken::TkCOMMA
end

class RubyToken::TkCOMMENT
end

class RubyToken::TkCOMMENT
end

class RubyToken::TkCONSTANT
end

class RubyToken::TkCONSTANT
end

class RubyToken::TkCVAR
end

class RubyToken::TkCVAR
end

class RubyToken::TkDEF
end

class RubyToken::TkDEF
end

class RubyToken::TkDEFINED
end

class RubyToken::TkDEFINED
end

class RubyToken::TkDIV
end

class RubyToken::TkDIV
end

class RubyToken::TkDO
end

class RubyToken::TkDO
end

class RubyToken::TkDOLLAR
end

class RubyToken::TkDOLLAR
end

class RubyToken::TkDOT
end

class RubyToken::TkDOT
end

class RubyToken::TkDOT2
end

class RubyToken::TkDOT2
end

class RubyToken::TkDOT3
end

class RubyToken::TkDOT3
end

class RubyToken::TkDREGEXP
end

class RubyToken::TkDREGEXP
end

class RubyToken::TkDSTRING
end

class RubyToken::TkDSTRING
end

class RubyToken::TkDXSTRING
end

class RubyToken::TkDXSTRING
end

class RubyToken::TkELSE
end

class RubyToken::TkELSE
end

class RubyToken::TkELSIF
end

class RubyToken::TkELSIF
end

class RubyToken::TkEND
end

class RubyToken::TkEND
end

class RubyToken::TkEND_OF_SCRIPT
end

class RubyToken::TkEND_OF_SCRIPT
end

class RubyToken::TkENSURE
end

class RubyToken::TkENSURE
end

class RubyToken::TkEQ
end

class RubyToken::TkEQ
end

class RubyToken::TkEQQ
end

class RubyToken::TkEQQ
end

class RubyToken::TkError
end

class RubyToken::TkError
end

class RubyToken::TkFALSE
end

class RubyToken::TkFALSE
end

class RubyToken::TkFID
end

class RubyToken::TkFID
end

class RubyToken::TkFLOAT
end

class RubyToken::TkFLOAT
end

class RubyToken::TkFOR
end

class RubyToken::TkFOR
end

class RubyToken::TkGEQ
end

class RubyToken::TkGEQ
end

class RubyToken::TkGT
end

class RubyToken::TkGT
end

class RubyToken::TkGVAR
end

class RubyToken::TkGVAR
end

class RubyToken::TkIDENTIFIER
end

class RubyToken::TkIDENTIFIER
end

class RubyToken::TkIF
end

class RubyToken::TkIF
end

class RubyToken::TkIF_MOD
end

class RubyToken::TkIF_MOD
end

class RubyToken::TkIN
end

class RubyToken::TkIN
end

class RubyToken::TkINTEGER
end

class RubyToken::TkINTEGER
end

class RubyToken::TkIVAR
end

class RubyToken::TkIVAR
end

class RubyToken::TkId
  def initialize(seek, line_no, char_no, name); end

  def name(); end
end

class RubyToken::TkId
end

class RubyToken::TkLBRACE
end

class RubyToken::TkLBRACE
end

class RubyToken::TkLBRACK
end

class RubyToken::TkLBRACK
end

class RubyToken::TkLEQ
end

class RubyToken::TkLEQ
end

class RubyToken::TkLPAREN
end

class RubyToken::TkLPAREN
end

class RubyToken::TkLSHFT
end

class RubyToken::TkLSHFT
end

class RubyToken::TkLT
end

class RubyToken::TkLT
end

class RubyToken::TkMATCH
end

class RubyToken::TkMATCH
end

class RubyToken::TkMINUS
end

class RubyToken::TkMINUS
end

class RubyToken::TkMOD
end

class RubyToken::TkMOD
end

class RubyToken::TkMODULE
end

class RubyToken::TkMODULE
end

class RubyToken::TkMULT
end

class RubyToken::TkMULT
end

class RubyToken::TkNEQ
end

class RubyToken::TkNEQ
end

class RubyToken::TkNEXT
end

class RubyToken::TkNEXT
end

class RubyToken::TkNIL
end

class RubyToken::TkNIL
end

class RubyToken::TkNL
end

class RubyToken::TkNL
end

class RubyToken::TkNMATCH
end

class RubyToken::TkNMATCH
end

class RubyToken::TkNOT
end

class RubyToken::TkNOT
end

class RubyToken::TkNOTOP
end

class RubyToken::TkNOTOP
end

class RubyToken::TkNTH_REF
end

class RubyToken::TkNTH_REF
end

class RubyToken::TkNode
  def node(); end
end

class RubyToken::TkNode
end

class RubyToken::TkOPASGN
  def initialize(seek, line_no, char_no, op); end

  def op(); end
end

class RubyToken::TkOPASGN
end

class RubyToken::TkOR
end

class RubyToken::TkOR
end

class RubyToken::TkOROP
end

class RubyToken::TkOROP
end

class RubyToken::TkOp
  def name(); end

  def name=(name); end
end

class RubyToken::TkOp
end

class RubyToken::TkPLUS
end

class RubyToken::TkPLUS
end

class RubyToken::TkPOW
end

class RubyToken::TkPOW
end

class RubyToken::TkQUESTION
end

class RubyToken::TkQUESTION
end

class RubyToken::TkRBRACE
end

class RubyToken::TkRBRACE
end

class RubyToken::TkRBRACK
end

class RubyToken::TkRBRACK
end

class RubyToken::TkRD_COMMENT
end

class RubyToken::TkRD_COMMENT
end

class RubyToken::TkREDO
end

class RubyToken::TkREDO
end

class RubyToken::TkREGEXP
end

class RubyToken::TkREGEXP
end

class RubyToken::TkRESCUE
end

class RubyToken::TkRESCUE
end

class RubyToken::TkRETRY
end

class RubyToken::TkRETRY
end

class RubyToken::TkRETURN
end

class RubyToken::TkRETURN
end

class RubyToken::TkRPAREN
end

class RubyToken::TkRPAREN
end

class RubyToken::TkRSHFT
end

class RubyToken::TkRSHFT
end

class RubyToken::TkSELF
end

class RubyToken::TkSELF
end

class RubyToken::TkSEMICOLON
end

class RubyToken::TkSEMICOLON
end

class RubyToken::TkSPACE
end

class RubyToken::TkSPACE
end

class RubyToken::TkSTAR
end

class RubyToken::TkSTAR
end

class RubyToken::TkSTRING
end

class RubyToken::TkSTRING
end

class RubyToken::TkSUPER
end

class RubyToken::TkSUPER
end

class RubyToken::TkSYMBEG
end

class RubyToken::TkSYMBEG
end

class RubyToken::TkSYMBOL
end

class RubyToken::TkSYMBOL
end

class RubyToken::TkTHEN
end

class RubyToken::TkTHEN
end

class RubyToken::TkTRUE
end

class RubyToken::TkTRUE
end

class RubyToken::TkUMINUS
end

class RubyToken::TkUMINUS
end

class RubyToken::TkUNDEF
end

class RubyToken::TkUNDEF
end

class RubyToken::TkUNLESS
end

class RubyToken::TkUNLESS
end

class RubyToken::TkUNLESS_MOD
end

class RubyToken::TkUNLESS_MOD
end

class RubyToken::TkUNTIL
end

class RubyToken::TkUNTIL
end

class RubyToken::TkUNTIL_MOD
end

class RubyToken::TkUNTIL_MOD
end

class RubyToken::TkUPLUS
end

class RubyToken::TkUPLUS
end

class RubyToken::TkUnknownChar
  def initialize(seek, line_no, char_no, id); end

  def name(); end
end

class RubyToken::TkUnknownChar
end

class RubyToken::TkVal
  def initialize(seek, line_no, char_no, value=T.unsafe(nil)); end

  def value(); end
end

class RubyToken::TkVal
end

class RubyToken::TkWHEN
end

class RubyToken::TkWHEN
end

class RubyToken::TkWHILE
end

class RubyToken::TkWHILE
end

class RubyToken::TkWHILE_MOD
end

class RubyToken::TkWHILE_MOD
end

class RubyToken::TkXSTRING
end

class RubyToken::TkXSTRING
end

class RubyToken::TkYIELD
end

class RubyToken::TkYIELD
end

class RubyToken::Tk__FILE__
end

class RubyToken::Tk__FILE__
end

class RubyToken::Tk__LINE__
end

class RubyToken::Tk__LINE__
end

class RubyToken::TkfLBRACE
end

class RubyToken::TkfLBRACE
end

class RubyToken::TkfLBRACK
end

class RubyToken::TkfLBRACK
end

class RubyToken::TkfLPAREN
end

class RubyToken::TkfLPAREN
end

class RubyToken::TklBEGIN
end

class RubyToken::TklBEGIN
end

class RubyToken::TklEND
end

class RubyToken::TklEND
end

class RubyToken::Token
  def char_no(); end

  def initialize(seek, line_no, char_no); end

  def line_no(); end

  def seek(); end
end

class RubyToken::Token
end

module RubyToken
  extend ::T::Sig
  def self.def_token(token_n, super_token=T.unsafe(nil), reading=T.unsafe(nil), *opts); end
end

class RubyVM::Env
end

class RubyVM::Env
end

class RubyVM::InstructionSequence
  def absolute_path(); end

  def base_label(); end

  def disasm(); end

  def disassemble(); end

  def eval(); end

  def first_lineno(); end

  def label(); end

  def path(); end

  def to_a(); end

  def to_binary(*_); end
end

class RubyVM::InstructionSequence
  extend ::T::Sig
  def self.compile(*_); end

  def self.compile_file(*_); end

  def self.compile_option(); end

  def self.compile_option=(compile_option); end

  def self.disasm(_); end

  def self.disassemble(_); end

  def self.load_from_binary(_); end

  def self.load_from_binary_extra_data(_); end

  def self.of(_); end
end

class RubyVM
  extend ::T::Sig
  def self.stat(*_); end
end

class RuntimeError
  extend ::T::Sig
end

module Scanf
end

class Scanf::FormatSpecifier
  def conversion(); end

  def count_space?(); end

  def initialize(str); end

  def letter(); end

  def match(str); end

  def matched(); end

  def matched_string(); end

  def mid_match?(); end

  def re_string(); end

  def to_re(); end

  def width(); end
end

class Scanf::FormatSpecifier
end

class Scanf::FormatString
  def initialize(str); end

  def last_match_tried(); end

  def last_spec(); end

  def last_spec_tried(); end

  def match(str); end

  def matched_count(); end

  def prune(n=T.unsafe(nil)); end

  def space(); end

  def spec_count(); end

  def string_left(); end
  REGEX = ::T.let(nil, ::T.untyped)
  SPECIFIERS = ::T.let(nil, ::T.untyped)
end

class Scanf::FormatString
end

module Scanf
  extend ::T::Sig
end

class ScriptError
  extend ::T::Sig
end

module SecureRandom
  extend ::Random::Formatter
  extend ::T::Sig
end

class SecurityError
  extend ::T::Sig
end

module SemanticPuppet::Dependency::GraphNode
  extend ::T::Sig
end

module SemanticPuppet::Dependency
  extend ::T::Sig
end

module SemanticPuppet
  extend ::T::Sig
end

class Set
  def ==(other); end

  def divide(&func); end

  def eql?(o); end

  def flatten_merge(set, seen=T.unsafe(nil)); end

  def pretty_print(pp); end

  def pretty_print_cycle(pp); end
  InspectKey = ::T.let(nil, ::T.untyped)
end

class Set
  extend ::T::Sig
end

module Shellwords
end

module Shellwords
  extend ::T::Sig
  def self.escape(str); end

  def self.join(array); end

  def self.shellescape(str); end

  def self.shelljoin(array); end

  def self.shellsplit(line); end

  def self.shellwords(line); end

  def self.split(line); end
end

module Signal
  extend ::T::Sig
end

class SignalException
  def signm(); end

  def signo(); end
end

class SignalException
  extend ::T::Sig
end

class SimpleDelegator
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class SimpleDelegator
  extend ::T::Sig
end

module SingleForwardable
  def def_delegator(accessor, method, ali=T.unsafe(nil)); end

  def def_delegators(accessor, *methods); end

  def def_single_delegator(accessor, method, ali=T.unsafe(nil)); end

  def def_single_delegators(accessor, *methods); end

  def delegate(hash); end

  def single_delegate(hash); end
end

module SingleForwardable
  extend ::T::Sig
end

module Singleton
  def _dump(depth=T.unsafe(nil)); end

  def clone(); end

  def dup(); end
end

module Singleton::SingletonClassMethods
  def _load(str); end

  def clone(); end
end

module Singleton::SingletonClassMethods
  extend ::T::Sig
end

module Singleton
  extend ::T::Sig
  def self.__init__(klass); end
end

SizedQueue = Thread::SizedQueue

class Socket
  AF_CCITT = ::T.let(nil, ::T.untyped)
  AF_CHAOS = ::T.let(nil, ::T.untyped)
  AF_CNT = ::T.let(nil, ::T.untyped)
  AF_COIP = ::T.let(nil, ::T.untyped)
  AF_DATAKIT = ::T.let(nil, ::T.untyped)
  AF_DLI = ::T.let(nil, ::T.untyped)
  AF_E164 = ::T.let(nil, ::T.untyped)
  AF_ECMA = ::T.let(nil, ::T.untyped)
  AF_HYLINK = ::T.let(nil, ::T.untyped)
  AF_IMPLINK = ::T.let(nil, ::T.untyped)
  AF_ISO = ::T.let(nil, ::T.untyped)
  AF_LAT = ::T.let(nil, ::T.untyped)
  AF_LINK = ::T.let(nil, ::T.untyped)
  AF_NATM = ::T.let(nil, ::T.untyped)
  AF_NDRV = ::T.let(nil, ::T.untyped)
  AF_NETBIOS = ::T.let(nil, ::T.untyped)
  AF_NS = ::T.let(nil, ::T.untyped)
  AF_OSI = ::T.let(nil, ::T.untyped)
  AF_PPP = ::T.let(nil, ::T.untyped)
  AF_PUP = ::T.let(nil, ::T.untyped)
  AF_SIP = ::T.let(nil, ::T.untyped)
  AF_SYSTEM = ::T.let(nil, ::T.untyped)
  AI_DEFAULT = ::T.let(nil, ::T.untyped)
  AI_MASK = ::T.let(nil, ::T.untyped)
  AI_V4MAPPED_CFG = ::T.let(nil, ::T.untyped)
  EAI_BADHINTS = ::T.let(nil, ::T.untyped)
  EAI_MAX = ::T.let(nil, ::T.untyped)
  EAI_PROTOCOL = ::T.let(nil, ::T.untyped)
  IFF_ALTPHYS = ::T.let(nil, ::T.untyped)
  IFF_LINK0 = ::T.let(nil, ::T.untyped)
  IFF_LINK1 = ::T.let(nil, ::T.untyped)
  IFF_LINK2 = ::T.let(nil, ::T.untyped)
  IFF_OACTIVE = ::T.let(nil, ::T.untyped)
  IFF_SIMPLEX = ::T.let(nil, ::T.untyped)
  IPPROTO_EON = ::T.let(nil, ::T.untyped)
  IPPROTO_GGP = ::T.let(nil, ::T.untyped)
  IPPROTO_HELLO = ::T.let(nil, ::T.untyped)
  IPPROTO_MAX = ::T.let(nil, ::T.untyped)
  IPPROTO_ND = ::T.let(nil, ::T.untyped)
  IPPROTO_XTP = ::T.let(nil, ::T.untyped)
  IPV6_DONTFRAG = ::T.let(nil, ::T.untyped)
  IPV6_PATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_RECVPATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_USE_MIN_MTU = ::T.let(nil, ::T.untyped)
  IP_PORTRANGE = ::T.let(nil, ::T.untyped)
  IP_RECVDSTADDR = ::T.let(nil, ::T.untyped)
  IP_RECVIF = ::T.let(nil, ::T.untyped)
  LOCAL_PEERCRED = ::T.let(nil, ::T.untyped)
  MSG_EOF = ::T.let(nil, ::T.untyped)
  MSG_FLUSH = ::T.let(nil, ::T.untyped)
  MSG_HAVEMORE = ::T.let(nil, ::T.untyped)
  MSG_HOLD = ::T.let(nil, ::T.untyped)
  MSG_RCVMORE = ::T.let(nil, ::T.untyped)
  MSG_SEND = ::T.let(nil, ::T.untyped)
  PF_CCITT = ::T.let(nil, ::T.untyped)
  PF_CHAOS = ::T.let(nil, ::T.untyped)
  PF_CNT = ::T.let(nil, ::T.untyped)
  PF_COIP = ::T.let(nil, ::T.untyped)
  PF_DATAKIT = ::T.let(nil, ::T.untyped)
  PF_DLI = ::T.let(nil, ::T.untyped)
  PF_ECMA = ::T.let(nil, ::T.untyped)
  PF_HYLINK = ::T.let(nil, ::T.untyped)
  PF_IMPLINK = ::T.let(nil, ::T.untyped)
  PF_ISO = ::T.let(nil, ::T.untyped)
  PF_LAT = ::T.let(nil, ::T.untyped)
  PF_LINK = ::T.let(nil, ::T.untyped)
  PF_NATM = ::T.let(nil, ::T.untyped)
  PF_NDRV = ::T.let(nil, ::T.untyped)
  PF_NETBIOS = ::T.let(nil, ::T.untyped)
  PF_NS = ::T.let(nil, ::T.untyped)
  PF_OSI = ::T.let(nil, ::T.untyped)
  PF_PIP = ::T.let(nil, ::T.untyped)
  PF_PPP = ::T.let(nil, ::T.untyped)
  PF_PUP = ::T.let(nil, ::T.untyped)
  PF_RTIP = ::T.let(nil, ::T.untyped)
  PF_SIP = ::T.let(nil, ::T.untyped)
  PF_SYSTEM = ::T.let(nil, ::T.untyped)
  PF_XTP = ::T.let(nil, ::T.untyped)
  SCM_CREDS = ::T.let(nil, ::T.untyped)
  SO_DONTTRUNC = ::T.let(nil, ::T.untyped)
  SO_NKE = ::T.let(nil, ::T.untyped)
  SO_NOSIGPIPE = ::T.let(nil, ::T.untyped)
  SO_NREAD = ::T.let(nil, ::T.untyped)
  SO_USELOOPBACK = ::T.let(nil, ::T.untyped)
  SO_WANTMORE = ::T.let(nil, ::T.untyped)
  SO_WANTOOBFLAG = ::T.let(nil, ::T.untyped)
  TCP_NOOPT = ::T.let(nil, ::T.untyped)
  TCP_NOPUSH = ::T.let(nil, ::T.untyped)
end

class Socket::AncillaryData
  extend ::T::Sig
end

module Socket::Constants
  AF_CCITT = ::T.let(nil, ::T.untyped)
  AF_CHAOS = ::T.let(nil, ::T.untyped)
  AF_CNT = ::T.let(nil, ::T.untyped)
  AF_COIP = ::T.let(nil, ::T.untyped)
  AF_DATAKIT = ::T.let(nil, ::T.untyped)
  AF_DLI = ::T.let(nil, ::T.untyped)
  AF_E164 = ::T.let(nil, ::T.untyped)
  AF_ECMA = ::T.let(nil, ::T.untyped)
  AF_HYLINK = ::T.let(nil, ::T.untyped)
  AF_IMPLINK = ::T.let(nil, ::T.untyped)
  AF_ISO = ::T.let(nil, ::T.untyped)
  AF_LAT = ::T.let(nil, ::T.untyped)
  AF_LINK = ::T.let(nil, ::T.untyped)
  AF_NATM = ::T.let(nil, ::T.untyped)
  AF_NDRV = ::T.let(nil, ::T.untyped)
  AF_NETBIOS = ::T.let(nil, ::T.untyped)
  AF_NS = ::T.let(nil, ::T.untyped)
  AF_OSI = ::T.let(nil, ::T.untyped)
  AF_PPP = ::T.let(nil, ::T.untyped)
  AF_PUP = ::T.let(nil, ::T.untyped)
  AF_SIP = ::T.let(nil, ::T.untyped)
  AF_SYSTEM = ::T.let(nil, ::T.untyped)
  AI_DEFAULT = ::T.let(nil, ::T.untyped)
  AI_MASK = ::T.let(nil, ::T.untyped)
  AI_V4MAPPED_CFG = ::T.let(nil, ::T.untyped)
  EAI_BADHINTS = ::T.let(nil, ::T.untyped)
  EAI_MAX = ::T.let(nil, ::T.untyped)
  EAI_PROTOCOL = ::T.let(nil, ::T.untyped)
  IFF_ALTPHYS = ::T.let(nil, ::T.untyped)
  IFF_LINK0 = ::T.let(nil, ::T.untyped)
  IFF_LINK1 = ::T.let(nil, ::T.untyped)
  IFF_LINK2 = ::T.let(nil, ::T.untyped)
  IFF_OACTIVE = ::T.let(nil, ::T.untyped)
  IFF_SIMPLEX = ::T.let(nil, ::T.untyped)
  IPPROTO_EON = ::T.let(nil, ::T.untyped)
  IPPROTO_GGP = ::T.let(nil, ::T.untyped)
  IPPROTO_HELLO = ::T.let(nil, ::T.untyped)
  IPPROTO_MAX = ::T.let(nil, ::T.untyped)
  IPPROTO_ND = ::T.let(nil, ::T.untyped)
  IPPROTO_XTP = ::T.let(nil, ::T.untyped)
  IPV6_DONTFRAG = ::T.let(nil, ::T.untyped)
  IPV6_PATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_RECVPATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_USE_MIN_MTU = ::T.let(nil, ::T.untyped)
  IP_PORTRANGE = ::T.let(nil, ::T.untyped)
  IP_RECVDSTADDR = ::T.let(nil, ::T.untyped)
  IP_RECVIF = ::T.let(nil, ::T.untyped)
  LOCAL_PEERCRED = ::T.let(nil, ::T.untyped)
  MSG_EOF = ::T.let(nil, ::T.untyped)
  MSG_FLUSH = ::T.let(nil, ::T.untyped)
  MSG_HAVEMORE = ::T.let(nil, ::T.untyped)
  MSG_HOLD = ::T.let(nil, ::T.untyped)
  MSG_RCVMORE = ::T.let(nil, ::T.untyped)
  MSG_SEND = ::T.let(nil, ::T.untyped)
  PF_CCITT = ::T.let(nil, ::T.untyped)
  PF_CHAOS = ::T.let(nil, ::T.untyped)
  PF_CNT = ::T.let(nil, ::T.untyped)
  PF_COIP = ::T.let(nil, ::T.untyped)
  PF_DATAKIT = ::T.let(nil, ::T.untyped)
  PF_DLI = ::T.let(nil, ::T.untyped)
  PF_ECMA = ::T.let(nil, ::T.untyped)
  PF_HYLINK = ::T.let(nil, ::T.untyped)
  PF_IMPLINK = ::T.let(nil, ::T.untyped)
  PF_ISO = ::T.let(nil, ::T.untyped)
  PF_LAT = ::T.let(nil, ::T.untyped)
  PF_LINK = ::T.let(nil, ::T.untyped)
  PF_NATM = ::T.let(nil, ::T.untyped)
  PF_NDRV = ::T.let(nil, ::T.untyped)
  PF_NETBIOS = ::T.let(nil, ::T.untyped)
  PF_NS = ::T.let(nil, ::T.untyped)
  PF_OSI = ::T.let(nil, ::T.untyped)
  PF_PIP = ::T.let(nil, ::T.untyped)
  PF_PPP = ::T.let(nil, ::T.untyped)
  PF_PUP = ::T.let(nil, ::T.untyped)
  PF_RTIP = ::T.let(nil, ::T.untyped)
  PF_SIP = ::T.let(nil, ::T.untyped)
  PF_SYSTEM = ::T.let(nil, ::T.untyped)
  PF_XTP = ::T.let(nil, ::T.untyped)
  SCM_CREDS = ::T.let(nil, ::T.untyped)
  SO_DONTTRUNC = ::T.let(nil, ::T.untyped)
  SO_NKE = ::T.let(nil, ::T.untyped)
  SO_NOSIGPIPE = ::T.let(nil, ::T.untyped)
  SO_NREAD = ::T.let(nil, ::T.untyped)
  SO_USELOOPBACK = ::T.let(nil, ::T.untyped)
  SO_WANTMORE = ::T.let(nil, ::T.untyped)
  SO_WANTOOBFLAG = ::T.let(nil, ::T.untyped)
  TCP_NOOPT = ::T.let(nil, ::T.untyped)
  TCP_NOPUSH = ::T.let(nil, ::T.untyped)
end

module Socket::Constants
  extend ::T::Sig
end

class Socket::Ifaddr
  extend ::T::Sig
end

class Socket::Option
  extend ::T::Sig
end

class Socket::UDPSource
  extend ::T::Sig
end

class Socket
  extend ::T::Sig
end

class SocketError
  extend ::T::Sig
end

class Sorbet::Private::ConstantLookupCache::ConstantEntry
  def self.[](*_); end

  def self.members(); end
end

class Sorbet::Private::GemGeneratorTracepoint::ClassDefinition
  def self.[](*_); end

  def self.members(); end
end

module Sorbet::Private::GemGeneratorTracepoint
  extend ::T::Sig
end

class Sorbet::Private::GemLoader
  GEM_LOADER = ::T.let(nil, ::T.untyped)
  NO_GEM = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::GemLoader
  def self.my_require(gem); end
end

module Sorbet::Private::Main
end

module Sorbet::Private::Main
  extend ::T::Sig
  def self.cyan(msg); end

  def self.emojify(emoji, msg); end

  def self.main(argv); end

  def self.make_step(step); end

  def self.parse_command(argv); end

  def self.yellow(msg); end
end

module Sorbet::Private::RealStdlib
  extend ::T::Sig
end

module Sorbet::Private::Status
  extend ::T::Sig
end

module Sorbet::Private::StepInterface
  extend ::T::Sig
end

module Sorbet::Private
  extend ::T::Sig
end

class Sorbet
  extend ::T::Sig
end

class SortedSet
  def initialize(*args, &block); end
end

class SortedSet
  extend ::T::Sig
  def self.setup(); end
end

class StandardError
  extend ::T::Sig
end

class StopIteration
  def result(); end
end

class StopIteration
  extend ::T::Sig
end

class String
  include ::PSON::Pure::Generator::GeneratorMethods::String
  include ::JSON::Ext::Generator::GeneratorMethods::String
  def +@(); end

  def -@(); end

  def []=(*_); end

  def block_scanf(fstr); end

  def encode(*_); end

  def encode!(*_); end

  def iseuc(); end

  def isjis(); end

  def issjis(); end

  def isutf8(); end

  def kconv(to_enc, from_enc=T.unsafe(nil)); end

  def reverse!(); end

  def scanf(fstr, &b); end

  def shellescape(); end

  def shellsplit(); end

  def succ!(); end

  def toeuc(); end

  def tojis(); end

  def tolocale(); end

  def tosjis(); end

  def toutf16(); end

  def toutf32(); end

  def toutf8(); end

  def unicode_normalize(form=T.unsafe(nil)); end

  def unicode_normalize!(form=T.unsafe(nil)); end

  def unicode_normalized?(form=T.unsafe(nil)); end

end

class String
  extend ::T::Sig
end

class StringIO
  def length(); end

  def truncate(_); end
end

class StringIO
  extend ::T::Sig
end

class StringScanner
  def <<(_); end

  def [](_); end

  def beginning_of_line?(); end

  def bol?(); end

  def charpos(); end

  def check(_); end

  def check_until(_); end

  def clear(); end

  def concat(_); end

  def empty?(); end

  def exist?(_); end

  def get_byte(); end

  def getbyte(); end

  def initialize(*_); end

  def match?(_); end

  def matched(); end

  def matched?(); end

  def matched_size(); end

  def peek(_); end

  def peep(_); end

  def pointer(); end

  def pointer=(pointer); end

  def pos(); end

  def pos=(pos); end

  def post_match(); end

  def pre_match(); end

  def reset(); end

  def rest(); end

  def rest?(); end

  def rest_size(); end

  def restsize(); end

  def scan_full(_, _1, _2); end

  def scan_until(_); end

  def search_full(_, _1, _2); end

  def skip(_); end

  def skip_until(_); end

  def string(); end

  def string=(string); end

  def terminate(); end

  def unscan(); end
  Id = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class StringScanner::Error
  extend ::T::Sig
end

class StringScanner
  extend ::T::Sig
  def self.must_C_version(); end
end

class Struct
  def [](_); end

  def []=(_, _1); end

  def dig(*_); end

  def each_pair(); end

  def length(); end

  def members(); end

  def select(*_); end

  def size(); end

  def to_a(); end

  def to_h(); end

  def values(); end

  def values_at(*_); end
end

Struct::Group = Etc::Group

Struct::Passwd = Etc::Passwd

Struct::Tms = Process::Tms

class Struct
  extend ::T::Sig
end

class Symbol
  def next(); end

end

class Symbol
  extend ::T::Sig
end

class Sync
  include ::Sync_m
  def exclusive?(); end

  def lock(m=T.unsafe(nil)); end

  def locked?(); end

  def shared?(); end

  def synchronize(mode=T.unsafe(nil)); end

  def try_lock(mode=T.unsafe(nil)); end

  def unlock(m=T.unsafe(nil)); end
end

class Sync
end

module Sync_m
  def initialize(*args); end

  def sync_ex_count(); end

  def sync_ex_count=(sync_ex_count); end

  def sync_ex_locker(); end

  def sync_ex_locker=(sync_ex_locker); end

  def sync_exclusive?(); end

  def sync_extend(); end

  def sync_inspect(); end

  def sync_lock(m=T.unsafe(nil)); end

  def sync_locked?(); end

  def sync_mode(); end

  def sync_mode=(sync_mode); end

  def sync_sh_locker(); end

  def sync_sh_locker=(sync_sh_locker); end

  def sync_shared?(); end

  def sync_synchronize(mode=T.unsafe(nil)); end

  def sync_try_lock(mode=T.unsafe(nil)); end

  def sync_unlock(m=T.unsafe(nil)); end

  def sync_upgrade_waiting(); end

  def sync_upgrade_waiting=(sync_upgrade_waiting); end

  def sync_waiting(); end

  def sync_waiting=(sync_waiting); end
  EX = ::T.let(nil, ::T.untyped)
  SH = ::T.let(nil, ::T.untyped)
  UN = ::T.let(nil, ::T.untyped)
end

class Sync_m::Err
end

class Sync_m::Err::LockModeFailer
  Message = ::T.let(nil, ::T.untyped)
end

class Sync_m::Err::LockModeFailer
  def self.Fail(mode); end
end

class Sync_m::Err::UnknownLocker
  Message = ::T.let(nil, ::T.untyped)
end

class Sync_m::Err::UnknownLocker
  def self.Fail(th); end
end

class Sync_m::Err
  def self.Fail(*opt); end
end

module Sync_m
  extend ::T::Sig
  def self.append_features(cl); end

  def self.define_aliases(cl); end

  def self.extend_object(obj); end
end

Synchronizer = Sync

Synchronizer_m = Sync_m

class SyntaxError
  extend ::T::Sig
end

module Syslog
  include ::Syslog::Constants
  include ::Syslog::Option
  include ::Syslog::Facility
  include ::Syslog::Level
  include ::Syslog::Macros
end

module Syslog::Constants
  include ::Syslog::Option
  include ::Syslog::Facility
  include ::Syslog::Level
  include ::Syslog::Macros
end

module Syslog::Constants
  extend ::Syslog::Macros
  extend ::T::Sig
end

module Syslog::Facility
  LOG_AUTH = ::T.let(nil, ::T.untyped)
  LOG_AUTHPRIV = ::T.let(nil, ::T.untyped)
  LOG_CRON = ::T.let(nil, ::T.untyped)
  LOG_DAEMON = ::T.let(nil, ::T.untyped)
  LOG_FTP = ::T.let(nil, ::T.untyped)
  LOG_KERN = ::T.let(nil, ::T.untyped)
  LOG_LOCAL0 = ::T.let(nil, ::T.untyped)
  LOG_LOCAL1 = ::T.let(nil, ::T.untyped)
  LOG_LOCAL2 = ::T.let(nil, ::T.untyped)
  LOG_LOCAL3 = ::T.let(nil, ::T.untyped)
  LOG_LOCAL4 = ::T.let(nil, ::T.untyped)
  LOG_LOCAL5 = ::T.let(nil, ::T.untyped)
  LOG_LOCAL6 = ::T.let(nil, ::T.untyped)
  LOG_LOCAL7 = ::T.let(nil, ::T.untyped)
  LOG_LPR = ::T.let(nil, ::T.untyped)
  LOG_MAIL = ::T.let(nil, ::T.untyped)
  LOG_NEWS = ::T.let(nil, ::T.untyped)
  LOG_SYSLOG = ::T.let(nil, ::T.untyped)
  LOG_USER = ::T.let(nil, ::T.untyped)
  LOG_UUCP = ::T.let(nil, ::T.untyped)
end

module Syslog::Facility
  extend ::T::Sig
end

module Syslog::Level
  LOG_ALERT = ::T.let(nil, ::T.untyped)
  LOG_CRIT = ::T.let(nil, ::T.untyped)
  LOG_DEBUG = ::T.let(nil, ::T.untyped)
  LOG_EMERG = ::T.let(nil, ::T.untyped)
  LOG_ERR = ::T.let(nil, ::T.untyped)
  LOG_INFO = ::T.let(nil, ::T.untyped)
  LOG_NOTICE = ::T.let(nil, ::T.untyped)
  LOG_WARNING = ::T.let(nil, ::T.untyped)
end

module Syslog::Level
  extend ::T::Sig
end

module Syslog::Macros
  def LOG_MASK(_); end

  def LOG_UPTO(_); end
end

module Syslog::Macros
  extend ::T::Sig
end

module Syslog::Option
  LOG_CONS = ::T.let(nil, ::T.untyped)
  LOG_NDELAY = ::T.let(nil, ::T.untyped)
  LOG_NOWAIT = ::T.let(nil, ::T.untyped)
  LOG_ODELAY = ::T.let(nil, ::T.untyped)
  LOG_PERROR = ::T.let(nil, ::T.untyped)
  LOG_PID = ::T.let(nil, ::T.untyped)
end

module Syslog::Option
  extend ::T::Sig
end

module Syslog
  extend ::Syslog::Macros
  extend ::T::Sig
  def self.alert(*_); end

  def self.close(); end

  def self.crit(*_); end

  def self.debug(*_); end

  def self.emerg(*_); end

  def self.err(*_); end

  def self.facility(); end

  def self.ident(); end

  def self.info(*_); end

  def self.instance(); end

  def self.log(*_); end

  def self.mask(); end

  def self.mask=(mask); end

  def self.notice(*_); end

  def self.open(*_); end

  def self.open!(*_); end

  def self.opened?(); end

  def self.options(); end

  def self.reopen(*_); end

  def self.warning(*_); end
end

class SystemCallError
  def errno(); end
end

class SystemCallError
  extend ::T::Sig
end

class SystemExit
  def status(); end

  def success?(); end
end

class SystemExit
  extend ::T::Sig
end

class SystemStackError
  extend ::T::Sig
end

class TCPServer
  extend ::T::Sig
end

class TCPSocket
  extend ::T::Sig
end

class TSort::Cyclic
  extend ::T::Sig
end

module TSort
  extend ::T::Sig
end

class Tempfile
  def _close(); end

  def inspect(); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Tempfile::Remover
  def call(*args); end

  def initialize(tmpfile); end
end

class Tempfile::Remover
end

class Thread
  def abort_on_exception(); end

  def abort_on_exception=(abort_on_exception); end

  def add_trace_func(_); end

  def backtrace(*_); end

  def backtrace_locations(*_); end

  def exit(); end

  def group(); end

  def initialize(*_); end

  def join(*_); end

  def key?(_); end

  def keys(); end

  def name(); end

  def name=(name); end

  def pending_interrupt?(*_); end

  def priority(); end

  def priority=(priority); end

  def run(); end

  def safe_level(); end

  def status(); end

  def stop?(); end

  def terminate(); end

  def thread_variable?(_); end

  def thread_variable_get(_); end

  def thread_variable_set(_, _1); end

  def thread_variables(); end

  def value(); end

  def wakeup(); end
  MUTEX_FOR_THREAD_EXCLUSIVE = ::T.let(nil, ::T.untyped)
end

class Thread::Backtrace::Location
  extend ::T::Sig
end

class Thread::Backtrace
  extend ::T::Sig
end

class Thread::ConditionVariable
  def broadcast(); end

  def marshal_dump(); end

  def signal(); end

  def wait(*_); end
end

class Thread::ConditionVariable
  extend ::T::Sig
end

class Thread::Mutex
  def lock(); end

  def locked?(); end

  def owned?(); end

  def synchronize(); end

  def try_lock(); end

  def unlock(); end
end

class Thread::Mutex
  extend ::T::Sig
end

class Thread::Queue
  def <<(_); end

  def clear(); end

  def close(); end

  def closed?(); end

  def deq(*_); end

  def empty?(); end

  def enq(_); end

  def length(); end

  def marshal_dump(); end

  def num_waiting(); end

  def pop(*_); end

  def push(_); end

  def shift(*_); end

  def size(); end
end

class Thread::Queue
  extend ::T::Sig
end

class Thread::SizedQueue
  def <<(*_); end

  def enq(*_); end

  def initialize(_); end

  def max(); end

  def max=(max); end

  def push(*_); end
end

class Thread::SizedQueue
  extend ::T::Sig
end

class Thread
  extend ::T::Sig
  def self.abort_on_exception(); end

  def self.abort_on_exception=(abort_on_exception); end

  def self.exclusive(); end

  def self.exit(); end

  def self.fork(*_); end

  def self.handle_interrupt(_); end

  def self.kill(_); end

  def self.list(); end

  def self.pass(); end

  def self.pending_interrupt?(*_); end

  def self.start(*_); end

  def self.stop(); end
end

class ThreadError
  extend ::T::Sig
end

class ThreadGroup
  def add(_); end

  def enclose(); end

  def enclosed?(); end

  def list(); end
  Default = ::T.let(nil, ::T.untyped)
end

class ThreadGroup
  extend ::T::Sig
end

class Time
  extend ::T::Sig
end

class Timeout::Error
  extend ::T::Sig
end

module Timeout
  extend ::T::Sig
end

class TracePoint
  def event(); end
end

class TracePoint
  extend ::T::Sig
end

class TrueClass
  include ::PSON::Pure::Generator::GeneratorMethods::TrueClass
  include ::JSON::Ext::Generator::GeneratorMethods::TrueClass
end

class TrueClass
  extend ::T::Sig
end

class TypeError
  extend ::T::Sig
end

class UDPSocket
  extend ::T::Sig
end

class UNIXServer
  extend ::T::Sig
end

class UNIXSocket
  extend ::T::Sig
end

module URI
  include ::URI::RFC2396_REGEXP
end

class URI::BadURIError
  extend ::T::Sig
end

class URI::Error
  extend ::T::Sig
end

module URI::Escape
  def decode(*arg); end

  def encode(*arg); end

  def escape(*arg); end

  def unescape(*arg); end
end

module URI::Escape
  extend ::T::Sig
end

class URI::FTP
  include ::OpenURI::OpenRead
  def buffer_open(buf, proxy, options); end

  def set_typecode(v); end

  def typecode(); end

  def typecode=(typecode); end
end

class URI::FTP
  extend ::T::Sig
  def self.new2(user, password, host, port, path, typecode=T.unsafe(nil), arg_check=T.unsafe(nil)); end
end

class URI::Generic
  def +(oth); end

  def -(oth); end

  def ==(oth); end

  def absolute(); end

  def absolute?(); end

  def coerce(oth); end

  def component(); end

  def component_ary(); end

  def default_port(); end

  def eql?(oth); end

  def find_proxy(); end

  def fragment(); end

  def fragment=(v); end

  def hierarchical?(); end

  def host(); end

  def host=(v); end

  def hostname=(v); end

  def initialize(scheme, userinfo, host, port, registry, path, opaque, query, fragment, parser=T.unsafe(nil), arg_check=T.unsafe(nil)); end

  def merge(oth); end

  def merge!(oth); end

  def normalize(); end

  def normalize!(); end

  def opaque(); end

  def opaque=(v); end

  def parser(); end

  def password(); end

  def password=(password); end

  def path(); end

  def path=(v); end

  def port(); end

  def port=(v); end

  def query(); end

  def query=(v); end

  def registry(); end

  def registry=(v); end

  def relative?(); end

  def route_from(oth); end

  def route_to(oth); end

  def scheme(); end

  def scheme=(v); end

  def select(*components); end

  def set_host(v); end

  def set_opaque(v); end

  def set_password(v); end

  def set_path(v); end

  def set_port(v); end

  def set_registry(v); end

  def set_scheme(v); end

  def set_user(v); end

  def set_userinfo(user, password=T.unsafe(nil)); end

  def user(); end

  def user=(user); end

  def userinfo(); end

  def userinfo=(userinfo); end
end

class URI::Generic
  extend ::T::Sig
  def self.build(args); end

  def self.build2(args); end

  def self.component(); end

  def self.default_port(); end

  def self.use_registry(); end
end

class URI::HTTP
  include ::OpenURI::OpenRead
  def buffer_open(buf, proxy, options); end

  def request_uri(); end
end

class URI::HTTP
  extend ::T::Sig
end

class URI::HTTPS
  extend ::T::Sig
end

class URI::InvalidComponentError
  extend ::T::Sig
end

class URI::InvalidURIError
  extend ::T::Sig
end

class URI::LDAP
  def attributes(); end

  def attributes=(val); end

  def dn(); end

  def dn=(val); end

  def extensions(); end

  def extensions=(val); end

  def filter(); end

  def filter=(val); end

  def initialize(*arg); end

  def scope(); end

  def scope=(val); end

  def set_attributes(val); end

  def set_dn(val); end

  def set_extensions(val); end

  def set_filter(val); end

  def set_scope(val); end
end

class URI::LDAP
  extend ::T::Sig
end

class URI::LDAPS
  extend ::T::Sig
end

class URI::MailTo
  def headers(); end

  def headers=(v); end

  def initialize(*arg); end

  def set_headers(v); end

  def set_to(v); end

  def to(); end

  def to=(v); end

  def to_mailtext(); end

  def to_rfc822text(); end
end

class URI::MailTo
  extend ::T::Sig
end

URI::Parser = URI::RFC2396_Parser

URI::REGEXP = URI::RFC2396_REGEXP

class URI::RFC2396_Parser
  def escape(str, unsafe=T.unsafe(nil)); end

  def extract(str, schemes=T.unsafe(nil)); end

  def initialize(opts=T.unsafe(nil)); end

  def join(*uris); end

  def make_regexp(schemes=T.unsafe(nil)); end

  def parse(uri); end

  def pattern(); end

  def regexp(); end

  def split(uri); end

  def unescape(str, escaped=T.unsafe(nil)); end
end

class URI::RFC2396_Parser
  extend ::T::Sig
end

module URI::RFC2396_REGEXP::PATTERN
  extend ::T::Sig
end

module URI::RFC2396_REGEXP
  extend ::T::Sig
end

class URI::RFC3986_Parser
  def join(*uris); end

  def parse(uri); end

  def regexp(); end

  def split(uri); end
  RFC3986_relative_ref = ::T.let(nil, ::T.untyped)
end

class URI::RFC3986_Parser
  extend ::T::Sig
end

module URI::Util
  extend ::T::Sig
  def self.make_components_hash(klass, array_hash); end
end

module URI
  extend ::T::Sig
  extend ::URI::Escape
  def self.encode_www_form(enum, enc=T.unsafe(nil)); end

  def self.get_encoding(label); end
end

class UnboundMethod
  def original_name(); end
end

class UnboundMethod
  extend ::T::Sig
end

class UncaughtThrowError
  def tag(); end

  def value(); end
end

class UncaughtThrowError
  extend ::T::Sig
end

class WEBrick::HTTPServlet::AbstractServlet
  extend ::T::Sig
end

class ZeroDivisionError
  extend ::T::Sig
end

module Zlib
  ASCII = ::T.let(nil, ::T.untyped)
  BEST_COMPRESSION = ::T.let(nil, ::T.untyped)
  BEST_SPEED = ::T.let(nil, ::T.untyped)
  BINARY = ::T.let(nil, ::T.untyped)
  DEFAULT_COMPRESSION = ::T.let(nil, ::T.untyped)
  DEFAULT_STRATEGY = ::T.let(nil, ::T.untyped)
  DEF_MEM_LEVEL = ::T.let(nil, ::T.untyped)
  FILTERED = ::T.let(nil, ::T.untyped)
  FINISH = ::T.let(nil, ::T.untyped)
  FIXED = ::T.let(nil, ::T.untyped)
  FULL_FLUSH = ::T.let(nil, ::T.untyped)
  HUFFMAN_ONLY = ::T.let(nil, ::T.untyped)
  MAX_MEM_LEVEL = ::T.let(nil, ::T.untyped)
  MAX_WBITS = ::T.let(nil, ::T.untyped)
  NO_COMPRESSION = ::T.let(nil, ::T.untyped)
  NO_FLUSH = ::T.let(nil, ::T.untyped)
  OS_AMIGA = ::T.let(nil, ::T.untyped)
  OS_ATARI = ::T.let(nil, ::T.untyped)
  OS_CODE = ::T.let(nil, ::T.untyped)
  OS_CPM = ::T.let(nil, ::T.untyped)
  OS_MACOS = ::T.let(nil, ::T.untyped)
  OS_MSDOS = ::T.let(nil, ::T.untyped)
  OS_OS2 = ::T.let(nil, ::T.untyped)
  OS_QDOS = ::T.let(nil, ::T.untyped)
  OS_RISCOS = ::T.let(nil, ::T.untyped)
  OS_TOPS20 = ::T.let(nil, ::T.untyped)
  OS_UNIX = ::T.let(nil, ::T.untyped)
  OS_UNKNOWN = ::T.let(nil, ::T.untyped)
  OS_VMCMS = ::T.let(nil, ::T.untyped)
  OS_VMS = ::T.let(nil, ::T.untyped)
  OS_WIN32 = ::T.let(nil, ::T.untyped)
  OS_ZSYSTEM = ::T.let(nil, ::T.untyped)
  RLE = ::T.let(nil, ::T.untyped)
  SYNC_FLUSH = ::T.let(nil, ::T.untyped)
  TEXT = ::T.let(nil, ::T.untyped)
  UNKNOWN = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  ZLIB_VERSION = ::T.let(nil, ::T.untyped)
end

class Zlib::BufError
end

class Zlib::BufError
end

class Zlib::DataError
end

class Zlib::DataError
end

class Zlib::Deflate
  def <<(_); end

  def deflate(*_); end

  def flush(*_); end

  def initialize(*_); end

  def params(_, _1); end

  def set_dictionary(_); end
end

class Zlib::Deflate
  def self.deflate(*_); end
end

class Zlib::Error
end

class Zlib::Error
end

class Zlib::GzipFile
  def close(); end

  def closed?(); end

  def comment(); end

  def crc(); end

  def finish(); end

  def level(); end

  def mtime(); end

  def orig_name(); end

  def os_code(); end

  def sync(); end

  def sync=(sync); end

  def to_io(); end
end

class Zlib::GzipFile::CRCError
end

class Zlib::GzipFile::CRCError
end

class Zlib::GzipFile::Error
  def input(); end
end

class Zlib::GzipFile::Error
end

class Zlib::GzipFile::LengthError
end

class Zlib::GzipFile::LengthError
end

class Zlib::GzipFile::NoFooter
end

class Zlib::GzipFile::NoFooter
end

class Zlib::GzipFile
  def self.wrap(*_); end
end

class Zlib::GzipReader
  include ::Enumerable
  def bytes(); end

  def each(*_); end

  def each_byte(); end

  def each_char(); end

  def each_line(*_); end

  def eof(); end

  def eof?(); end

  def external_encoding(); end

  def getbyte(); end

  def getc(); end

  def initialize(*_); end

  def lineno(); end

  def lineno=(lineno); end

  def lines(*_); end

  def pos(); end

  def read(*_); end

  def readbyte(); end

  def readchar(); end

  def readpartial(*_); end

  def rewind(); end

  def tell(); end

  def ungetbyte(_); end

  def ungetc(_); end

  def unused(); end
end

class Zlib::GzipReader
  def self.open(*_); end
end

class Zlib::GzipWriter
  def <<(_); end

  def comment=(comment); end

  def flush(*_); end

  def initialize(*_); end

  def mtime=(mtime); end

  def orig_name=(orig_name); end

  def pos(); end

  def tell(); end

  def write(_); end
end

class Zlib::GzipWriter
  def self.open(*_); end
end

class Zlib::Inflate
  def <<(_); end

  def add_dictionary(_); end

  def inflate(_); end

  def initialize(*_); end

  def set_dictionary(_); end

  def sync(_); end

  def sync_point?(); end
end

class Zlib::Inflate
  def self.inflate(_); end
end

class Zlib::MemError
end

class Zlib::MemError
end

class Zlib::NeedDict
end

class Zlib::NeedDict
end

class Zlib::StreamEnd
end

class Zlib::StreamEnd
end

class Zlib::StreamError
end

class Zlib::StreamError
end

class Zlib::VersionError
end

class Zlib::VersionError
end

class Zlib::ZStream
  def adler(); end

  def avail_in(); end

  def avail_out(); end

  def avail_out=(avail_out); end

  def close(); end

  def closed?(); end

  def data_type(); end

  def end(); end

  def ended?(); end

  def finish(); end

  def finished?(); end

  def flush_next_in(); end

  def flush_next_out(); end

  def reset(); end

  def stream_end?(); end

  def total_in(); end

  def total_out(); end
end

class Zlib::ZStream
end

module Zlib
  extend ::T::Sig
  def self.adler32(*_); end

  def self.adler32_combine(_, _1, _2); end

  def self.crc32(*_); end

  def self.crc32_combine(_, _1, _2); end

  def self.crc_table(); end

  def self.deflate(*_); end

  def self.inflate(_); end

  def self.zlib_version(); end
end
